<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Mysql | AnXiang</title><meta name="author" content="暗香依飘"><meta name="copyright" content="暗香依飘"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="sqlsql语法数据定义DDL 数据操纵DML 数据查询DQL 数据控制DCL 事务管理TPL 指针控制 mysql -u root -p &#x2F;&#x2F;数据定义DDLcreate database database_name default character set utf8；show databases;drop database database_name;use database_name ;cr">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql">
<meta property="og:url" content="https://anxiangyipiao.github.io/anxiangblog.github.io/2024/07/09/mysql/index.html">
<meta property="og:site_name" content="AnXiang">
<meta property="og:description" content="sqlsql语法数据定义DDL 数据操纵DML 数据查询DQL 数据控制DCL 事务管理TPL 指针控制 mysql -u root -p &#x2F;&#x2F;数据定义DDLcreate database database_name default character set utf8；show databases;drop database database_name;use database_name ;cr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://anxiangyipiao.github.io/anxiangblog.github.io/img/home.jpg">
<meta property="article:published_time" content="2024-07-09T02:42:59.732Z">
<meta property="article:modified_time" content="2024-07-09T03:06:43.991Z">
<meta property="article:author" content="暗香依飘">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://anxiangyipiao.github.io/anxiangblog.github.io/img/home.jpg"><link rel="shortcut icon" href="/anxiangblog.github.io/img/favicon.png"><link rel="canonical" href="https://anxiangyipiao.github.io/anxiangblog.github.io/2024/07/09/mysql/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/anxiangblog.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/anxiangblog.github.io/',
  algolia: undefined,
  localSearch: {"path":"/anxiangblog.github.io/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mysql',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-09 11:06:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/anxiangblog.github.io/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/anxiangblog.github.io/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/anxiangblog.github.io/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 娱乐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/anxiangblog.github.io/./img/home.jpg')"><nav id="nav"><span id="blog-info"><a href="/anxiangblog.github.io/" title="AnXiang"><span class="site-name">AnXiang</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 娱乐</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Mysql</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-09T03:06:43.991Z" title="更新于 2024-07-09 11:06:43">2024-07-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/anxiangblog.github.io/categories/%E4%B8%93%E4%B8%9A/">专业</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Mysql"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h1><h2 id="sql语法"><a href="#sql语法" class="headerlink" title="sql语法"></a>sql语法</h2><p>数据定义DDL</p>
<p>数据操纵DML</p>
<p>数据查询DQL</p>
<p>数据控制DCL</p>
<p>事务管理TPL</p>
<p>指针控制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p </span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>数据定义DDL</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database database_name <span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8；</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> database database_name;</span><br><span class="line"></span><br><span class="line">use database_name ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tablename(字段名<span class="number">1</span> 字段类型<span class="number">1</span>(字段长度),字段名<span class="number">2</span> 字段类型<span class="number">2</span>(字段长度));</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">desc</span> tablename;  查看表结构</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tablename;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename xxx(操作) 修改表</span><br><span class="line"></span><br><span class="line">修改列名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename change 原列名 想改成的列名 列类型;</span><br><span class="line">修改表的名字</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename rename 新表名 ;</span><br><span class="line">修改列的类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename modify  列名 想改的类型;</span><br><span class="line">增加某列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">add</span> 列名 类型;</span><br><span class="line">删除某列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">drop</span> 列名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);	#值的个数、顺序要和字段的个数、顺序一样</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename.列名<span class="number">1</span>,tablename.列名<span class="number">2</span> <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);#给某一列添加数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tablename <span class="keyword">set</span> 字段名 <span class="operator">=</span> 值；</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tablename;<span class="comment">---删除全部表记录(表还在)</span></span><br><span class="line"></span><br><span class="line">防止中文乱码</span><br><span class="line"><span class="keyword">set</span> name gbk;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### 主键约束</span><br><span class="line"></span><br><span class="line">create table tablename(字段名1 字段类型1(字段长度) **primary key auto_increment**,</span><br><span class="line">                字段名2 字段类型2(字段长度));</span><br><span class="line"></span><br><span class="line">#### 非空约束</span><br><span class="line"></span><br><span class="line">create table tablename(字段名1 字段类型1(字段长度),</span><br><span class="line">                字段名2 字段类型2(字段长度) **not null** );</span><br><span class="line"></span><br><span class="line">#### 唯一约束</span><br><span class="line"></span><br><span class="line">create table tablename(字段名1 字段类型1(字段长度),</span><br><span class="line">                字段名2 字段类型2(字段长度) **unique** );</span><br><span class="line"></span><br><span class="line">#### 默认约束</span><br><span class="line"></span><br><span class="line">sex CHAR(2) **DEFAULT** &#x27;男&#x27;</span><br><span class="line"></span><br><span class="line">#### 检查约束</span><br><span class="line"></span><br><span class="line">create table tablename(</span><br><span class="line">age INT, </span><br><span class="line">CHECK (age&gt;0 AND age&lt;=200)</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">#### 外检约束</span><br><span class="line"></span><br><span class="line">FOREIGN KEY (本表(子表)主键) REFERENCES 外表(主表)名(外表主键)</span><br></pre></td></tr></table></figure>

<h2 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全转小写：lower</span><br><span class="line">SELECT lower(ename) FROM emp;</span><br><span class="line">全转大写：upper</span><br><span class="line">SELECT upper(ename) FROM emp;</span><br><span class="line">获取长度：length</span><br><span class="line">一个字母、数字长度为1，一个汉字为3。跟底层编码表有关</span><br><span class="line">SELECT dname,LENGTH(dname) FROM dept;</span><br><span class="line"></span><br><span class="line">concat：拼接字符串</span><br><span class="line">SELECT concat(dname,&#x27;hello&#x27;) FROM dept;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">substr：截取字符串</span><br><span class="line">substr(1,2) 1:字段名	2:从那个字符开始</span><br><span class="line">	SELECT substr(dname,3) FROM dept;---------从第三个字母后开始截取，直到结束</span><br><span class="line">	substr(1,2,3) 1:字段名	2：从那个字符开始 3：截取长度</span><br><span class="line">	SELECT substr(dname,3,2) FROM dept;-------从第三个字母后开始截取，截取两个字母</span><br><span class="line"></span><br><span class="line">replace:替换字符</span><br><span class="line">replace(1,2,3):替换字符 1：字段名  把2替换成3</span><br><span class="line"></span><br><span class="line">SELECT dname,REPLACE(dname,&#x27;a&#x27;,&#x27;666&#x27;) FROM dept;</span><br><span class="line"></span><br><span class="line">ifnull：判断是否为空</span><br><span class="line">ifnull(1,2)----判断1是否为null，为null，替换为2.不为null，不管</span><br><span class="line"></span><br><span class="line">SELECT comm,IFNULL(comm,200) FROM emp;</span><br><span class="line">	</span><br><span class="line">round：四舍五入</span><br><span class="line">SELECT comm,ROUND(comm)FROM emp;</span><br><span class="line"></span><br><span class="line">ceil 向上取整</span><br><span class="line">SELECT comm,CEIL(comm) FROM emp;</span><br><span class="line"></span><br><span class="line">floor 向下取整</span><br><span class="line">	SELECT comm,FLOOR(comm) FROM emp;</span><br><span class="line">	</span><br><span class="line">时间函数：</span><br><span class="line">now()----------------获取当前时间(年月日时分秒)</span><br><span class="line"></span><br><span class="line">year(now())--------获取当前时间的年份</span><br><span class="line"></span><br><span class="line">month(now())------获取当前时间的月份</span><br><span class="line"></span><br><span class="line">day(now())---------获取当前时间的日份</span><br><span class="line"></span><br><span class="line">hour(now())--------获取当前时间的时份</span><br><span class="line"></span><br><span class="line">minute(now())-----获取当前时间的分份</span><br><span class="line"></span><br><span class="line">second(now())-----获取当前时间的秒份</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">distinct</span>:去重</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> 字段名 <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span>条件：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名<span class="number">1</span> <span class="operator">=</span> 条件<span class="number">1</span> <span class="keyword">and</span> 字段名<span class="number">2</span> <span class="operator">=</span> 条件<span class="number">2</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名<span class="number">1</span> <span class="operator">=</span> 条件<span class="number">1</span> <span class="keyword">or</span> 字段名<span class="number">2</span> <span class="operator">=</span> 条件<span class="number">2</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">in</span> (条件<span class="number">1</span>,条件<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">模糊查询：<span class="keyword">like</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">LIKE</span> <span class="string">&#x27;%o%&#x27;</span>;#低效</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">LIKE</span> <span class="string">&#x27;o%&#x27;</span>;#最高效</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">LIKE</span> <span class="string">&#x27;%o&#x27;</span>;#高效</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">LIKE</span><span class="string">&#x27;l__&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span>操作空数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">IS</span> <span class="keyword">not</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">区间范围:between...and...是包含的关系</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">BETWEEN</span> <span class="number">3000</span> <span class="keyword">AND</span> <span class="number">10000</span>;#等效包含<span class="number">3000</span>、<span class="number">10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分页:limit</span><br><span class="line">#查询表中前两条信息</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename limit <span class="number">2</span>;	</span><br><span class="line">#从第二行,展示两条信息</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename LIMIT <span class="number">1</span>,<span class="number">2</span>;  #从n<span class="operator">+</span><span class="number">1</span>行开始展示,要展示的行数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">排序:<span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">ORDER</span> <span class="keyword">BY</span>  字段名;#默认升序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名 <span class="keyword">DESC</span>;#降序</span><br><span class="line"></span><br><span class="line">#查询的是数字<span class="comment">---按照数字排序</span></span><br><span class="line">#查询的是字母<span class="comment">---按照字母的顺序</span></span><br><span class="line">#查询的是生日<span class="comment">---按照数值排序</span></span><br><span class="line">#查询的是汉字<span class="comment">---按照汉字对应在utf8编码表中数字进行排序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查最大值：max</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(字段名)  <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">查最小值：min</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(字段名)  <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">查平均值：avg</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(字段名) 平均工资 <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">求和：sum</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(字段名) 求和 <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">统计个数count</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">分组： <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">查询时，出现了混合列(聚合列跟非聚合列)的现象是不行的，必须分组</span><br><span class="line"></span><br><span class="line">#查询每个部门的最高薪<span class="comment">---部门编号deptno---薪水sal	</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno, <span class="built_in">MAX</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line">#		非聚合列,聚合列</span><br><span class="line"></span><br><span class="line"><span class="keyword">having</span>:完成分组后过滤</span><br><span class="line">#查询每个部门的人数，人数<span class="operator">&gt;</span><span class="number">1</span>的部门</span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="operator">&gt;</span><span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">开始事务</span><br><span class="line"><span class="keyword">start</span> transaction</span><br><span class="line"></span><br><span class="line">结束事务之提交事务</span><br><span class="line"><span class="keyword">commit</span></span><br><span class="line"></span><br><span class="line">结束事务之回滚事务</span><br><span class="line"><span class="keyword">rollback</span></span><br><span class="line"></span><br><span class="line">索引</span><br><span class="line">查看索引</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line">创建单值索引</span><br><span class="line"><span class="keyword">create</span> index indexname <span class="keyword">on</span> 表名(字段名);</span><br><span class="line"></span><br><span class="line">创建唯一索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index indexname <span class="keyword">on</span> tablename(字段名);</span><br><span class="line"></span><br><span class="line">创建复合索引</span><br><span class="line"><span class="keyword">create</span> index indexname <span class="keyword">on</span> tablename(字段名<span class="number">1</span>, 字段名<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">删除索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">drop</span> index indexname; </span><br><span class="line"></span><br><span class="line">使用普通索引，唯一索引</span><br><span class="line">explain	<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename <span class="keyword">where</span> 字段名 <span class="operator">=</span> 字段值;</span><br><span class="line"></span><br><span class="line">使用复合索引</span><br><span class="line">explain	<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename <span class="keyword">where</span> 字段名<span class="number">1</span> <span class="operator">=</span> 字段值  <span class="keyword">and</span> 字段名<span class="number">2</span> <span class="operator">=</span> 字段值;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="多表联查"><a href="#多表联查" class="headerlink" title="多表联查"></a>多表联查</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tablename1,tablename2 </span><br><span class="line">				where tablename1.字段名 = tablename2.字段名	#表关系</span><br><span class="line">                and tablename1.字段名2 = 字段值;				#业务关系</span><br><span class="line"></span><br><span class="line">连接查询</span><br><span class="line">内连接-----inner join: 取两个表的交集</span><br><span class="line"></span><br><span class="line">SELECT * FROM tablename1 INNER JOIN tablename2 </span><br><span class="line">						ON  tablename1.`deptno` = tablename2.`deptno`#表关系</span><br><span class="line">						where tablename1.字段名2 = 字段值;#业务关系</span><br><span class="line"></span><br><span class="line">外左连接-----left join :左表的所有和右表满足条件的，不满足是null</span><br><span class="line">SELECT * FROM tablename1 left JOIN tablename2 </span><br><span class="line">						ON  tablename1.`deptno` = tablename2.`deptno`#表关系</span><br><span class="line">						where tablename1.字段名1 = 字段值;#业务关系</span><br><span class="line"></span><br><span class="line">外右连接-----right join :右表的所有和左表满足条件的，不满足是null</span><br><span class="line">SELECT * FROM tablename1 right JOIN tablename2 </span><br><span class="line">						ON  tablename1.`deptno` = tablename2.`deptno`#表关系</span><br><span class="line">						where tablename1.字段名2 = 字段值;#业务关系</span><br><span class="line"></span><br><span class="line">子查询</span><br><span class="line">SELECT * FROM tablename1 WHERE 字段名1 IN (SELECT 字段名1 FROM tablename2 WHERE 字段名2 = &#x27;字段值&#x27;);</span><br><span class="line"></span><br><span class="line">视图</span><br><span class="line"></span><br><span class="line">创建视图</span><br><span class="line">create view view_name as SQL查询语句</span><br><span class="line">使用视图</span><br><span class="line">select * from view_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="数据库分页"><a href="#数据库分页" class="headerlink" title="数据库分页"></a>数据库分页</h2><p>在MySQL中，SELECT语句默认返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句，以实现分页查询。LIMIT子句的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 在所有的查询结果中，返回前5行记录。 </span><br><span class="line">SELECT prod_name FROM products LIMIT 5;</span><br><span class="line"></span><br><span class="line">-- 在所有的查询结果中，从第5行开始，返回5行记录。 </span><br><span class="line">SELECT prod_name FROM products LIMIT 5,5;</span><br><span class="line"></span><br><span class="line">总之，带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。</span><br></pre></td></tr></table></figure>

<p>在偏移量非常大的时候，例如 LIMIT 10000,20 这样的查询，这时MySQL需要查询10020条记录然后只返回最后20条，前面的10000条记录都将被抛弃，这样的代价是非常高的。如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。</p>
<p>优化此类分页查询的一个最简单的办法就是尽可能地使用<strong>索引覆盖扫描</strong>，*<em>而不是查询所有的列</em>***，然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候，这样做的效率会提升非常大。考虑下面的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT film_id,description FROM sakila.film ORDER BY title LIMIT 50,5;</span><br></pre></td></tr></table></figure>

<p>如果这个表非常大，那么这个查询最好改写成下面的样子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id,film.description  <span class="keyword">FROM</span> sakila.film <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (  <span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> sakila.film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">50</span>,<span class="number">5</span> ) <span class="keyword">AS</span> lim <span class="keyword">USING</span>(film_id);</span><br></pre></td></tr></table></figure>

<p><strong>这里的“延迟关联”将大大提升查询效率，它让MySQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用于优化关联查询中的LIMIT子句。</strong></p>
<p>有时候也可以将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得对应的结果。例如，如果在一个位置列上有索引，并且预先计算出了边界值，上面的查询就可以改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT film_id,description FROM skila.film WHERE position BETWEEN 50 AND 54 ORDER BY position;</span><br></pre></td></tr></table></figure>

<p>对数据进行排名的问题也与此类似，但往往还会同时和GROUP BY混合使用，在这种情况下通常都需要预先计算并存储排名信息。</p>
<p>LIMIT和OFFSET的问题，其实是OFFSET的问题，它<strong>会导致MySQL扫描大量不需要的行然后再抛弃掉。如果可以使用书签记录上次取数的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET</strong>。例如，若需要按照租赁记录做翻页，那么可以根据最新一条租赁记录向后追溯，这种做法可行是因为租赁记录的主键是单调增长的。首先使用下面的查询获得第一组结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM sakila.rental ORDER BY rental_id DESC LIMIT 20;</span><br></pre></td></tr></table></figure>

<p>假设上面的查询返回的是主键16049到16030的租赁记录，那么下一页查询就可以从16030这个点开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM sakila.rental  WHERE rental_id &lt; 16030 ORDER BY rental_id DESC LIMIT 20;</span><br></pre></td></tr></table></figure>

<p>该技术的好处是无论翻页到多么后面，其性能都会很好。</p>
<h2 id="介绍一下SQL中的聚合函数"><a href="#介绍一下SQL中的聚合函数" class="headerlink" title="介绍一下SQL中的聚合函数"></a>介绍一下SQL中的聚合函数</h2><p><strong>参考答案</strong></p>
<p>常用的聚合函数有COUNT()、AVG()、SUM()、MAX()、MIN()，下面以MySQL为例，说明这些函数的作用。</p>
<p>COUNT()函数：</p>
<p>COUNT()函数统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数，它有两种用法：</p>
<ul>
<li>COUNT(*)计算表中总的行数，不管某列是否有数值或者为空值。</li>
<li>COUNT(字段名)计算指定列下总的行数，计算时将忽略空值的行。</li>
</ul>
<p>COUNT()函数可以与GROUP BY一起使用来计算每个分组的总和。</p>
<p>AVG()函数()：</p>
<p>AVG()函数通过计算返回的行数和每一行数据的和，求得指定列数据的平均值。</p>
<p>AVG()函数可以与GROUP BY一起使用，来计算每个分组的平均值。</p>
<p>SUM()函数：</p>
<p>SUM()是一个求总和的函数，返回指定列值的总和。</p>
<p>SUM()可以与GROUP BY一起使用，来计算每个分组的总和。</p>
<p>MAX()函数：</p>
<p>MAX()返回指定列中的最大值。</p>
<p>MAX()也可以和GROUP BY关键字一起使用，求每个分组中的最大值。</p>
<p><strong>MAX()函数不仅适用于查找数值类型，也可应用于字符类型。</strong></p>
<p>MIN()函数：</p>
<p>MIN()返回查询列中的最小值。</p>
<p>MIN()也可以和GROUP BY关键字一起使用，求出每个分组中的最小值。</p>
<p>MIN()函数与MAX()函数类似，不仅适用于查找数值类型，也可应用于字符类型。</p>
<h2 id="表跟表是怎么关联的？"><a href="#表跟表是怎么关联的？" class="headerlink" title="表跟表是怎么关联的？"></a>表跟表是怎么关联的？</h2><p><strong>参考答案</strong></p>
<p>表与表之间常用的关联方式有两种：内连接、外连接，下面以MySQL为例来说明这两种连接方式。</p>
<p>内连接：</p>
<p>内连接通过INNER JOIN来实现，<strong>它将返回两张表中满足连接条件的数据，不满足条件的数据不会查询出来。</strong></p>
<p>外连接：</p>
<p>外连接通过OUTER JOIN来实现，<strong>它会返回两张表中满足连接条件的数据，同时返回不满足连接条件的数据</strong>。<strong>外连接有两种形式：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）</strong>。</p>
<ul>
<li>左外连接：可以简称为左连接（LEFT JOIN），<strong>它会返回左表中的所有记录和右表中满足连接条件的记录。</strong></li>
<li>右外连接：可以简称为右连接（RIGHT JOIN）<strong>，它会返回右表中的所有记录和左表中满足连接条件的记录。</strong></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SELECT &lt;字段名&gt; </span><br><span class="line">FROM &lt;表a&gt; </span><br><span class="line">JOIN &lt;表b&gt; </span><br><span class="line">ON a.&lt;字段名&gt; = b.&lt;字段名&gt; ;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Students AS s</span><br><span class="line">JOIN Teachers AS t</span><br><span class="line">ON s.Tid = t.Tid</span><br><span class="line"></span><br><span class="line">使用USING</span><br><span class="line">SELECT film.film_id, film.description</span><br><span class="line">FROM sakila.film</span><br><span class="line">INNER JOIN (</span><br><span class="line">    -- 子查询，获取前50部电影的 film_id</span><br><span class="line">    SELECT film_id</span><br><span class="line">    FROM sakila.film</span><br><span class="line">    ORDER BY title</span><br><span class="line">    LIMIT 50, 5</span><br><span class="line">) AS lim</span><br><span class="line">USING (film_id);</span><br><span class="line"></span><br><span class="line">使用on</span><br><span class="line">SELECT film.film_id, film.description</span><br><span class="line">FROM sakila.film</span><br><span class="line">INNER JOIN (</span><br><span class="line">    -- 子查询，获取前50部电影的 film_id</span><br><span class="line">    SELECT film_id</span><br><span class="line">    FROM sakila.film</span><br><span class="line">    ORDER BY title</span><br><span class="line">    LIMIT 50, 5</span><br><span class="line">) AS lim</span><br><span class="line">ON film.film_id = lim.film_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除此之外，还有一种常见的连接方式：<strong>等值连接</strong>。这种连接是通过<strong>WHERE子句中的条件</strong>，将两张表连接在一起，<strong>它的实际效果等同于内连接</strong>。出于语义清晰的考虑，一般更建议使用内连接，而不是等值连接。</p>
<p>以上是从语法上来说明表与表之间关联的实现方式，而从表的关系上来说，比较常见的关联关系有：一对多关联、多对多关联、自关联。</p>
<ul>
<li><strong>一对多关联：这种关联形式最为常见，一般是两张表具有主从关系</strong>，并且以主表的主键关联从表的外键来实现这种关联关系。另外，以从表的角度来看，它们是具有多对一关系的，所以不再赘述多对一关联了。</li>
<li><strong>多对多关联：这种关联关系比较复杂，如果两张表具有多对多的关系，那么它们之间需要有一张中间表来作为衔接，以实现这种关联关系</strong>。这个中间表要设计两列，分别存储那两张表的主键。因此，这两张表中的任何一方，都与中间表形成了一对多关系，从而在这个中间表上建立起了多对多关系。</li>
<li><strong>自关联：自关联就是一张表自己与自己相关联，为了避免表名的冲突，需要在关联时通过别名将它们当做两张表来看待</strong>。一般在表中数据具有层级（树状）时，可以采用自关联一次性查询出多层级的数据。</li>
</ul>
<h2 id="SQL中怎么将行转成列？"><a href="#SQL中怎么将行转成列？" class="headerlink" title="SQL中怎么将行转成列？"></a>SQL中怎么将行转成列？</h2><p>在 SQL 中，将行转换为列的操作称为数据透视（Pivot）</p>
<p><strong>1. 使用 CASE 表达式：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> category <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">THEN</span> <span class="keyword">value</span> <span class="keyword">END</span>) <span class="keyword">AS</span> value_A,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> category <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span> <span class="keyword">THEN</span> <span class="keyword">value</span> <span class="keyword">END</span>) <span class="keyword">AS</span> value_B,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> category <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span> <span class="keyword">THEN</span> <span class="keyword">value</span> <span class="keyword">END</span>) <span class="keyword">AS</span> value_C</span><br><span class="line"><span class="keyword">FROM</span> your_table;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>category</code> 是一个列，<code>value</code> 是另一个列。我们使用 <code>CASE</code> 表达式将不同的 <code>category</code> 对应的 <code>value</code> 放在不同的列中，然后使用聚合函数（这里用的是 <code>MAX</code>）来获取每个列的值</p>
<p> 2.<strong>使用 PIVOT：</strong></p>
<p>某些数据库系统（如 SQL Server 和 Oracle）提供了 <code>PIVOT</code> 关键字，用于更方便地执行数据透视操作。示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> your_table</span><br><span class="line">PIVOT (</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">value</span>) <span class="keyword">FOR</span> category <span class="keyword">IN</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">) <span class="keyword">AS</span> pivot_table;</span><br></pre></td></tr></table></figure>

<p>这里，<code>category</code> 列的值 (‘A’, ‘B’, ‘C’) 将会成为新表的列名，对应的 <code>value</code> 列的值将填充到相应的列中。</p>
<p>首先，假设我们有一张分数表（tb_score），表中的数据如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789565340/54AFB38EE7925F020B8244A971AD0197" alt="img"></p>
<p>然后，我们再来看一下转换之后需要得到的结果，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789578254/4D7E0B1F85854406C0011E8D87BD5BBB" alt="img"></p>
<ol>
<li><p>使用 CASE…WHEN…THEN 语句实现行转列，参考如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT userid, </span><br><span class="line">SUM(CASE `subject` WHEN &#x27;语文&#x27; THEN score ELSE 0 END) as &#x27;语文&#x27;, </span><br><span class="line">SUM(CASE `subject` WHEN &#x27;数学&#x27; THEN score ELSE 0 END) as &#x27;数学&#x27;, </span><br><span class="line">SUM(CASE `subject` WHEN &#x27;英语&#x27; THEN score ELSE 0 END) as &#x27;英语&#x27;, </span><br><span class="line">SUM(CASE `subject` WHEN &#x27;政治&#x27; THEN score ELSE 0 END) as &#x27;政治&#x27;  </span><br><span class="line">FROM tb_score  </span><br><span class="line">GROUP BY userid</span><br></pre></td></tr></table></figure>

<p>注意，SUM() 是为了能够使用GROUP BY根据userid进行分组，因为每一个userid对应的subject&#x3D;”语文”的记录只有一条，所以SUM() 的值就等于对应那一条记录的score的值。假如userid &#x3D;’001’ and subject&#x3D;’语文’ 的记录有两条，<strong>则此时SUM() 的值将会是这两条记录的和</strong>，同理，<strong>使用Max()的值将会是这两条记录里面值最大的一个</strong>。但是正常情况下，一个user对应一个subject只有一个分数，<strong>因此可以使用SUM()、MAX()、MIN()、AVG()等聚合函数都可以达到行转列的效果</strong>。</p>
</li>
<li><p>使用 IF() 函数实现行转列，参考如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT userid, SUM(IF(`subject`=&#x27;语文&#x27;,score,0)) as &#x27;语文&#x27;, SUM(IF(`subject`=&#x27;数学&#x27;,score,0)) as &#x27;数学&#x27;, SUM(IF(`subject`=&#x27;英语&#x27;,score,0)) as &#x27;英语&#x27;, SUM(IF(`subject`=&#x27;政治&#x27;,score,0)) as &#x27;政治&#x27;  FROM tb_score  GROUP BY userid</span><br></pre></td></tr></table></figure>

<p>注意，IF(subject&#x3D;’语文’,score,0) 作为条件，即对所有subject&#x3D;’语文’的记录的score字段进行SUM()、MAX()、MIN()、AVG()操作，如果score没有值则默认为0。</p>
</li>
</ol>
<h2 id="谈谈你对SQL注入的理解"><a href="#谈谈你对SQL注入的理解" class="headerlink" title="谈谈你对SQL注入的理解"></a>谈谈你对SQL注入的理解</h2><p><strong>SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，在一些对SERVER端发起的请求参数中植入一些SQL代码，SERVER端在执行SQL操作时，会拼接对应参数，同时也将一些SQL注入攻击的“SQL”拼接起来，导致会执行一些预期之外的操作。</strong></p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE username = &#x27;ls&#x27; AND password = &#x27;123456&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>SQL中会将#及–以后的字符串当做注释处理</strong>，如果我们使用 ‘ or 1&#x3D;1 # 作为用户名参数，那么服务端构建的SQL语句就如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where username=&#x27;&#x27; or 1=1 #&#x27; and password=&#x27;123456&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>而#会忽略后面的语句，而1&#x3D;1属于常等型条件</strong>，因此这个SQL将查询出所有的登录用户。其实上面的SQL注入只是在参数层面做了些手脚，如果是引入了一些功能性的SQL那就更危险了，比如上面的登录功能，如果用户名使用这个 ‘ or 1&#x3D;1;delete * from users; #，那么在”;”之后相当于是另外一条新的SQL，这个SQL是删除全表，是非常危险的操作，因此SQL注入这种还是需要特别注意的。</p>
<p>如何解决SQL注入</p>
<ol>
<li><p>SQL预编译</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span></span><br><span class="line"><span class="keyword">with</span> sqlite3.connect(<span class="string">&quot;mydb.db&quot;</span>) <span class="keyword">as</span> connection:</span><br><span class="line">    cursor = connection.cursor()</span><br><span class="line">    cursor.execute(sql, (enteredUsername, enteredPassword))</span><br><span class="line">    results = cursor.fetchall()</span><br></pre></td></tr></table></figure>

<p><strong>将查询与参数分开，确保输入的参数值不会被解释为 SQL 代码的一部分，不仅提升性能，而且防止SQL注入</strong>。</p>
</li>
<li><p><strong>使用参数化查询</strong>：使用数据库驱动或框架提供的参数化查询机制，将用户输入作为参数传递给查询，而不是将其拼接到查询字符串中。</p>
</li>
<li><p><strong>数据验证和过滤</strong>：对用户输入进行严格的验证和过滤，确保只接受预期的数据类型和格式。</p>
</li>
<li><p><strong>转义字符</strong>：对输入进行适当的字符转义，以防止特殊字符被误解为 SQL 代码。</p>
</li>
<li><p><strong>最小权限原则</strong>：在数据库配置中，为应用程序使用的数据库账户分配最小必要的权限，避免攻击者通过注入攻击访问不应该访问的数据。</p>
</li>
<li><p><strong>定期更新和维护</strong>：保持数据库引擎和应用程序库的更新，以获取最新的安全性修复。</p>
</li>
<li><p><strong>安全开发实践</strong>：开发人员需要了解并遵循安全的编程实践，以最大程度地减少安全漏洞。</p>
</li>
</ol>
<h2 id="将一张表的部分数据更新到另一张表，该如何操作呢？"><a href="#将一张表的部分数据更新到另一张表，该如何操作呢？" class="headerlink" title="将一张表的部分数据更新到另一张表，该如何操作呢？"></a>将一张表的部分数据更新到另一张表，该如何操作呢？</h2><p><strong>参考答案</strong></p>
<p>可以采用关联更新的方式，将一张表的部分数据，更新到另一张表内。参考如下代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> target_table <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">JOIN</span> source_table <span class="keyword">AS</span> s <span class="keyword">ON</span> t.id <span class="operator">=</span> s.id</span><br><span class="line"><span class="keyword">SET</span> t.name <span class="operator">=</span> s.name, t.age <span class="operator">=</span> s.age</span><br><span class="line"><span class="keyword">WHERE</span> t.id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> 语句来将 source_table 中 id 为 <span class="number">2</span> 的行的数据更新到 target_table 中。我们使用 <span class="keyword">JOIN</span> 子句来关联两个表，然后使用 <span class="keyword">SET</span> 子句指定要更新的列和更新值。最后，使用 <span class="keyword">WHERE</span> 子句来指定更新的条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> b <span class="keyword">set</span> b.col<span class="operator">=</span>a.col <span class="keyword">from</span> a,b <span class="keyword">where</span> a.id<span class="operator">=</span>b.id;</span><br><span class="line"><span class="keyword">update</span> b <span class="keyword">set</span> col<span class="operator">=</span>a.col <span class="keyword">from</span> b <span class="keyword">inner</span> <span class="keyword">join</span> a <span class="keyword">on</span> a.id<span class="operator">=</span>b.id;</span><br><span class="line"><span class="keyword">update</span> b <span class="keyword">set</span> b.col<span class="operator">=</span>a.col <span class="keyword">from</span> b <span class="keyword">left</span> <span class="keyword">Join</span> a <span class="keyword">on</span> b.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure>



<h2 id="WHERE和HAVING有什么区别？"><a href="#WHERE和HAVING有什么区别？" class="headerlink" title="WHERE和HAVING有什么区别？"></a>WHERE和HAVING有什么区别？</h2><p><strong>参考答案</strong></p>
<p>WHERE是一个<strong>约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数。</strong></p>
<p>HAVING是一个<strong>过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在HAVING中可以使用聚合函数</strong>。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。</p>
<p>从性能的角度来说，<strong>HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。</strong> <code>HAVING</code> 子句只能在 <code>SELECT</code> 查询中使用。</p>
<h2 id="说一说你对MySQL索引的理解"><a href="#说一说你对MySQL索引的理解" class="headerlink" title="说一说你对MySQL索引的理解"></a>说一说你对MySQL索引的理解</h2><p><strong>索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针</strong>。使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，<strong>对相关列使用索引是提高查询操作速度的最佳途径。</strong></p>
<p>索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY&#x2F;HEAP存储引擎可以支持HASH和BTREE索引。</p>
<p>索引的优点主要有以下几条：</p>
<ol>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可<strong>以大大加快数据的查询速度，这也是创建索引的主要原因。</strong></li>
<li><strong>在实现数据的参考完整性方面，可以加速表和表之间的连接。</strong></li>
<li><strong>在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。</strong></li>
</ol>
<p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<ol>
<li><strong>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。</strong></li>
<li><strong>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。</strong></li>
<li><strong>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</strong></li>
</ol>
<h2 id="索引有哪几种？"><a href="#索引有哪几种？" class="headerlink" title="索引有哪几种？"></a>索引有哪几种？</h2><p><strong>参考答案</strong></p>
<p>MySQL的索引可以分为以下几类：</p>
<ol>
<li><p><strong>普通索引和唯一索引</strong></p>
<p><strong>普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。</strong></p>
<p><strong>唯一索引要求索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</strong></p>
<p>主键索引是一种特殊的唯一索引，不允许有空值。</p>
</li>
<li><p>单列索引和组合索引</p>
<p>单列索引即一个索引只包含单个列，一个表可以有多个单列索引。</p>
<p>组合索引是指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。<strong>使用组合索引时遵循最左前缀集合。</strong></p>
</li>
<li><p>全文索引</p>
<p>全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。</p>
</li>
<li><p>空间索引</p>
<p>空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MyISAM的表中创建。</p>
</li>
</ol>
<ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong></li>
</ul>
<h3 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h3><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p>
<p>这两个区别在前面也提到了：</p>
<ul>
<li>主<strong>键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</strong></li>
<li><strong>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</strong></li>
</ul>
<p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就<strong>不需要回表，这个过程就是覆盖索引</strong>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p>
<h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，<strong>一张表最多只有一个主键索引，索引列的值不允许有空值</strong>。</p>
<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一索引建立在 <strong>UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</strong></p>
<h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p>
<p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p>
<h3 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h3><p>从字段个数的角度来看，索引分为<strong>单列索引、联合索引</strong>（复合索引）。</p>
<ul>
<li>建立在单列上的索引称为单列索引，比如主键索引；</li>
<li>建立在多列上的索引称为联合索引；</li>
</ul>
<h2 id="如何判断数据库的索引有没有生效？"><a href="#如何判断数据库的索引有没有生效？" class="headerlink" title="如何判断数据库的索引有没有生效？"></a>如何判断数据库的索引有没有生效？</h2><p>可以使用EXPLAIN语句查看索引是否正在使用。</p>
<p>举例，假设已经创建了book表，并已经在其year_publication字段上建立了普通索引。执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM book WHERE year_publication=1990;</span><br><span class="line"></span><br><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure>

<p>EXPLAIN语句将为我们输出详细的SQL执行信息，其中：</p>
<ul>
<li><strong>possible_keys</strong>行给出了MySQL在搜索数据记录时可选用的各个索引。</li>
<li><strong>key行是MySQL实际选用的索引</strong>。</li>
</ul>
<p><strong>如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。</strong></p>
<h2 id="如何评估一个索引创建的是否合理？"><a href="#如何评估一个索引创建的是否合理？" class="headerlink" title="如何评估一个索引创建的是否合理？"></a>如何评估一个索引创建的是否合理？</h2><p>建议按照如下的原则来设计索引：</p>
<ol>
<li><p><strong>避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。应该经常用于查询的字段创建索引，但要避免添加不必要的字段。</strong></p>
</li>
<li><p><strong>数据量小的表最好不要使用索引</strong>，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p>
</li>
<li><p>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引，如果建立索引不但不会提高查询效率，反而会严重降低数据更新速度。</p>
</li>
<li><p>当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。</p>
</li>
<li><p>在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。</p>
</li>
<li><p>数据库事务 ：数据库中一组原子性的SQL操作，彼此状态一致。具有ACID特性。</p>
</li>
<li><p>事务 ACID 特性：</p>
<ul>
<li>原子性：数据库事务是一个整体，其中的SQL操作要么全部提交成功commit要么全部失败回滚rollback，不可分割；</li>
<li>一致性：与原子性有联系。事务总是从一个一致状态转换到另一个一致状态；</li>
<li>隔离性：事务之间彼此互不影响，一个事务在提交之前，对其他事务是不可见的。</li>
<li>持久性：一个事务一旦提交成功，他所做的修改就会永久性的存储在数据库中。</li>
</ul>
</li>
<li><p>MySQL 4 种隔离级别</p>
<ul>
<li>未提交读READ UNCOMMITTED：一个事务在提交之前，对其他事务是可见的，即事务可以读取未提交的数据。存在“脏读”（读到了脏数据）问题；</li>
<li>提交读READ COMMITTED：事务在提交之前，对其它事务是不可见的。存在“不可重复读”（两次查询的得到的结果可能不同，即可能在查询的间隙，有事务提交了修改）问题。解决了“脏读”问题。</li>
<li>可重复读REPEATABLE READ：在同一事务中多次读取的数据是一致的。解决了脏读和不可重复读问题，存在“幻读”（在事务两次查询间隙，有其他事务又插入或删除了新的记录）。— MySQL默认隔离级别。</li>
<li>可串行化SERIALIZABLE：强制事务串行化执行。即一个事物一个事物挨个来执行，可以解决上述所有问题。</li>
</ul>
</li>
<li><p>锁及粒度：</p>
<ul>
<li>共享锁&#x2F;读锁：互不阻塞，优先级低</li>
<li>排他锁&#x2F;写锁：阻塞其他锁，优先级高，即确保在一个事务写入时不受其他事务的影响。</li>
<li>锁粒度：锁定的数据量越少（粒度越小），并发程度越高，但相应的加锁、检测锁、释放锁用的系统开销也随之增大。</li>
<li>锁策略：锁开销与数据安全性之间的平衡<ul>
<li>表锁：锁住整张表，读锁互不阻塞，写锁阻塞其他所有读写锁（同一张表）。开销最小。</li>
<li>行级锁：对每一行数据（记录）加锁，开销大，并发程度高。</li>
</ul>
</li>
</ul>
</li>
<li><p>InnoDB对死锁的处理：此处死锁与OS死锁类似，多个事务互相持有对方所有要申请资源的锁不释放，造成环路死锁。MySQL InnoDB引擎检测到死锁循环依赖后，回滚持有最少行级锁的事务。</p>
</li>
<li><p>索引及其作用和实现方法：</p>
<ul>
<li>概念：对数据库表列进行增加恰当索引，可以快速的找到匹配的记录行数，相比于默认的全表扫描，可以大大加快查找的速度。</li>
<li>作用：加快查找速度；</li>
<li>实现方法：一般分为B+树索引和哈希索引。<ul>
<li>B+树索引：在B-tree上改进得到，其非叶子节点均为key值，叶子节点是key-data键值对。叶子节点前后相连且有序。</li>
<li>哈希索引：通过对key进行hash(crc&#x2F;MD5&#x2F;sha1&#x2F;sha256…)而将记录存储在不同的bucket种，可以做到常数时间的查找，但要注意哈希冲突的避免（链表法、线性探测、二次探测、公共溢出区的方法）。其中MD5 128位，和sha1&#x2F;256码都较长不太适合作为hash函数。默认无序。</li>
<li>为什么有了B+树索引还要hash索引？<ol>
<li>B+树默认有序，hash默认无序，所以哈希索引无法用于排序；</li>
<li>哈希索引O(1)在速度上毋庸置疑要快于B+树近似O(logn);</li>
<li>哈希索引只能进行等值查询（因为他要计算hash(key)再去匹配）而B+树索引可以进行等值、部分前缀、范围查询；</li>
<li>底层实现结构不同：B+树是非线性结构，hash桶是线性结构。</li>
<li>对于某些场景如热点页&#x2F;活跃查询页，需要借助哈希索引来实现快速查询。</li>
</ol>
</li>
</ul>
</li>
<li>索引越多越快？<br>此言差矣，索引并非是虚无缥缈的，是实实在在的一种数据结构（B+树&#x2F;hash桶）要占内存、维护它要系统开销，一般的插入删除都要进行结构的调整，这要消耗时间，所以索引太多反而拖慢查找时间。有时候，见数据量不多时，建立索引还不如全表查询。索引加快了检索的速度，但是插入删除修改都需要DBMS动态更新内部索引结构，要耗费开销。</li>
</ul>
</li>
<li><p>InnoDB MVCC</p>
</li>
<li><p>MVCC 的核心思想是在数据库中为<strong>每个事务创建一个独立的“版本”，这个版本包含了在该事务开始时数据库中的数据快照。每个事务都只能看到自己开始时的数据快照，而不受其他事务的影响。这种机制避免了读-写冲突以及脏读等并发问题。</strong></p>
</li>
<li><p><strong>多版本并发控制</strong>，是为了避免加锁而实现的。一般的实现方法是存储快照来实现的。InnoDB实现方式是在记录后添加两个隐藏列（表项），分别是事务创建时间、过期时间，存储的实际上是系统版本号（系统版本号随着事务的创建而递增）。<br>这样一来，INSERT 时加上开始版本号，UPDATE&#x2F;DELETE时加上过期版本号，这样一来在SELETE时，就只访问开始系统版本号小于当前的事务的版本号、过期时间要么未定义要么在当前版本号之后的记录，这样就可以保证：访问的记录是在本事务开始前就存在而且在本事务期间没有过期（被删除或被修改过的）。可以避免脏读、不可重复读、幻读的问题。（个人觉得）</p>
</li>
<li><p>MySQL存储引擎简介</p>
</li>
</ol>
<ul>
<li><p>InnoDB,最为通用&#x2F;推荐的一种引擎，支持事务、行级锁、甚至间隙锁（避免幻读）、支持热备份，MVCC，在并发上占优势，系统资源占用多。</p>
</li>
<li><p>MyISAM,默认的存储引擎，不支持事务和行级锁，只支持表锁，某些场景性能很好：占用存储上优，查询速度上完胜（大概是InnoDB的3倍）系统资源占用少。</p>
</li>
<li><p>InnoDB支持事务, MyISAM不支持；</p>
</li>
<li><p>InnoDB支持行级锁、表锁；MyISAM只支持表锁；</p>
</li>
<li><p>InnoDB支持MVCC，MyISAM不支持；</p>
</li>
<li><p>InnoDB不支持全文索引，MyISAM支持；</p>
</li>
<li><p>InnoDB支持外键，MyISAM不支持外键；</p>
</li>
<li><p>InnoDB和MyISAM都支持B+树索引，InnoDB还支持自适应哈希索引</p>
</li>
<li><p>MyISAM实现了前缀压缩技术，占用存储空间更小（但会影响查找），InnoDB是原始数据存储，占用存储更大。</p>
<p>PS：大部分情况下，InnoDB都是正确的选择。—《高性能MySQL》</p>
</li>
</ul>
<ol start="11">
<li><p>SQL优化</p>
<ul>
<li>在经常性的检索列上，建立必要索引，以加快搜索速率，避免全表扫描（索引覆盖扫描）；</li>
<li>多次查询同样的数据，可以考虑缓存该组数据；</li>
<li>审视select * form tables, 你需要所有列数据吗？</li>
<li>切分查询（大查询切分成为小查询，避免一次性锁住大量数据）</li>
<li>分解关联查询（单表查询，结果在应用程序中进行关联，可以减少处理过程中的锁争用）</li>
<li>尽量先做单表查询；</li>
<li>…</li>
</ul>
</li>
<li><p>profile 的作用和用法<br>用于保存SQL语句执行状态，需要手动开启，才可以查看。</p>
<blockquote>
<p>set profiling &#x3D; 1; 开启<br>show profiles; 显示SQL查询的profiles概况<br>show profile all for query X; 查看第X条语句的所有执行情况。<br>show profile cpu, block io, memory for query X; 查看部分profile信息。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://uploadfiles.nowcoder.com/files/20190731/9084855_1564581954903_1027722-20190731141049676-1016503398.png" alt="img"></p>
</blockquote>
</li>
<li><p>MySQL查询的步骤</p>
<ul>
<li>客户端发送查询到服务器；</li>
<li>服务器检查查询缓存query ***（大小写敏感的哈希查找，常数时间）。如果命中，返回缓存中的结果，否则下一步；</li>
<li>解析语句，生成执行计划；（SQL解析，预处理，优化器生成执行计划）；</li>
<li>根据执行计划，根据存储引擎的不同调用API，执行查询（一棵指令树）；</li>
<li>结果返回客户端。</li>
</ul>
</li>
</ol>
<h2 id="为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？"><a href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？" class="headerlink" title="为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？"></a>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</h2><p><em><strong>B+Tree vs B Tree</strong></em></p>
<p><strong>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</strong></p>
<p><strong>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</strong></p>
<p><em><strong>2、B+Tree vs 二叉树</strong></em></p>
<p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p>
<p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作**只需要做 3</del>4 次的磁盘 I&#x2F;O 操作就能查询到目标数据**。</p>
<p>而<strong>二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多</strong>。</p>
<p><em><strong>3、B+Tree vs Hash</strong></em></p>
<p><strong>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</strong></p>
<p><strong>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因</strong></p>
<h3 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h3><p>用上了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的。</p>
<p>我之前写过索引失效的文章，想详细了解的可以去看这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">谁还没碰过索引失效呢?(opens new window)</a></p>
<p>这里简单说一下，发生索引失效的情况：</p>
<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对<strong>索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效</strong>；</li>
<li>联合索引要能正确使用需要<strong>遵循最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li><strong>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效</strong>。</li>
</ul>
<p>这次主要介绍了索引的原理、分类和使用。我把重点总结在了下面这个表格</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png" alt="img"></p>
<h2 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h2><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，所以就跟大家图解下InnoDB 是如何存储数据的。</p>
<p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，<strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p>数据库的 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p>
<p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p>
<p><strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</p>
<p>数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</p>
<p>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</p>
<p>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</p>
<p>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。</p>
<ul>
<li>MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。</li>
<li>页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。</li>
<li>在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</li>
<li>索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能</li>
</ul>
<h2 id="索引失效有哪些"><a href="#索引失效有哪些" class="headerlink" title="索引失效有哪些"></a>索引失效有哪些</h2><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p>
<p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p>
<p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。在查询条件中对索引进行表达式计算，也是无法走索引的。</p>
<p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p>
<p>这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="built_in">CAST</span>(phone <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p>
<p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配</p>
<p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>今天给大家介绍了 6 种会发生索引失效的情况：</p>
<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li>
<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li>
<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
<h2 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><h2 id><a href="#" class="headerlink" title></a></h2><p><strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com//mysql/other/af711033aa3423330d3a4bc6baeb9532.png" alt="图片"></p>
<p>**count(<code>*</code>) 其实等于 count(<code>0</code>)**，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理</p>
<p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p>
<p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p>
<p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p>
<ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略为NULL的值。</li>
<li>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略为NULL的值。</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是指空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
</ul>
<h2 id="如何优化-count-？"><a href="#如何优化-count-？" class="headerlink" title="如何优化 count(*)？"></a>如何优化 count(*)？</h2><h3 id="近似值"><a href="#近似值" class="headerlink" title="近似值"></a>近似值</h3><p>我们就可以使用 show table status 或者 explain 命令来表进行估算。</p>
<h3 id="额外表保存计数值"><a href="#额外表保存计数值" class="headerlink" title="额外表保存计数值"></a>额外表保存计数值</h3><p>如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p>
<p>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表</p>
<h2 id="执行一条-select-语句，期间发生了什么？"><a href="#执行一条-select-语句，期间发生了什么？" class="headerlink" title="执行一条 select 语句，期间发生了什么？"></a>执行一条 select 语句，期间发生了什么？</h2><p>先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p>
<p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p>
<ul>
<li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li>
</ul>
<p>好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p>
<p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p>
<p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。</p>
<p>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p>
<p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。</p>
<h3 id="解析-SQL"><a href="#解析-SQL" class="headerlink" title="解析 SQL"></a>解析 SQL</h3><p>在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成</p>
<h3 id="执行-SQL"><a href="#执行-SQL" class="headerlink" title="执行 SQL"></a>执行 SQL</h3><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p>
<ul>
<li>prepare 阶段，也就是预处理阶段；</li>
<li>optimize 阶段，也就是优化阶段；</li>
<li>execute 阶段，也就是执行阶段；</li>
</ul>
<h2 id="MySQL-一行记录是怎么存储的"><a href="#MySQL-一行记录是怎么存储的" class="headerlink" title="MySQL 一行记录是怎么存储的"></a>MySQL 一行记录是怎么存储的</h2><ul>
<li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li>
<li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li>
<li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li>
</ul>
<p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p>
<p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p>
<h4 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p>
<ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合，之前讲<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离 (opens new window)</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li>
</ul>
<p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong></p>
<p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p>
<ul>
<li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li>
<li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li>
</ul>
<p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p>
<p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p>
<blockquote>
<p>MySQL 的 NULL 值是怎么存放的？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p>
<p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p>
<blockquote>
<p>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「<strong>变长字段长度列表</strong>」存储变长字段实际占用的数据大小。</p>
<ul>
<li>如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；</li>
<li>条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；</li>
<li>我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」</li>
</ul>
<blockquote>
<p>varchar(n) 中 n 最大取值为多少？</p>
</blockquote>
<p>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p>
<p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p>
<p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 &#x3D; 65535 - 2 - 1 &#x3D; 65532。</p>
<p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535。</p>
<ul>
<li>在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532&#x2F;3 &#x3D; 21844。</li>
</ul>
<blockquote>
<p>行溢出后，MySQL 是怎么处理的？</p>
</blockquote>
<p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p>
<p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p>
<p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，<strong>只存储 20 个字节的指针来指向溢出页</strong>。而实际的数据都存储在溢出页中。</p>
<h2 id="MySQL-有哪些锁"><a href="#MySQL-有哪些锁" class="headerlink" title="MySQL 有哪些锁"></a>MySQL 有哪些锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>在 MySQL 里，根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。</p>
<blockquote>
<p>全局锁是怎么用的？</p>
</blockquote>
<p>要使用全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure>

<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如 insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>当然，当会话断开了，全局锁会被自动释放。</p>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><blockquote>
<p>MySQL 表级锁有哪些？具体怎么用的。</p>
</blockquote>
<p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li>表锁；</li>
<li>元数据锁（MDL）;</li>
<li>意向锁；</li>
<li>AUTO-INC 锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line">//表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br><span class="line"></span><br><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit &#x3D; 0。</p>
<h2 id="update-没加索引会锁全表？"><a href="#update-没加索引会锁全表？" class="headerlink" title="update 没加索引会锁全表？"></a>update 没加索引会锁全表？</h2><p><strong>当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的</strong>。另外，这<strong>个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放</strong>。</p>
<p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，<strong>锁是加在索引上的而非行上</strong>。</p>
<p>比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。</p>
<p>这里举个例子，这里有一张数据库表，其中 id 为主键索引。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com//mysql/other/3c3af16e7a948833ccb6409e8b51daf8.png" alt="img"></p>
<p>假设有两个事务的执行顺序如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com//mysql/other/d2326f98cbb34fc09ca4013703251501.png" alt="在这里插入图片描述"></p>
<p>可以看到，事务 A 的 update 语句中 where 是等值查询，并且 id 是唯一索引，所以只会对 id &#x3D; 1 这条记录加锁，因此，事务 B 的更新操作并不会阻塞。</p>
<p>但是，<strong>在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</strong></p>
<p>假设有两个事务的执行顺序如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com//mysql/other/1aa886fe95e7bc791c296e2d342fa435.png" alt="img"></p>
<p>可以看到，这次事务 B 的 update 语句被阻塞了。</p>
<p>这是<strong>因为事务 A的 update 语句中 where 条件没有索引列，触发了全表扫描，在扫描过程中会对索引加锁，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com//mysql/other/63e055617720853f5b64c99576227c09.png" alt="img"></p>
<p>因此，当在数据量非常大的数据库表执行 update 语句时，如果没有使用索引，就会给全表的加上 next-key 锁， 那么锁就会持续很长一段时间，直到事务结束，而这期间除了 <code>select ... from</code>语句，其他语句都会被锁住不能执行，业务会因此停滞，接下来等着你的，就是老板的挨骂。</p>
<p>那 update 语句的 where 带上索引就能避免全表记录加锁了吗？</p>
<p>并不是。</p>
<p><strong>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了</strong>。</p>
<p>TIP</p>
<p>网上很多资料说，update 没加锁索引会加表锁，这是不对的。</p>
<p>Innodb 源码里面在扫描记录的时候，都是针对索引项这个单位去加锁的， update 不带索引就是全表扫扫描，也就是表里的索引项都加锁，相当于锁了整张表，所以大家误以为加了表锁。</p>
<h2 id="如何避免这种事故的发生？"><a href="#如何避免这种事故的发生？" class="headerlink" title="如何避免这种事故的发生？"></a>如何避免这种事故的发生？</h2><p>我们可以将 MySQL 里的 <code>sql_safe_updates</code> 参数设置为 1，开启安全更新模式。</p>
<p>大致的意思是，当 sql_safe_updates 设置为 1 时。</p>
<p>update 语句必须满足如下条件之一才能执行成功：</p>
<ul>
<li>使用 where，并且 where 条件中必须有索引列；</li>
<li>使用 limit；</li>
<li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li>
</ul>
<p>delete 语句必须满足以下条件能执行成功：</p>
<ul>
<li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li>
</ul>
<p>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</p>
<p><strong>当我们要执行 update 语句的时候，确保 where 条件中带上了索引列，并且在测试机确认该语句是否走的是索引扫描，防止因为扫描全表，而对表中的所有记录加上锁。</strong></p>
<p><strong>我们可以打开 MySQL sql_safe_updates 参数，这样可以预防 update 操作时 where 条件没有带上索引列</strong>。</p>
<p>如果发现即使在 where 条件中带上了列索引列，优化器走的还是全标扫描，这时我们就要使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引。</p>
<h2 id="为什么要有-Buffer-Pool？"><a href="#为什么要有-Buffer-Pool？" class="headerlink" title="为什么要有 Buffer Pool？"></a>为什么要有 Buffer Pool？</h2><p>虽然说 MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。</p>
<p>要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p>
<p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能</p>
<p>有了缓冲池后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li>
</ul>
<h3 id="Buffer-Pool-有多大？"><a href="#Buffer-Pool-有多大？" class="headerlink" title="Buffer Pool 有多大？"></a>Buffer Pool 有多大？</h3><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> 。</p>
<p>可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。</p>
<h2 id="MySQL-日志：undo-log、redo-log、binlog-有什么用？"><a href="#MySQL-日志：undo-log、redo-log、binlog-有什么用？" class="headerlink" title="MySQL 日志：undo log、redo log、binlog 有什么用？"></a>MySQL 日志：undo log、redo log、binlog 有什么用？</h2><ul>
<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li>
<li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="回滚事务"></p>
<p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p>
<ul>
<li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li>
<li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li>
<li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li>
</ul>
<p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p>
<ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li>
</ul>
<p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://anxiangyipiao.github.io/anxiangblog.github.io">暗香依飘</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://anxiangyipiao.github.io/anxiangblog.github.io/2024/07/09/mysql/">https://anxiangyipiao.github.io/anxiangblog.github.io/2024/07/09/mysql/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://anxiangyipiao.github.io/anxiangblog.github.io" target="_blank">AnXiang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/anxiangblog.github.io/tags/mysql/">mysql</a></div><div class="post_share"><div class="social-share" data-image="/anxiangblog.github.io/./img/home.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/anxiangblog.github.io/2024/07/09/cpu%E7%9C%BC%E4%B8%AD%E7%9A%84c++/" title="c++"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="onerror=null;src='/anxiangblog.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">c++</div></div></a></div><div class="next-post pull-right"><a href="/anxiangblog.github.io/2024/07/09/Go%20vs%20C++%20vs%20python%20%20%20%E2%95%97%E2%88%99%E2%94%A4%D0%B1%E2%95%93%D0%BA%E2%95%A9%E2%95%A2%E2%95%A2%E2%95%98%E2%96%92%E2%95%9A/" title="Go vs C++ vs python"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="onerror=null;src='/anxiangblog.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go vs C++ vs python</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/img/favicon.png" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">暗香依飘</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/anxiangblog.github.io/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/anxiangblog.github.io/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/anxiangblog.github.io/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="https://anxiangyipiao.github.io"><i class="fab fa-github"></i><span>Like You</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is our Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#sql"><span class="toc-number">1.</span> <span class="toc-text">sql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">sql语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.2.</span> <span class="toc-text">字段约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">基础函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.</span> <span class="toc-text">条件查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">聚合函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E8%81%94%E6%9F%A5"><span class="toc-number">1.7.</span> <span class="toc-text">多表联查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5"><span class="toc-number">1.8.</span> <span class="toc-text">数据库分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSQL%E4%B8%AD%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">介绍一下SQL中的聚合函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%B7%9F%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%85%B3%E8%81%94%E7%9A%84%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">表跟表是怎么关联的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E4%B8%AD%E6%80%8E%E4%B9%88%E5%B0%86%E8%A1%8C%E8%BD%AC%E6%88%90%E5%88%97%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">SQL中怎么将行转成列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.12.</span> <span class="toc-text">谈谈你对SQL注入的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%88%B0%E5%8F%A6%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E5%91%A2%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">将一张表的部分数据更新到另一张表，该如何操作呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WHERE%E5%92%8CHAVING%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">WHERE和HAVING有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.15.</span> <span class="toc-text">说一说你对MySQL索引的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">索引有哪几种？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB"><span class="toc-number">1.16.1.</span> <span class="toc-text">按物理存储分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%AD%97%E6%AE%B5%E7%89%B9%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">1.16.2.</span> <span class="toc-text">按字段特性分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">1.16.2.1.</span> <span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.16.2.2.</span> <span class="toc-text">唯一索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">1.16.2.3.</span> <span class="toc-text">普通索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.16.2.4.</span> <span class="toc-text">前缀索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB"><span class="toc-number">1.16.3.</span> <span class="toc-text">按字段个数分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">如何判断数据库的索引有没有生效？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E7%9A%84%E6%98%AF%E5%90%A6%E5%90%88%E7%90%86%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">如何评估一个索引创建的是否合理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-MySQL-InnoDB-%E9%80%89%E6%8B%A9-B-tree-%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">1.19.1.</span> <span class="toc-text">防止索引失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">InnoDB 是如何存储数据的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.21.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.22.</span> <span class="toc-text">索引失效有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.23.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E6%9C%80%E5%A5%BD%EF%BC%9F"><span class="toc-number">1.24.</span> <span class="toc-text">count(*) 和 count(1) 有什么区别？哪个性能最好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.25.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-count-%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">如何优化 count(*)？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%91%E4%BC%BC%E5%80%BC"><span class="toc-number">1.26.1.</span> <span class="toc-text">近似值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E8%A1%A8%E4%BF%9D%E5%AD%98%E8%AE%A1%E6%95%B0%E5%80%BC"><span class="toc-number">1.26.2.</span> <span class="toc-text">额外表保存计数值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1-select-%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.27.</span> <span class="toc-text">执行一条 select 语句，期间发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-number">1.27.1.</span> <span class="toc-text">连接器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.27.2.</span> <span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-SQL"><span class="toc-number">1.27.3.</span> <span class="toc-text">解析 SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-SQL"><span class="toc-number">1.27.4.</span> <span class="toc-text">执行 SQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">1.28.</span> <span class="toc-text">MySQL 一行记录是怎么存储的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%EF%BC%88segment%EF%BC%89"><span class="toc-number">1.28.0.1.</span> <span class="toc-text">段（segment）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81"><span class="toc-number">1.29.</span> <span class="toc-text">MySQL 有哪些锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">1.29.1.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">1.29.2.</span> <span class="toc-text">表级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">1.29.3.</span> <span class="toc-text">行级锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#update-%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">update 没加索引会锁全表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%99%E7%A7%8D%E4%BA%8B%E6%95%85%E7%9A%84%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">如何避免这种事故的发生？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-Buffer-Pool%EF%BC%9F"><span class="toc-number">1.32.</span> <span class="toc-text">为什么要有 Buffer Pool？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-Pool-%E6%9C%89%E5%A4%9A%E5%A4%A7%EF%BC%9F"><span class="toc-number">1.32.1.</span> <span class="toc-text">Buffer Pool 有多大？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E6%97%A5%E5%BF%97%EF%BC%9Aundo-log%E3%80%81redo-log%E3%80%81binlog-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.33.</span> <span class="toc-text">MySQL 日志：undo log、redo log、binlog 有什么用？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/cpu%E7%9C%BC%E4%B8%AD%E7%9A%84c++/" title="c++"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="c++"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/cpu%E7%9C%BC%E4%B8%AD%E7%9A%84c++/" title="c++">c++</a><time datetime="2024-07-09T03:08:40.492Z" title="发表于 2024-07-09 11:08:40">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/mysql/" title="Mysql"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="Mysql"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/mysql/" title="Mysql">Mysql</a><time datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/Go%20vs%20C++%20vs%20python%20%20%20%E2%95%97%E2%88%99%E2%94%A4%D0%B1%E2%95%93%D0%BA%E2%95%A9%E2%95%A2%E2%95%A2%E2%95%98%E2%96%92%E2%95%9A/" title="Go vs C++ vs python"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="Go vs C++ vs python"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/Go%20vs%20C++%20vs%20python%20%20%20%E2%95%97%E2%88%99%E2%94%A4%D0%B1%E2%95%93%D0%BA%E2%95%A9%E2%95%A2%E2%95%A2%E2%95%98%E2%96%92%E2%95%9A/" title="Go vs C++ vs python">Go vs C++ vs python</a><time datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/go%20%E2%95%99%D1%8F%E2%95%A4%E2%95%98%E2%95%A3%D1%86%E2%95%96%E2%95%A2/" title="go 语言规范"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="go 语言规范"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/go%20%E2%95%99%D1%8F%E2%95%A4%E2%95%98%E2%95%A3%D1%86%E2%95%96%E2%95%A2/" title="go 语言规范">go 语言规范</a><time datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/%E2%94%90%D0%B8%E2%95%96%E2%95%9C/" title="卡方测验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/img/home2.jpg%20/img/home3.jpg%20/img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="卡方测验"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/%E2%94%90%D0%B8%E2%95%96%E2%95%9C/" title="卡方测验">卡方测验</a><time datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/anxiangblog.github.io/./img/home.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 暗香依飘</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/anxiangblog.github.io/js/utils.js"></script><script src="/anxiangblog.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'diBhtLp5zcy429eQQ21ikoNl-gzGzoHsz',
      appKey: '6clFk0OD64y2clBFdpNvlYzS',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="netease" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/anxiangblog.github.io/js/search/local-search.js"></script></div></div></body></html>