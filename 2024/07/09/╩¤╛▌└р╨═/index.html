<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go vs C++ vs python 基本数据类型 | AnXiang</title><meta name="author" content="暗香依飘"><meta name="copyright" content="暗香依飘"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="二、基本数据类型goGo语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。 整形分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64其中，uint8就是我们熟知的byte型，int16">
<meta property="og:type" content="article">
<meta property="og:title" content="Go vs C++ vs python 基本数据类型">
<meta property="og:url" content="https://anxiangyipiao.github.io/anxiangblog.github.io/2024/07/09/%E2%95%A9%C2%A4%E2%95%9B%E2%96%8C%E2%94%94%D1%80%E2%95%A8%E2%95%90/index.html">
<meta property="og:site_name" content="AnXiang">
<meta property="og:description" content="二、基本数据类型goGo语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。 整形分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64其中，uint8就是我们熟知的byte型，int16">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://anxiangyipiao.github.io/anxiangblog.github.io/img/home.jpg">
<meta property="article:published_time" content="2024-07-09T02:42:59.732Z">
<meta property="article:modified_time" content="2023-04-27T09:46:58.000Z">
<meta property="article:author" content="暗香依飘">
<meta property="article:tag" content="Go python C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://anxiangyipiao.github.io/anxiangblog.github.io/img/home.jpg"><link rel="shortcut icon" href="/anxiangblog.github.io/img/favicon.png"><link rel="canonical" href="https://anxiangyipiao.github.io/anxiangblog.github.io/2024/07/09/%E2%95%A9%C2%A4%E2%95%9B%E2%96%8C%E2%94%94%D1%80%E2%95%A8%E2%95%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/anxiangblog.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/anxiangblog.github.io/',
  algolia: undefined,
  localSearch: {"path":"/anxiangblog.github.io/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go vs C++ vs python 基本数据类型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-27 17:46:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/anxiangblog.github.io/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/anxiangblog.github.io/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/anxiangblog.github.io/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 娱乐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/anxiangblog.github.io/./img/home.jpg')"><nav id="nav"><span id="blog-info"><a href="/anxiangblog.github.io/" title="AnXiang"><span class="site-name">AnXiang</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/anxiangblog.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 娱乐</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go vs C++ vs python 基本数据类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-27T09:46:58.000Z" title="更新于 2023-04-27 17:46:58">2023-04-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/anxiangblog.github.io/categories/%E4%B8%93%E4%B8%9A/">专业</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go vs C++ vs python 基本数据类型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h2><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p>
<h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</span><br><span class="line">其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型</span><br><span class="line"></span><br><span class="line">uint	32位操作系统上就是uint32，64位操作系统上就是uint64</span><br><span class="line">int	32位操作系统上就是int32，64位操作系统上就是int64</span><br><span class="line">uintptr	无符号整型，用于存放一个指针</span><br><span class="line"></span><br><span class="line">而且还允许我们用 _ 来分隔数字，比如说： v := 123_456 表示 v 的值等于 123456。</span><br></pre></td></tr></table></figure>

<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float32和float64</span><br></pre></td></tr></table></figure>

<h3 id="布尔值-bool"><a href="#布尔值-bool" class="headerlink" title="布尔值 bool"></a>布尔值 bool</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">布尔类型变量的默认值为false。</span><br><span class="line">Go 语言中不允许将整型强制转换为布尔型.</span><br><span class="line">布尔型无法参与数值运算，也无法与其他类型进行转换。</span><br></pre></td></tr></table></figure>

<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">complex64和complex128</span><br><span class="line"></span><br><span class="line">var c1 complex64</span><br><span class="line">c1 = 1 + 2i</span><br><span class="line">var c2 complex128</span><br><span class="line">c2 = 2 + 3i</span><br><span class="line">complex64的实部和虚部为32位，complex128的实部和虚部为64位。</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 := &quot;hello&quot;</span><br><span class="line">s2 := &quot;你好&quot;</span><br><span class="line">Go语言中要定义一个多行字符串时，就必须使用反引号字符：</span><br><span class="line">s1 := `第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">`</span><br><span class="line">反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出</span><br><span class="line"></span><br><span class="line">len(str)	求长度</span><br><span class="line">+或fmt.Sprintf	拼接字符串</span><br><span class="line">strings.Split	分割</span><br><span class="line">strings.contains	判断是否包含</span><br><span class="line">strings.HasPrefix,strings.HasSuffix	前缀/后缀判断</span><br><span class="line">strings.Index(),strings.LastIndex()	子串出现的位置</span><br><span class="line">strings.Join(a[]string, sep string)	join操作</span><br></pre></td></tr></table></figure>

<h3 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</span><br><span class="line">var a = &#x27;中&#x27;</span><br><span class="line">var b = &#x27;x&#x27;</span><br><span class="line">rune类型实际是一个int32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改字符串</span><br><span class="line">要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。</span><br><span class="line"></span><br><span class="line">func changeString() &#123;</span><br><span class="line">	s1 := &quot;big&quot;</span><br><span class="line">	// 强制类型转换</span><br><span class="line">	byteS1 := []byte(s1)</span><br><span class="line">	byteS1[0] = &#x27;p&#x27;</span><br><span class="line">	fmt.Println(string(byteS1))</span><br><span class="line"></span><br><span class="line">	s2 := &quot;白萝卜&quot;</span><br><span class="line">	runeS2 := []rune(s2)</span><br><span class="line">	runeS2[0] = &#x27;红&#x27;</span><br><span class="line">	fmt.Println(string(runeS2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指针类型（Pointer）"><a href="#指针类型（Pointer）" class="headerlink" title="指针类型（Pointer）"></a>指针类型（Pointer）</h3><p>在 Go 中，指针类型用于存储变量的内存地址。与 C 和 C++ 不同，Go 指针不能进行偏移和运算，因此它们更安全且更易于使用。指针类型以 <code>*</code> 开头，用于指定指针类型的底层类型。例如，<code>*int</code> 表示指向整数类型的指针。在 Go 中，通过 <code>&amp;</code> 运算符可以获取一个变量的内存地址，而通过 <code>*</code> 运算符可以获取指针所指向的变量的值，<strong>指针类型的零值为 <code>nil</code><strong>，表示指</strong>针不指向任何有效的内存地址</strong>。因此，在使用指针之前，应该先进行空指针检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x int = 42</span><br><span class="line">var ptr *int = &amp;x   // 获取 x 的地址，将其赋值给 ptr</span><br><span class="line">fmt.Println(*ptr)  // 输出指针所指向的变量的值，即 42</span><br></pre></td></tr></table></figure>

<h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h3><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个长度为3元素类型为int的数组a   数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变</span><br><span class="line">var 数组变量名 [元素数量]T</span><br><span class="line">var a [3]int</span><br></pre></td></tr></table></figure>

<h4 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var testArray [3]int                        //数组会初始化为int类型的零值</span><br><span class="line">var numArray = [3]int&#123;1, 2&#125;                 //使用指定的初始值完成初始化</span><br><span class="line">var cityArray = [3]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125; //使用指定的初始值完成初始化</span><br><span class="line"></span><br><span class="line">一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度</span><br><span class="line">var testArray [3]int</span><br><span class="line">var numArray = [...]int&#123;1, 2&#125;</span><br><span class="line">var cityArray = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line"></span><br><span class="line">指定索引值的方式来初始化数组</span><br><span class="line">a := [...]int&#123;1: 1, 3: 5&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 方法1：for循环遍历</span><br><span class="line">for i := 0; i &lt; len(a); i++ &#123;</span><br><span class="line">		fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	// 方法2：for range遍历</span><br><span class="line">for index, value := range a &#123;</span><br><span class="line">		fmt.Println(index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二维数组</span><br><span class="line">a := [3][2]string&#123;</span><br><span class="line">		&#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">		&#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">		&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">for _, v1 := range a &#123;</span><br><span class="line">	for _, v2 := range v1 &#123;</span><br><span class="line">			fmt.Printf(&quot;%s\t&quot;, v2)</span><br><span class="line">	&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h4 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h4><p>数组是值类型，<strong>赋值和传参会复制整个数组</strong>。因此改变副本的值，不会改变本身的值。</p>
<ol>
<li>数组支持 “&#x3D;&#x3D;“、”!&#x3D;” 操作符，因为内存总是被初始化过的。</li>
<li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li>
</ol>
<h3 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h3><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>
<h4 id="切片声明"><a href="#切片声明" class="headerlink" title="切片声明"></a>切片声明</h4><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p>
<ol>
<li>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</li>
<li>切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）</li>
<li>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</li>
<li>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name []T</span><br><span class="line"></span><br><span class="line">简单切片表达式</span><br><span class="line">a := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">s := a[1:3]  // s := a[low:high]</span><br><span class="line">a[2:]  // 等同于 a[2:len(a)]</span><br><span class="line">a[:3]  // 等同于 a[0:3]</span><br><span class="line">a[:]   // 等同于 a[0:len(a)]</span><br><span class="line"></span><br><span class="line">完整切片表达式</span><br><span class="line">a[low : high : max]</span><br><span class="line">它会将得到的结果切片的容量cap设置为max-low</span><br></pre></td></tr></table></figure>

<h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make([]T, size, cap)</span><br></pre></td></tr></table></figure>

<ul>
<li>T:切片的元素类型</li>
<li>size:切片中元素的数量</li>
<li>cap:切片的容量</li>
</ul>
<h4 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">四维数组</span><br><span class="line">var Sites  [][][][]int</span><br><span class="line">for i := 0; i &lt; DataInfo.X; i++ &#123;</span><br><span class="line">		var first [][][]int</span><br><span class="line">		for j := 0; j &lt; DataInfo.Y; j++ &#123;</span><br><span class="line">			var secend [][]int</span><br><span class="line">			for k := 0; k &lt; DataInfo.Z; k++ &#123;</span><br><span class="line"></span><br><span class="line">				third := make([]int, 2)</span><br><span class="line">				secend = append(secend, third)</span><br><span class="line">			&#125;</span><br><span class="line">			first = append(first, secend)</span><br><span class="line">		&#125;</span><br><span class="line">		Sites = append(Sites, first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">切片遍历</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">append</span>()方法为切片添加元素</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">Go语言内建的<span class="built_in">copy</span>()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<span class="built_in">copy</span>()函数的使用格式如下：</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(destSlice, srcSlice []T) </span><br><span class="line"></span><br><span class="line">srcSlice: 数据来源切片</span><br><span class="line">destSlice: 目标切片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure>

<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap），</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="map声明"><a href="#map声明" class="headerlink" title="map声明"></a>map声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure>

<ul>
<li>KeyType:表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>
<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>

<p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">	scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">	scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h4 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br><span class="line"></span><br><span class="line">v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="map操作"><a href="#map操作" class="headerlink" title="map操作"></a>map操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遍历</span><br><span class="line">for k, v := range scoreMap &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">遍历map时的元素顺序与添加键值对的顺序无关</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(map, key)</span><br><span class="line">delete(scoreMap, &quot;小明&quot;)//将小明:100从map中删除</span><br><span class="line"></span><br><span class="line">元素为map类型的切片</span><br><span class="line">var mapSlice = make([]map[string]string, 3)</span><br><span class="line">mapSlice[0][&quot;address&quot;] = &quot;沙河&quot;</span><br><span class="line"></span><br><span class="line">值为切片类型的map</span><br><span class="line">var sliceMap = make(map[string][]string, 3)</span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		value = make([]string, 0, 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体Struct"><a href="#结构体Struct" class="headerlink" title="结构体Struct"></a>结构体Struct</h3><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p>
<p>Go语言中通过<code>struct</code>来实现面向对象。</p>
<h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Go语言中并没有类的概念，而是使用结构体来实现类似的功能</span></span><br><span class="line"><span class="keyword">type</span> MyClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyClass)</span></span> setX(val <span class="type">int</span>) &#123;</span><br><span class="line">    m.x = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h4><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	city <span class="type">string</span></span><br><span class="line">	age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p1 person</span><br><span class="line">	p1.name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">	p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">	p1.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在定义一些临时数据结构等场景下还可以使用匿名结构体</span><br><span class="line"><span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="type">string</span>; Age <span class="type">int</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h4><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure>

<p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针,需要注意的是<strong>在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员</strong></p>
<h4 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h4><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;七米&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;七米&quot;, city:&quot;成都&quot;, age:30&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p>
<h4 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h4><p><strong>没有初始化的结构体，其成员变量都是对应其类型的零值。</strong><em><strong>结构体占用一块连续的内存.</strong></em>* <strong>空结构体是不占用空间的。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用键值对初始化,,当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</span></span><br><span class="line">p5 := person&#123;</span><br><span class="line">	name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">	city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用值的列表初始化</span></span><br><span class="line">p8 := &amp;person&#123;</span><br><span class="line">	<span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">	<span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	<span class="number">28</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *person &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		city: city,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p9 := newPerson(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;沙河&quot;</span>, <span class="number">90</span>)</span><br></pre></td></tr></table></figure>

<h4 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h4><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p>
<p>方法的定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="comment">//值类型的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	p1.Dream()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针类型的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h5><ol>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ol>
<h4 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province <span class="type">string</span></span><br><span class="line">	City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span></span><br><span class="line">	Gender  <span class="type">string</span></span><br><span class="line">	Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user1 := User&#123;</span><br><span class="line">		Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		Address: Address&#123;</span><br><span class="line">			Province: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">			City:     <span class="string">&quot;威海&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套匿名字段</span></span><br><span class="line">Address <span class="comment">//匿名字段</span></span><br><span class="line">user2.Address.Province = <span class="string">&quot;山东&quot;</span>    <span class="comment">// 匿名字段默认使用类型名作为字段名</span></span><br></pre></td></tr></table></figure>

<h4 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h4><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Feet    <span class="type">int8</span></span><br><span class="line">	*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := &amp;Dog&#123;</span><br><span class="line">		Feet: <span class="number">4</span>,</span><br><span class="line">		Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">			name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">	d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h4><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）.</p>
<h4 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h4><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键&#x2F;值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//JSON序列化：结构体--&gt;JSON格式的字符串</span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line">	</span><br><span class="line">//JSON反序列化：JSON格式的字符串--&gt;结构体</span><br><span class="line">err = json.Unmarshal([]byte(str), c1)</span><br></pre></td></tr></table></figure>

<h4 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h4><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`key1:<span class="string">&quot;value1&quot;</span> key2:<span class="string">&quot;value2&quot;</span>`</span><br></pre></td></tr></table></figure>

<p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">	Gender <span class="type">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">	name   <span class="type">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := Student&#123;</span><br><span class="line">		ID:     <span class="number">1</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		name:   <span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := json.Marshal(s1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体和方法补充知识点"><a href="#结构体和方法补充知识点" class="headerlink" title="结构体和方法补充知识点"></a>结构体和方法补充知识点</h4><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意.</p>
<p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p>
<h3 id="函数Func"><a href="#函数Func" class="headerlink" title="函数Func"></a>函数Func</h3><p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p>
<p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><strong>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</strong></li>
<li><strong>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</strong></li>
<li><strong>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</strong></li>
<li><strong>函数体：实现指定功能的代码块。</strong></li>
<li><strong>函数的参数和返回值都是可选的</strong></li>
<li><strong>函数的参数中如果相邻变量的类型相同，则可以省略类型</strong></li>
</ul>
<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p><strong>可变参数是指函数的参数数量不固定</strong>。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p>
<p>注意：<strong>可变参数通常要作为函数的最后一个参数。</strong></p>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p>
<p>返回值命名  函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p>
<p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 没必要返回[]int&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h5><p>局部变量和全局变量重名，优先访问局部变量。</p>
<h5 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h5><p>定义函数类型</p>
<p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>
<p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br><span class="line"></span><br><span class="line">fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br></pre></td></tr></table></figure>

<h5 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h5><p>函数可以作为参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ret2 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">	fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h5><p>函数也可以作为返回值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> s &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		err := errors.New(<span class="string">&quot;无法识别的操作符&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h5><p><strong>匿名函数多用于实现回调函数和闭包</strong>。</p>
<p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将匿名函数保存到变量</span></span><br><span class="line">	add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(x + y)</span><br><span class="line">	&#125;</span><br><span class="line">	add(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//自执行函数：匿名函数定义完加()直接执行</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(x + y)</span><br><span class="line">	&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>闭包指的是一个函数和与其相关的引用环境组合而成的实体</strong>。简单来说，<code>闭包=函数+引用环境</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		x += y</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = adder()</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br></pre></td></tr></table></figure>

<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</p>
<p>闭包进阶示例2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffixFunc</span><span class="params">(suffix <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line">			<span class="keyword">return</span> name + suffix</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	jpgFunc := makeSuffixFunc(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">	txtFunc := makeSuffixFunc(<span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">	fmt.Println(jpgFunc(<span class="string">&quot;test&quot;</span>)) <span class="comment">//test.jpg</span></span><br><span class="line">	fmt.Println(txtFunc(<span class="string">&quot;test&quot;</span>)) <span class="comment">//test.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包进阶示例3：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">	add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		base += i</span><br><span class="line">		<span class="keyword">return</span> base</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		base -= i</span><br><span class="line">		<span class="keyword">return</span> base</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f1, f2 := calc(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>)) <span class="comment">//11 9</span></span><br><span class="line">	fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>)) <span class="comment">//12 8</span></span><br><span class="line">	fmt.Println(f1(<span class="number">5</span>), f2(<span class="number">6</span>)) <span class="comment">//13 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p>
<h5 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h5><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p>
<p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := a + b</span><br><span class="line">	fmt.Println(index, a, b, ret)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">1</span></span><br><span class="line">	y := <span class="number">2</span></span><br><span class="line">	<span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">	x = <span class="number">10</span></span><br><span class="line">	<span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">	y = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">B <span class="number">10</span> <span class="number">2</span> <span class="number">12</span></span><br><span class="line">BB <span class="number">10</span> <span class="number">12</span> <span class="number">22</span></span><br><span class="line">AA <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="内置函数介绍"><a href="#内置函数介绍" class="headerlink" title="内置函数介绍"></a>内置函数介绍</h5><table>
<thead>
<tr>
<th align="center">内置函数</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">close</td>
<td align="center">主要用来关闭channel</td>
</tr>
<tr>
<td align="center">len</td>
<td align="center">用来求长度，比如string、array、slice、map、channel</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td>
</tr>
<tr>
<td align="center">make</td>
<td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td>
</tr>
<tr>
<td align="center">append</td>
<td align="center">用来追加元素到数组、slice中</td>
</tr>
<tr>
<td align="center">panic和recover</td>
<td align="center">用来做错误处理</td>
</tr>
</tbody></table>
<h3 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h3><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节</p>
<p>在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于之前章节中讲到的那些具体类型（字符串、切片、结构体等）更注重“我是谁”，接口类型更注重“我能做什么”的问题。接口类型就像是一种约定——概括了一种类型应该具备哪些方法，在Go语言中提倡使用面向接口的编程方式实现解耦。</p>
<h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口类型名：Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有关闭操作的接口叫<code>closer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>
<h4 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h4><p>接口就是规定了一个<strong>需要实现的方法列表</strong>，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口。</p>
<p>我们定义的<code>Singer</code>接口类型，它包含一个<code>Sing</code>方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singer 接口</span></span><br><span class="line"><span class="keyword">type</span> Singer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Sing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有一个<code>Bird</code>结构体类型如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>Singer</code>接口只包含一个<code>Sing</code>方法，所以只需要给<code>Bird</code>结构体添加一个<code>Sing</code>方法就可以满足<code>Singer</code>接口的要求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sing Bird类型的Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Sing() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就称为<code>Bird</code>实现了<code>Singer</code>接口。</p>
<p>只要实现了<code>Say()</code>方法都能当成<code>Sayer</code>类型的变量来处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Sayer interface &#123;</span><br><span class="line">    Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MakeHungry 饿肚子了...</span><br><span class="line">func MakeHungry(s Sayer) &#123;</span><br><span class="line">	s.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c cat</span><br><span class="line">MakeHungry(c)</span><br><span class="line">var d dog</span><br><span class="line">MakeHungry(d)</span><br></pre></td></tr></table></figure>

<p>Go语言中为了解决类似上面的问题引入了接口的概念，接口类型区别于我们之前章节中介绍的那些具体类型，让我们专注于该类型提供的方法，而不是类型本身。使用接口类型通常能够让我们写出更加通用和灵活的代码</p>
<h4 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h4><p>只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。</p>
<p>我们可以将具体的支付方式抽象为一个名为<code>Payer</code>的接口类型，即任何实现了<code>Pay</code>方法的都可以称为<code>Payer</code>类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Payer 包含支付方法的接口类型</span></span><br><span class="line"><span class="keyword">type</span> Payer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Pay(<span class="type">int64</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ZhiFuBao <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 支付宝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay 支付宝的支付方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *ZhiFuBao)</span></span> Pay(amount <span class="type">int64</span>) &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;使用支付宝付款：%.2f元。\n&quot;</span>, <span class="type">float64</span>(amount/<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WeChat <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 微信</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay 微信的支付方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WeChat)</span></span> Pay(amount <span class="type">int64</span>) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;使用微信付款：%.2f元。\n&quot;</span>, <span class="type">float64</span>(amount/<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Checkout</span><span class="params">(obj *Payer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 支付100元</span></span><br><span class="line">	obj.Pay(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Checkout(&amp;ZhiFuBao&#123;&#125;) <span class="comment">// 之前调用支付宝支付</span></span><br><span class="line"></span><br><span class="line">	Checkout(&amp;WeChat&#123;&#125;) <span class="comment">// 现在支持使用微信支付</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x Sayer // 声明一个Sayer类型的变量x</span><br><span class="line">a := Cat&#123;&#125;  // 声明一个Cat类型变量a</span><br><span class="line">b := Dog&#123;&#125;  // 声明一个Dog类型变量b</span><br><span class="line">x = a       // 可以把Cat类型变量直接赋值给x</span><br><span class="line">x.Say()     // 喵喵喵</span><br><span class="line">x = b       // 可以把Dog类型变量直接赋值给x</span><br><span class="line">x.Say()     // 汪汪汪</span><br></pre></td></tr></table></figure>

<h4 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Mover 定义一个接口类型</span><br><span class="line">type Mover interface &#123;</span><br><span class="line">	Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Dog 狗结构体类型</span><br><span class="line">type Dog struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">//值接收者实现接口</span><br><span class="line">// Move 使用值接收者定义Move方法实现Mover接口</span><br><span class="line">func (d Dog) Move() &#123;</span><br><span class="line">	fmt.Println(&quot;狗会动&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指针接收者实现接口</span><br><span class="line"></span><br><span class="line">// Cat 猫结构体类型</span><br><span class="line">type Cat struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Move 使用指针接收者定义Move方法实现Mover接口</span><br><span class="line">func (c *Cat) Move() &#123;</span><br><span class="line">	fmt.Println(&quot;猫会动&quot;)</span><br><span class="line">&#125;</span><br><span class="line">ar c1 = &amp;Cat&#123;&#125; // c1是*Cat类型</span><br><span class="line">x = c1          // 可以将c1当成Mover类型</span><br><span class="line">x.Move()</span><br><span class="line"></span><br><span class="line">由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是我们并不总是能对一个值求址，所以对于指针接收者实现的接口要额外注意</span><br></pre></td></tr></table></figure>

<h4 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h4><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。我们完全可以分别定义<code>Sayer</code>接口和<code>Mover</code>接口，具体代码示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog既可以实现Sayer接口，也可以实现Mover接口。</span></span><br><span class="line"><span class="comment">//同一个类型实现不同的接口互相不影响使用。</span></span><br><span class="line"><span class="keyword">var</span> d = Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Sayer = d</span><br><span class="line"><span class="keyword">var</span> m Mover = d</span><br><span class="line"></span><br><span class="line">s.Say()  <span class="comment">// 对Sayer类型调用Say方法</span></span><br><span class="line">m.Move() <span class="comment">// 对Mover类型调用Move方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>一个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WashingMachine 洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">	wash()</span><br><span class="line">	dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干器</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> dry() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">	dryer <span class="comment">//嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span></span> wash() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h4><p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库<code>io</code>源码中就有很多接口之间互相组合的示例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/io/io.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Writer</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p>
<p>接口也可以作为结构体的一个字段，我们来看一段Go标准库<code>sort</code>源码中的示例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sort/sort.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface 定义通过索引对元素排序的接口类型</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse 结构体中嵌入了Interface接口</span></span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中还有一个需要注意的地方是<code>reverse</code>结构体本身是不可导出的（结构体类型名称首字母小写），<code>sort.go</code>中通过定义一个可导出的<code>Reverse</code>函数来让使用者创建<code>reverse</code>结构体实例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span></span> Interface &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的目的是保证得到的<code>reverse</code>结构体中的<code>Interface</code>属性一定不为<code>nil</code>，否者<code>r.Interface.Less(j, i)</code>就会出现空指针panic。</p>
<h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 不包含任何方法的空接口类型</span></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 狗结构体</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Any</span><br><span class="line"></span><br><span class="line">	x = <span class="string">&quot;你好&quot;</span> <span class="comment">// 字符串型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">	x = <span class="number">100</span> <span class="comment">// int型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">	x = <span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">	x = Dog&#123;&#125; <span class="comment">// 结构体类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常我们在使用空接口类型时不必使用<code>type</code>关键字声明，可以像下面的代码一样直接使用<code>interface&#123;&#125;</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 声明一个空接口类型变量x</span></span><br></pre></td></tr></table></figure>

<ol>
<li>空接口作为函数的参数   <code>func show(a interface&#123;&#125;)</code></li>
<li>空接口作为map的值 <code>var studentInfo = make(map[string]interface&#123;&#125;)</code></li>
</ol>
<h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<strong>值</strong>之外，还需要记录这个值属于的<strong>类型</strong>。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的<code>动态类型</code>和<code>动态值</code></p>
<table>
<thead>
<tr>
<th>类型type</th>
<th>nil</th>
</tr>
</thead>
<tbody><tr>
<td>值 value</td>
<td>nil</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;        <span class="keyword">type</span>  = *dog       value = 旺财</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *Car</span><br><span class="line">m = c                         <span class="keyword">type</span>  = *car      value = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</span></span><br></pre></td></tr></table></figure>

<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>我们可以借助标准库<code>fmt</code>包的格式化打印获取到接口值的动态类型 ,而<code>fmt</code>包内部其实是使用反射的机制在程序运行时获取到动态类型的名称</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m Mover</span><br><span class="line"></span><br><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, m) <span class="comment">// *main.Dog</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">new</span>(Car)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, m) <span class="comment">// *main.Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。</span></span><br><span class="line">x.(T)</span><br><span class="line"></span><br><span class="line">x：表示接口类型的变量</span><br><span class="line">T：表示断言x可能是的类型。</span><br><span class="line"></span><br><span class="line">v, ok := n.(*Dog)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v := x.(<span class="keyword">type</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Error-接口"><a href="#Error-接口" class="headerlink" title="Error 接口"></a>Error 接口</h3><p>Go 语言中把错误当成一种特殊的值来处理，不支持其他语言中使用<code>try/catch</code>捕获异常的方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>error 是一个接口类型，默认零值为<code>nil</code>。所以我们通常将调用函数返回的错误与<code>nil</code>进行比较，以此来判断函数是否返回错误.</p>
<h4 id="创建错误"><a href="#创建错误" class="headerlink" title="创建错误"></a>创建错误</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">errors.New(<span class="string">&quot;无效的id&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Errorf(<span class="string">&quot;查询数据库失败，err:%v&quot;</span>, err)</span><br></pre></td></tr></table></figure>

<h4 id="错误结构体类型"><a href="#错误结构体类型" class="headerlink" title="错误结构体类型"></a>错误结构体类型</h4><p>此外我们还可以自己定义结构体类型，实现&#96;&#96;error&#96;接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpError 自定义结构体类型</span></span><br><span class="line"><span class="keyword">type</span> OpError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error OpError 类型实现error接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *OpError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;无权执行%s操作&quot;</span>, e.Op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h5 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h5><p>使用 <code>new</code> 和 <code>make</code> 可以创建新的对象或数据结构</p>
<p><code>new</code> 函数用于分配一块新的内存，并将其初始化为零值，返回一个指向这块内存的指针。可以用于任何数据类型，但是并没有给这块内存赋值，因此在使用前需要进行赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明一个指向 int 类型的指针</span><br><span class="line">var p *int</span><br><span class="line">p = new(int)  // 分配一块新的内存，并将其初始化为 0，p 指向这块内存</span><br><span class="line">*p = 123      // 给这块内存赋值</span><br></pre></td></tr></table></figure>

<p><code>make</code> 函数则用于分配并初始化一个引用类型的对象（如 <code>slice</code>、<code>map</code>、<code>channel</code>）。返回的是一个该类型的对象而非指针，因为这些对象本身就是引用类型，即指向某个底层数据结构的指针。<code>make</code> 函数会为这些对象分配内存，初始化其内部字段，最后返回该对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为 5 的 int 类型切片，初始值为 0</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个容量为 10 的 int 类型切片，长度为 2，初始值为 0</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 map，初始化为空</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 channel，容量为 10</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>二者都是用来做内存分配的。</li>
<li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li>
<li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li>
</ol>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>在Python中常见的数据类型有以下8个类型，分别是：int，整数类型（整形）、float，浮点类型（浮点型）、bool，布尔类型、str，字符串类型、list，列表类型、tuple，元组类型、dict，字典类型、set，集合类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  int</span><br><span class="line">Python 中的整数没有长度限制，不像其他编程语言有 int，smallint，short，long，longint，long 等</span><br><span class="line"></span><br><span class="line">十进制就不说了，正常的写法</span><br><span class="line">十六进制写法：加前缀 0x，出现 0-9 和 A-F 的数字和字母组合</span><br><span class="line">八进制写法：加前缀 0o，出现 0-7 数字组合</span><br><span class="line">二进制写法：加前缀 0b，只有 0 和 1 数字组合</span><br><span class="line"></span><br><span class="line">2 浮点数 float</span><br><span class="line"></span><br><span class="line">a. 浮点数只能以十进制表示，不能加前缀，否则会报语法错误</span><br><span class="line">浮点数 有长度限制 边界值为：</span><br><span class="line">max=1.7976931348623157e+308 min=2.2250738585072014e-308</span><br><span class="line"></span><br><span class="line">3 布尔值 bool</span><br><span class="line"></span><br><span class="line">布尔值就是我们常说的逻辑，可以理解为对或错</span><br><span class="line">print(100 == 100.0)</span><br><span class="line"></span><br><span class="line">4 复数 complex</span><br><span class="line"></span><br><span class="line"># Python 中的复数这样来表示： 1 + 1j  虚部为 1，仍不可省略</span><br><span class="line">print((1 + 2j).real) # 输出实部 float 类型</span><br><span class="line">print((1 + 2j).imag) # 输出虚部 float 类型</span><br><span class="line"></span><br><span class="line">5 字符串 str</span><br><span class="line">通俗来说，字符串就是字符组成的一串内容，Python 中用成对的单引号或双引号括起来，用三个单引号或双引号可以使字符串内容保持原样输出，可以包含回车等特殊字符，在 Python 中字符串是不可变对象</span><br><span class="line">Python 中用反斜杠 “\” 来转义字符</span><br><span class="line"></span><br><span class="line">6 列表 list</span><br><span class="line">ls = [1, 2, 3, 4, &#x27;a&#x27;, &#x27;b&#x27;, [8, 5, 7]]</span><br><span class="line">for i in ls:</span><br><span class="line">    print(i) </span><br><span class="line"></span><br><span class="line">检查列表中是否存在某个元素</span><br><span class="line">使用 in 关键字，返回值为布尔值   </span><br><span class="line">del ls    </span><br></pre></td></tr></table></figure>

<h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line">    x = 0</span><br><span class="line">    def setX(self, val):</span><br><span class="line">        self.x = val</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="c-类型"><a href="#c-类型" class="headerlink" title="c++ 类型"></a>c++ 类型</h2><h4 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef type newname; </span><br></pre></td></tr></table></figure>

<p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int feet;</span><br></pre></td></tr></table></figure>

<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feet distance;</span><br></pre></td></tr></table></figure>

<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>: 整数类型，通常为 <span class="number">32</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">31</span> 到 <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span></span><br><span class="line"><span class="type">short</span>: 短整数类型，通常为 <span class="number">16</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">15</span> 到 <span class="number">2</span>^<span class="number">15</span><span class="number">-1</span></span><br><span class="line"><span class="type">long</span>: 长整数类型，通常为 <span class="number">32</span> 位或 <span class="number">64</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">31</span> 到 <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span> 或 <span class="number">-2</span>^<span class="number">63</span> 到 <span class="number">2</span>^<span class="number">63</span><span class="number">-1</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>: 长长整数类型，通常为 <span class="number">64</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">63</span> 到 <span class="number">2</span>^<span class="number">63</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>: 无符号整数类型，通常为 <span class="number">32</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">32</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>: 无符号短整数类型，通常为 <span class="number">16</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">16</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>: 无符号长整数类型，通常为 <span class="number">32</span> 位或 <span class="number">64</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">32</span><span class="number">-1</span> 或 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">64</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>: 无符号长长整数类型，通常为 <span class="number">64</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">64</span><span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点型-1"><a href="#浮点型-1" class="headerlink" title="浮点型"></a>浮点型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float: 单精度浮点型，通常为 32 位，可表示范围为 1.17549e-38 到 3.40282e+38，精度为 6 位小数</span><br><span class="line">double: 双精度浮点型，通常为 64 位，可表示范围为 2.22507e-308 到 1.79769e+308，精度为 15 位小数</span><br><span class="line">long double: 长双精度浮点型，通常为 80 位或 128 位，可表示范围和精度比 double 更高</span><br></pre></td></tr></table></figure>

<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char: 字符类型，通常为 8 位，可表示 ASCII 码的字符，例如 &#x27;A&#x27;、&#x27;B&#x27;、&#x27;C&#x27; 等</span><br><span class="line">char16_t: Unicode 字符类型，通常为 16 位</span><br><span class="line">char32_t: Unicode 字符类型，通常为 32 位</span><br><span class="line">wchar_t: 宽字符类型，通常为 16 位或 32 位，用于支持多语言字符集</span><br></pre></td></tr></table></figure>

<h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool: 布尔类型，通常为 1 位，可表示 true 或 false</span><br></pre></td></tr></table></figure>

<h4 id="复数-1"><a href="#复数-1" class="headerlink" title="复数"></a>复数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 C++ 标准库中，复数类型是通过 std::complex 实现的，它定义在 &lt;complex&gt; 头文件中。std::complex 是一个模板类，它接受一个模板参数表示元素类型，可以是 float、double、long double 等</span><br><span class="line"></span><br><span class="line">#include &lt;complex&gt;</span><br><span class="line">std::complex&lt;double&gt; z1(1.0, 2.0); // 定义并初始化一个复数</span><br><span class="line"> // 访问实部和虚部</span><br><span class="line">    std::cout &lt;&lt; &quot;real(z1) = &quot; &lt;&lt; z1.real() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;imag(z1) = &quot; &lt;&lt; z1.imag() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>



<h4 id="枚举类型（enum）"><a href="#枚举类型（enum）" class="headerlink" title="枚举类型（enum）"></a>枚举类型（enum）</h4><p>枚举类型是一种用户自定义的类型，用于定义一些有限的命名值。例如，我们可以使用枚举类型定义一些颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Color c = Green;</span><br></pre></td></tr></table></figure>

<h4 id="指针类型（pointer）"><a href="#指针类型（pointer）" class="headerlink" title="指针类型（pointer）"></a>指针类型（pointer）</h4><p>指针类型是一种保存了内存地址的变量类型。指针变量通常用于动态内存分配、函数调用等方面。例如，下面的代码中，我们定义了一个指针变量 <code>p</code>，并将它指向一个整型变量 <code>x</code> 的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int* p = &amp;x;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="引用（reference）"><a href="#引用（reference）" class="headerlink" title="引用（reference）"></a>引用（reference）</h4><p>在 C++ 中，引用是一种轻量级的指针，它提供了访问变量的另一种方式，它是某个变量的别名。引用通常用于函数参数、返回值和赋值。引用的语法使用 &amp; 符号。引用和指针类似，它们都提供了对变量的间接访问。但是，引用比指针更加安全，因为它们<strong>不会出现空指针</strong>的情况。在<strong>定义引用时必须初始化它</strong>，否则会出现编译错误。另外，引用一旦初始化后，就不能再指向其他变量，因此，引用可以被视为常量指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int&amp; b = a; // 声明 b 为 a 的引用</span><br><span class="line"></span><br><span class="line">b = 10; // 修改 b 也会修改 a</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; // 输出 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数组类型（array）"><a href="#数组类型（array）" class="headerlink" title="数组类型（array）"></a>数组类型（array）</h4><p>数组类型用于保存一组相同类型的数据，可以用下标访问数组中的元素。例如，下面的代码中，我们定义了一个数组 <code>a</code>，包含了三个整型元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[3] = &#123;1, 2, 3&#125;;</span><br><span class="line"></span><br><span class="line">int x = a[0];  // x = 1</span><br></pre></td></tr></table></figure>

<h4 id="结构体类型（struct）"><a href="#结构体类型（struct）" class="headerlink" title="结构体类型（struct）"></a>结构体类型（struct）</h4><p>结构体类型可以用于组合多个不同类型的变量，形成一个新的类型。例如，下面的代码中，我们定义了一个结构体 <code>Person</code>，包含了两个成员变量 <code>name</code> 和 <code>age</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p = &#123;&quot;Tom&quot;, 18&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="共用体类型（union）"><a href="#共用体类型（union）" class="headerlink" title="共用体类型（union）"></a>共用体类型（union）</h4><p>共用体类型可以让多个不同的变量共用一段内存空间，用于节省内存。例如，下面的代码中，我们定义了一个共用体 <code>Number</code>，可以表示一个整型数、一个浮点数或一个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union Number &#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">    char c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="类类型（class）"><a href="#类类型（class）" class="headerlink" title="类类型（class）"></a>类类型（class）</h4><p>在C++中，类是一种用户自定义的数据类型，可以包含数据成员、成员函数等元素。使用class关键字定义类</p>
<p>类是一种用户自定义的数据类型，它可以封装数据和方法。类定义了一组相关的数据和方法，它们通常是一些有意义的操作的集合。C++中的类可以看作是一种数据类型的定义方式，类的实例化（对象）是具体的这种数据类型的实现.</p>
<p>类是面向对象编程（OOP）的基础，其中面向对象的思想主要体现在封装、继承和多态性方面。类可以使用访问修饰符（public、protected、private）来限制成员变量和成员函数的访问权限。类还可以包含构造函数、析构函数、静态成员、常量成员函数等特殊成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  private:</span><br><span class="line">    int age;</span><br><span class="line">  public:</span><br><span class="line">    void setAge(int a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.setAge(25);</span><br><span class="line">int age = p.getAge(); // age = 25</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shape</span><br><span class="line">public 成员：任何地方都可以访问，包括类的外部和派生类。</span><br><span class="line">protected 成员：只能在类内部和派生类中访问，不能在类外部访问。</span><br><span class="line">private 成员：只能在类内部访问，不能在类外部和派生类中访问。</span><br><span class="line"></span><br><span class="line">class Rectangle: public Shape&#123;&#125;</span><br><span class="line"></span><br><span class="line">public：派生类可以访问基类中的公共成员，但不能访问基类的私有成员和受保护成员。</span><br><span class="line">protected：派生类可以访问基类中的公共成员和受保护成员，但不能访问基类的私有成员。</span><br><span class="line">private：派生类不能直接访问基类中的任何成员，包括公共成员、受保护成员和私有成员。</span><br></pre></td></tr></table></figure>

<h4 id="模板类型"><a href="#模板类型" class="headerlink" title="模板类型"></a>模板类型</h4><p>模板类型（template）是 C++ 中非常重要的一种数据类型，它可以用来定义通用的数据类型或函数。模板类型分为类模板和函数模板两种。</p>
<h5 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h5><p>类模板可以用来定义通用的类，例如标准库中的容器类模板 std::vector 和 std::map，它们可以用来存储任何类型的数据，<strong>类模板是用来定义类的蓝图</strong>，<strong>其中某些成员的类型不确定</strong>，而是用类型参数来表示。类型参数可以在使用类模板时指定，从而让编译器根据指定的类型生成对应的类代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Stack &#123;</span><br><span class="line">private:</span><br><span class="line">    T* data;</span><br><span class="line">    int top;</span><br><span class="line">    int capacity;</span><br><span class="line">public:</span><br><span class="line">    Stack(int capacity) : data(new T[capacity]), top(-1), capacity(capacity) &#123;&#125;</span><br><span class="line">    ~Stack() &#123; delete[] data; &#125;</span><br><span class="line">    void push(const T&amp; value) &#123; data[++top] = value; &#125;</span><br><span class="line">    T pop() &#123; return data[top--]; &#125;</span><br><span class="line">    bool empty() const &#123; return top == -1; &#125;</span><br><span class="line">    bool full() const &#123; return top == capacity - 1; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stack&lt;int&gt; intStack(10);</span><br><span class="line">intStack.push(1);</span><br><span class="line">intStack.push(2);</span><br><span class="line">intStack.push(3);</span><br><span class="line">std::cout &lt;&lt; intStack.pop() &lt;&lt; std::endl; // 输出 3</span><br><span class="line"></span><br><span class="line">在这里，我们实例化了一个 Stack 类，并将其元素类型指定为 int，然后调用了它的 push 和 pop 函数。</span><br></pre></td></tr></table></figure>

<h5 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h5><p>函数模板可以用来定义通用的函数，例如标准库中的算法函数 std::sort 和 std::find，它们可以用来操作任何类型的数据，函数模板则是用来定义函数的蓝图，其中某些参数或返回值的类型不确定，而是用类型参数来表示，如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(T* first, T* last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3.14</span></span><br><span class="line"></span><br><span class="line">这是因为编译器根据参数的类型生成了对应的函数代码</span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换是将一个数据类型的值转换为另一种数据类型的值。</p>
<p>C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。</p>
<h5 id="静态转换（Static-Cast）"><a href="#静态转换（Static-Cast）" class="headerlink" title="静态转换（Static Cast）"></a>静态转换（Static Cast）</h5><p>静态转换是将一种数据类型的值强制转换为另一种数据类型的值。</p>
<p>静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。</p>
<p>静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">float f = static_cast&lt;float&gt;(i); // 静态将int类型转换为float类型</span><br></pre></td></tr></table></figure>

<h5 id="动态转换（Dynamic-Cast）"><a href="#动态转换（Dynamic-Cast）" class="headerlink" title="动态转换（Dynamic Cast）"></a>动态转换（Dynamic Cast）</h5><p>动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = new Derived;</span><br><span class="line">Derived* ptr_derived = dynamic_cast&lt;Derived*&gt;(ptr_base); // 将基类指针转换为派生类指针</span><br></pre></td></tr></table></figure>

<h5 id="常量转换（Const-Cast）"><a href="#常量转换（Const-Cast）" class="headerlink" title="常量转换（Const Cast）"></a>常量转换（Const Cast）</h5><p>常量转换用于将 const 类型的对象转换为非 const 类型的对象。</p>
<p>常量转换只能用于转换掉 const 属性，不能改变对象的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int i = 10;</span><br><span class="line">int&amp; r = const_cast&lt;int&amp;&gt;(i); // 常量转换，将const int转换为int</span><br></pre></td></tr></table></figure>

<h5 id="重新解释转换（Reinterpret-Cast）"><a href="#重新解释转换（Reinterpret-Cast）" class="headerlink" title="重新解释转换（Reinterpret Cast）"></a>重新解释转换（Reinterpret Cast）</h5><p>重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。</p>
<p>重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">float f = reinterpret_cast&lt;float&amp;&gt;(i); // 重新解释将int类型转换为float类型</span><br></pre></td></tr></table></figure>

<h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><ol>
<li>多态性：C++ 支持静态多态和动态多态，静态多态通过函数重载和运算符重载实现，动态多态通过虚函数实现。</li>
<li>抽象类：C++ 中可以定义纯虚函数，一个类如果包含纯虚函数，该类就是抽象类，抽象类不能实例化对象，只能被其他类继承。</li>
<li>友元函数：C++ 中的友元函数可以访问类的私有成员，但不是类的成员函数，友元函数可以定义在类内或类外。</li>
<li>内联函数：C++ 中的内联函数在函数调用处直接展开，减少函数调用的开销，可以在函数前加 inline 关键字将其声明为内联函数。</li>
<li>类模板：C++ 中可以定义类模板，用来创建具有不同数据类型的类，类模板可以具有成员函数和成员变量。</li>
<li>构造函数和析构函数：C++ 中的构造函数用来初始化类的对象，析构函数用来清理对象所占用的资源，构造函数和析构函数都是特殊的成员函数，一个类可以有多个构造函数，但只能有一个析构函数。</li>
<li>拷贝构造函数和移动构造函数：C++ 中的拷贝构造函数用来复制一个对象到另一个对象，移动构造函数用来移动一个对象到另一个对象，移动构造函数可以更高效地将对象转移，避免了不必要的复制操作。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://anxiangyipiao.github.io/anxiangblog.github.io">暗香依飘</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://anxiangyipiao.github.io/anxiangblog.github.io/2024/07/09/%E2%95%A9%C2%A4%E2%95%9B%E2%96%8C%E2%94%94%D1%80%E2%95%A8%E2%95%90/">https://anxiangyipiao.github.io/anxiangblog.github.io/2024/07/09/%E2%95%A9%C2%A4%E2%95%9B%E2%96%8C%E2%94%94%D1%80%E2%95%A8%E2%95%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://anxiangyipiao.github.io/anxiangblog.github.io" target="_blank">AnXiang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/anxiangblog.github.io/tags/Go-python-C/">Go python C++</a></div><div class="post_share"><div class="social-share" data-image="/anxiangblog.github.io/./img/home.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/anxiangblog.github.io/2024/07/09/%E2%95%A1%D0%B5%E2%95%98%D0%BA%E2%96%93%D1%82%E2%95%A9%E2%95%98/" title="Go 单元测试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="onerror=null;src='/anxiangblog.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go 单元测试</div></div></a></div><div class="next-post pull-right"><a href="/anxiangblog.github.io/2023/10/09/Redis/" title="Redis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="onerror=null;src='/anxiangblog.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/anxiangblog.github.io/2024/07/09/Go%20vs%20C++%20vs%20python%20%20%20%E2%95%97%E2%88%99%E2%94%A4%D0%B1%E2%95%93%D0%BA%E2%95%A9%E2%95%A2%E2%95%A2%E2%95%98%E2%96%92%E2%95%9A/" title="Go vs C++ vs python"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="title">Go vs C++ vs python</div></div></a></div><div><a href="/anxiangblog.github.io/2024/07/09/%E2%95%96%E2%94%A4%E2%95%94%D1%84/" title="Go vs C++ vs python 反射"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="title">Go vs C++ vs python 反射</div></div></a></div><div><a href="/anxiangblog.github.io/2024/07/09/%E2%95%96%E2%95%91%E2%95%A8%E2%95%90/" title="Go vs C++ vs python 泛型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="title">Go vs C++ vs python 泛型</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/img/favicon.png" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">暗香依飘</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/anxiangblog.github.io/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/anxiangblog.github.io/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/anxiangblog.github.io/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="https://anxiangyipiao.github.io"><i class="fab fa-github"></i><span>Like You</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is our Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">二、基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go"><span class="toc-number">2.</span> <span class="toc-text">go</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%BD%A2"><span class="toc-number">2.1.</span> <span class="toc-text">整形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC-bool"><span class="toc-number">2.3.</span> <span class="toc-text">布尔值 bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">复数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#byte%E5%92%8Crune%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">byte和rune类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%88Pointer%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">指针类型（Pointer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.</span> <span class="toc-text">Array(数组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.8.1.</span> <span class="toc-text">数组的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.8.2.</span> <span class="toc-text">数组的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.3.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.8.4.</span> <span class="toc-text">数组是值类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%EF%BC%88slice%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">切片（slice）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%A3%B0%E6%98%8E"><span class="toc-number">2.9.1.</span> <span class="toc-text">切片声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8make-%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%88%87%E7%89%87"><span class="toc-number">2.9.2.</span> <span class="toc-text">使用make()函数构造切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E5%88%87%E7%89%87"><span class="toc-number">2.9.3.</span> <span class="toc-text">多维切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C"><span class="toc-number">2.9.4.</span> <span class="toc-text">切片操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">2.9.5.</span> <span class="toc-text">扩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">2.10.</span> <span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E5%A3%B0%E6%98%8E"><span class="toc-number">2.10.1.</span> <span class="toc-text">map声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">2.10.2.</span> <span class="toc-text">判断某个键是否存在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E6%93%8D%E4%BD%9C"><span class="toc-number">2.10.3.</span> <span class="toc-text">map操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93Struct"><span class="toc-number">2.11.</span> <span class="toc-text">结构体Struct</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.11.1.</span> <span class="toc-text">自定义类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.11.2.</span> <span class="toc-text">结构体实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.11.3.</span> <span class="toc-text">创建指针类型结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%9C%B0%E5%9D%80%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.11.4.</span> <span class="toc-text">取结构体的地址实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.11.5.</span> <span class="toc-text">结构体初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.6.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">2.11.7.</span> <span class="toc-text">方法和接收者</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">2.11.7.1.</span> <span class="toc-text">什么时候应该使用指针类型接收者</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">2.11.8.</span> <span class="toc-text">结构体的匿名字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.11.9.</span> <span class="toc-text">嵌套结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D"><span class="toc-number">2.11.10.</span> <span class="toc-text">结构体的“继承”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.11.11.</span> <span class="toc-text">结构体字段的可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8EJSON%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.11.12.</span> <span class="toc-text">结构体与JSON序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%EF%BC%88Tag%EF%BC%89"><span class="toc-number">2.11.13.</span> <span class="toc-text">结构体标签（Tag）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.11.14.</span> <span class="toc-text">结构体和方法补充知识点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0Func"><span class="toc-number">2.12.</span> <span class="toc-text">函数Func</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">2.12.0.1.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.12.0.2.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="toc-number">2.12.0.3.</span> <span class="toc-text">函数进阶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="toc-number">2.12.0.4.</span> <span class="toc-text">函数类型与变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">2.12.0.5.</span> <span class="toc-text">函数作为参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.12.0.6.</span> <span class="toc-text">函数作为返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-number">2.12.0.7.</span> <span class="toc-text">匿名函数和闭包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defer%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.12.0.8.</span> <span class="toc-text">defer语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.12.0.9.</span> <span class="toc-text">内置函数介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3interface"><span class="toc-number">2.13.</span> <span class="toc-text">接口interface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.13.1.</span> <span class="toc-text">接口类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.13.2.</span> <span class="toc-text">实现接口的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="toc-number">2.13.3.</span> <span class="toc-text">面向接口编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">2.13.4.</span> <span class="toc-text">接口类型变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">2.13.5.</span> <span class="toc-text">值接收者和指针接收者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.13.6.</span> <span class="toc-text">类型与接口的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%84%E5%90%88"><span class="toc-number">2.13.7.</span> <span class="toc-text">接口组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.13.8.</span> <span class="toc-text">空接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="toc-number">2.13.9.</span> <span class="toc-text">接口值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">2.13.10.</span> <span class="toc-text">类型断言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.14.</span> <span class="toc-text">Error 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%94%99%E8%AF%AF"><span class="toc-number">2.14.1.</span> <span class="toc-text">创建错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.14.2.</span> <span class="toc-text">错误结构体类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">2.15.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#new%E5%92%8Cmake"><span class="toc-number">2.15.0.1.</span> <span class="toc-text">new和make</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python"><span class="toc-number">3.</span> <span class="toc-text">python</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.1.</span> <span class="toc-text">类类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">c++ 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef-%E5%A3%B0%E6%98%8E"><span class="toc-number">4.0.1.</span> <span class="toc-text">typedef 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">4.0.2.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B-1"><span class="toc-number">4.0.3.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-number">4.0.4.</span> <span class="toc-text">字符型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">4.0.5.</span> <span class="toc-text">布尔型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0-1"><span class="toc-number">4.0.6.</span> <span class="toc-text">复数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%EF%BC%88enum%EF%BC%89"><span class="toc-number">4.0.7.</span> <span class="toc-text">枚举类型（enum）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%88pointer%EF%BC%89"><span class="toc-number">4.0.8.</span> <span class="toc-text">指针类型（pointer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%EF%BC%88reference%EF%BC%89"><span class="toc-number">4.0.9.</span> <span class="toc-text">引用（reference）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%EF%BC%88array%EF%BC%89"><span class="toc-number">4.0.10.</span> <span class="toc-text">数组类型（array）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%88struct%EF%BC%89"><span class="toc-number">4.0.11.</span> <span class="toc-text">结构体类型（struct）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%88union%EF%BC%89"><span class="toc-number">4.0.12.</span> <span class="toc-text">共用体类型（union）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%EF%BC%88class%EF%BC%89"><span class="toc-number">4.0.13.</span> <span class="toc-text">类类型（class）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90"><span class="toc-number">4.0.13.1.</span> <span class="toc-text">继承权限</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.0.14.</span> <span class="toc-text">模板类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.0.14.1.</span> <span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.0.14.2.</span> <span class="toc-text">函数模板</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.0.15.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%88Static-Cast%EF%BC%89"><span class="toc-number">4.0.15.1.</span> <span class="toc-text">静态转换（Static Cast）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%88Dynamic-Cast%EF%BC%89"><span class="toc-number">4.0.15.2.</span> <span class="toc-text">动态转换（Dynamic Cast）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%BD%AC%E6%8D%A2%EF%BC%88Const-Cast%EF%BC%89"><span class="toc-number">4.0.15.3.</span> <span class="toc-text">常量转换（Const Cast）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%A7%A3%E9%87%8A%E8%BD%AC%E6%8D%A2%EF%BC%88Reinterpret-Cast%EF%BC%89"><span class="toc-number">4.0.15.4.</span> <span class="toc-text">重新解释转换（Reinterpret Cast）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-1"><span class="toc-number">4.0.16.</span> <span class="toc-text">补充</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/cpu%E7%9C%BC%E4%B8%AD%E7%9A%84c++/" title="c++"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="c++"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/cpu%E7%9C%BC%E4%B8%AD%E7%9A%84c++/" title="c++">c++</a><time datetime="2024-07-09T03:08:40.492Z" title="发表于 2024-07-09 11:08:40">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/mysql/" title="Mysql"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="Mysql"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/mysql/" title="Mysql">Mysql</a><time datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/Go%20vs%20C++%20vs%20python%20%20%20%E2%95%97%E2%88%99%E2%94%A4%D0%B1%E2%95%93%D0%BA%E2%95%A9%E2%95%A2%E2%95%A2%E2%95%98%E2%96%92%E2%95%9A/" title="Go vs C++ vs python"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="Go vs C++ vs python"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/Go%20vs%20C++%20vs%20python%20%20%20%E2%95%97%E2%88%99%E2%94%A4%D0%B1%E2%95%93%D0%BA%E2%95%A9%E2%95%A2%E2%95%A2%E2%95%98%E2%96%92%E2%95%9A/" title="Go vs C++ vs python">Go vs C++ vs python</a><time datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/go%20%E2%95%99%D1%8F%E2%95%A4%E2%95%98%E2%95%A3%D1%86%E2%95%96%E2%95%A2/" title="go 语言规范"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/./img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="go 语言规范"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/go%20%E2%95%99%D1%8F%E2%95%A4%E2%95%98%E2%95%A3%D1%86%E2%95%96%E2%95%A2/" title="go 语言规范">go 语言规范</a><time datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/anxiangblog.github.io/2024/07/09/%E2%94%90%D0%B8%E2%95%96%E2%95%9C/" title="卡方测验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/anxiangblog.github.io/img/home2.jpg%20/img/home3.jpg%20/img/home.jpg" onerror="this.onerror=null;this.src='/anxiangblog.github.io/img/404.jpg'" alt="卡方测验"/></a><div class="content"><a class="title" href="/anxiangblog.github.io/2024/07/09/%E2%94%90%D0%B8%E2%95%96%E2%95%9C/" title="卡方测验">卡方测验</a><time datetime="2024-07-09T02:42:59.732Z" title="发表于 2024-07-09 10:42:59">2024-07-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/anxiangblog.github.io/./img/home.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 暗香依飘</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/anxiangblog.github.io/js/utils.js"></script><script src="/anxiangblog.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'diBhtLp5zcy429eQQ21ikoNl-gzGzoHsz',
      appKey: '6clFk0OD64y2clBFdpNvlYzS',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="netease" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/anxiangblog.github.io/js/search/local-search.js"></script></div></div></body></html>