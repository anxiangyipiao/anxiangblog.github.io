<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go vs C++ vs python 泛型</title>
      <link href="/anxiangblog.github.io/2023/04/27/%E6%B3%9B%E5%9E%8B/"/>
      <url>/anxiangblog.github.io/2023/04/27/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><p>泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。ーー换句话说，在编写某些代码或数据结构时先不提供值的类型，而是之后再提供。</p><p>这个函数只能接收<code>[]int</code>类型的参数，如果我们想支持<code>[]float64</code>类型的参数，我们就需要再定义一个<code>reverseFloat64Slice</code>函数。</p><p>一遍一遍地编写相同的功能是低效的，实际上这个反转切片的函数并不需要知道切片中元素的类型，但为了适用不同的类型我们把一段代码重复了很多遍。</p><h3 id="泛型实现"><a href="#泛型实现" class="headerlink" title="泛型实现"></a>泛型实现</h3><p>泛型为Go语言添加了三个新的重要特性:</p><ol><li>函数和类型的类型参数。</li><li>将接口类型定义为类型集，包括没有方法的类型。</li><li>类型推断，它允许在调用函数时在许多情况下省略类型参数。</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float64</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m1 := min[<span class="type">int</span>](<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">m2 := min[<span class="type">float64</span>](<span class="number">-0.1</span>, <span class="number">-0.2</span>)  <span class="comment">// -0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向 min 函数提供类型参数(在本例中为int和float64)称为实例化（ instantiation ）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先，编译器在整个泛型函数或类型中将所有类型形参（type parameters）替换为它们各自的类型实参（type arguments）。</span></span><br><span class="line"><span class="comment">//其次，编译器验证每个类型参数是否满足相应的约束。</span></span><br><span class="line"></span><br><span class="line">fmin := min[<span class="type">float64</span>] <span class="comment">// 类型实例化，编译器生成T=float64的min函数</span></span><br><span class="line">m2 = fmin(<span class="number">1.2</span>, <span class="number">2.3</span>)  <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure><h3 id="类型参数的使用"><a href="#类型参数的使用" class="headerlink" title="类型参数的使用"></a>类型参数的使用</h3><h4 id="类型参数的使用-1"><a href="#类型参数的使用-1" class="headerlink" title="类型参数的使用"></a>类型参数的使用</h4><p>除了函数中支持使用类型参数列表外，类型也可以使用类型参数列表。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span> | <span class="type">string</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map[K <span class="type">int</span> | <span class="type">string</span>, V <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">map</span>[K]V</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tree[T <span class="keyword">interface</span>&#123;&#125;] <span class="keyword">struct</span> &#123;</span><br><span class="line">left, right *Tree[T]</span><br><span class="line">value       T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用泛型类型，必须进行实例化。<code>Tree[string]</code>是使用类型实参<code>string</code>实例化 <code>Tree</code> 的示例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringTree Tree[<span class="type">string</span>]</span><br></pre></td></tr></table></figure><h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>&#x2F;&#x2F;作为类型约束使用的接口类型可以事先定义并支持复用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型约束字面量，通常外层interface&#123;&#125;可省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">interface</span></span>&#123; <span class="type">int</span> | <span class="type">float64</span> &#125;](a, b T) T &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为类型约束使用的接口类型可以事先定义并支持复用。</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="type">int</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">Value</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型集"><a href="#类型集" class="headerlink" title="类型集"></a>类型集</h3><p><strong>Go1.18开始接口类型的定义也发生了改变，由过去的接口类型定义方法集（method set）变成了接口类型定义类型集（type set）。</strong>也就是说，接口类型现在可以用作值的类型，也可以用作类型约束。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> V <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="type">int</span> | <span class="type">string</span> | <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就定义了一个包含 <code>int</code>、 <code>string</code> 和 <code>bool</code> 类型的类型集。</p><p>在 Go 1.18中，接口既可以像以前一样包含方法和嵌入式接口，但也可以嵌入非接口类型、类型并集和基础类型的集合。</p><p>当用作类型约束时，由接口定义的类型集精确地指定允许作为相应类型参数的类型。</p><ul><li><p><code>|</code>符号</p><p><code>T1 | T2</code>表示类型约束为T1和T2这两个类型的并集，例如下面的<code>Integer</code>类型表示由<code>Signed</code>和<code>Unsigned</code>组成。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Signed | Unsigned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>~</code>符号</p><p><code>~T</code>表示所以底层类型是T的类型，例如<code>~string</code>表示所有底层类型是<code>string</code>的类型集合。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span>  <span class="comment">// MyString的底层类型是string</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>~</code>符号后面只能是基本类型。</p></li></ul><p>接口作为类型集是一种强大的新机制，是使类型约束能够生效的关键。目前，使用新语法表的接口只能用作类型约束。</p><h4 id="any"><a href="#any" class="headerlink" title="any"></a>any</h4><p>空接口在类型参数列表中很常见，在Go 1.18引入了一个新的预声明标识符，作为空接口类型的别名。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/builtin/builtin.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> any = <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>由此，我们可以使用如下代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>[<span class="title">S</span> ~[]<span class="title">E</span>, <span class="title">E</span> <span class="title">any</span>]<span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>最后一个新的主要语言特征是类型推断。从某些方面来说，这是语言中最复杂的变化，但它很重要，因为它能让人们在编写调用泛型函数的代码时更自然。</p><p>在许多情况下，编译器可以从普通参数推断 <code>T</code> 的类型实参。这使得代码更短，同时保持清晰。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, m <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">m = min(a, b) <span class="comment">// 无需指定类型实参</span></span><br></pre></td></tr></table></figure><h4 id="约束类型推断"><a href="#约束类型推断" class="headerlink" title="约束类型推断"></a>约束类型推断</h4><p>Point 类型有方法 但是泛型后无法找到String()方法，需要声明一下<code>Point</code>类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Scale 返回切片中每个元素都乘c的副本切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span>[<span class="title">E</span> <span class="title">constraints</span>.<span class="title">Integer</span>]<span class="params">(s []E, c E)</span></span> []E &#123;</span><br><span class="line">    r := <span class="built_in">make</span>([]E, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        r[i] = v * c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point []<span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    b, _ := json.Marshal(p)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于一个<code>Point</code>其实就是一个整数切片，我们可以使用前面编写的<code>Scale</code>函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleAndPrint</span><span class="params">(p Point)</span></span> &#123;</span><br><span class="line">    r := Scale(p, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(r.String()) <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这代码会编译失败，输出<code>r.String undefined (type []int32 has no field or method String</code>的错误。</p><p>问题是<code>Scale</code>函数返回类型为<code>[]E</code>的值，其中<code>E</code>是参数切片的元素类型。当我们使用<code>Point</code>类型的值调用<code>Scale</code>（其基础类型为[]int32）时，我们返回的是<code>[]int32</code>类型的值，而不是<code>Point</code>类型。这源于泛型代码的编写方式，但这不是我们想要的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span>[<span class="title">S</span> ~[]<span class="title">E</span>, <span class="title">E</span> <span class="title">constraints</span>.<span class="title">Integer</span>]<span class="params">(s S, c E)</span></span> S &#123;</span><br><span class="line">    r := <span class="built_in">make</span>(S, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        r[i] = v * c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，如果你发现自己多次编写完全相同的代码，而这些代码之间的唯一区别就是使用的类型不同，这个时候你就应该考虑是否可以使用类型参数。</p><p>泛型和接口类型之间并不是替代关系，而是相辅相成的关系。泛型的引入是为了配合接口的使用，让我们能够编写更加类型安全的Go代码，并能有效地减少重复代码。</p><p><strong>这意味着使用类型参数通常不会比使用接口类型快。因此，不要为了速度而从接口类型更改为类型参数，因为它可能不会运行得更快</strong></p><h2 id="Go反射-泛型"><a href="#Go反射-泛型" class="headerlink" title="Go反射 泛型"></a>Go反射 泛型</h2><p>Go具有运行时反射。反射允许一种泛型编程，因为它允许你编写适用于任何类型的代码。</p><p>如果某些操作甚至必须支持没有方法的类型（不能使用接口类型），并且每个类型的操作都不同（不能使用类型参数），请使用反射。</p><p>encoding&#x2F;json包就是一个例子。我们不想要求我们编码的每个类型都有MarshalJSON方法，所以我们不能使用接口类型。但对接口类型的编码与对结构类型的编码不同，因此我们不应该使用类型参数。相反，该包使用反射。代码不简单，但它有效</p><p>最后，关于何时使用泛型的讨论可以简化为一个简单的指导原则。</p><p>如果您发现自己多次编写完全相同的代码，其中副本之间的唯一区别是代码使用不同的类型，请考虑是否可以使用类型参数。</p><p>另一种说法是，在注意到要多次编写完全相同的代码之前，应该避免使用类型参数。</p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>Python 是一种动态类型语言，它的变量类型是在运行时动态推断的。与其他静态类型语言不同，Python 并没有直接的泛型类型。但是，可以通过使用类型变量来实现类似泛型的效果.</p><p><strong>在 Python 中，我们可以使用类型提示（Type Hints）和 TypeVar 两个模块来模拟泛型。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, TypeVar</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_list</span>(<span class="params">lst: <span class="type">List</span>[T]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">        <span class="built_in">print</span>(item)   </span><br><span class="line">        </span><br><span class="line">int_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print_list[<span class="built_in">int</span>](int_list)</span><br><span class="line"></span><br><span class="line">str_list = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>]</span><br><span class="line">print_list[<span class="built_in">str</span>](str_list)</span><br><span class="line">       </span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>挺简单的223333333</p><p>除了类型提示和类型变量之外，Python 还提供了一些其他的泛型工具和库，例如 <code>typing</code> 模块中的 <code>Union</code> 和 <code>Optional</code> 类型，以及第三方库如 <code>Generics</code> 和 <code>dataclasses</code> 等。这些工具可以帮助开发人员更好地进行类型检查和处理，提高代码的可读性和可维护性。</p><p>另外，Python 的泛型机制虽然比其他语言灵活，但也存在一些限制和缺陷。例如，Python 的类型提示只是一种静态检查，运行时仍然可以接受不同的类型，这可能导致类型错误和运行时异常。此外，在使用泛型时需要谨慎处理类型转换和类型推断等问题，避免出现意外行为和难以调试的问题。</p><h3 id="typing-模块"><a href="#typing-模块" class="headerlink" title="typing 模块"></a><code>typing</code> 模块</h3><p><code>typing</code> 模块是 Python 3.5 引入的，它为类型提示提供了很多有用的工具和注释。</p><p>该模块提供了许多类型提示，例如：</p><ul><li><code>List[T]</code>：代表一个由类型 T 组成的列表。</li><li><code>Tuple[T1, T2, ..., Tn]</code>：代表一个由类型 T1、T2、…、Tn 组成的元组。</li><li><code>Dict[Tkey, Tvalue]</code>：代表一个由键值对组成的字典，其中键的类型为 Tkey，值的类型为 Tvalue。</li><li><code>Set[T]</code>：代表一个由类型 T 组成的集合。</li><li><code>Union[T1, T2, ..., Tn]</code>：代表类型 T1、T2、…、Tn 中的任何一个类型。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">numbers: <span class="type">List</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(numbers) / <span class="built_in">len</span>(numbers)</span><br><span class="line"></span><br><span class="line">当然，这只是类型提示的一部分，实际上 Python 解释器并不会检查这些类型。不过，这些类型提示对于代码维护和可读性来说是很有帮助的。</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="模板（Template）"><a href="#模板（Template）" class="headerlink" title="模板（Template）"></a>模板（Template）</h3><p><strong>C++ 的泛型是通过模板（Template）实现的。模板是一种代码生成机制，可以在编译时根据参数类型自动生成代码。C++ 模板支持函数模板和类模板两种</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">函数模板</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">类模板</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以使用泛型来实现一个通用的排序算法，可以接受任何类型的数组，并按照一定的规则进行排序。比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void printArray(std::vector&lt;T&gt; arr) &#123;</span><br><span class="line">    for (auto x : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void bubbleSort(std::vector&lt;T&gt;&amp; arr) &#123;</span><br><span class="line">    int n = arr.size();</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n - i - 1; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                std::swap(arr[j], arr[j + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; arr1 = &#123;3, 2, 1, 5, 4&#125;;</span><br><span class="line">    std::vector&lt;double&gt; arr2 = &#123;3.14, 2.71, 1.41, 4.0, 1.73&#125;;</span><br><span class="line">    std::vector&lt;std::string&gt; arr3 = &#123;&quot;hello&quot;, &quot;world&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    bubbleSort(arr1);</span><br><span class="line">    bubbleSort(arr2);</span><br><span class="line">    bubbleSort(arr3);</span><br><span class="line"></span><br><span class="line">    printArray(arr1);</span><br><span class="line">    printArray(arr2);</span><br><span class="line">    printArray(arr3);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数模板-高级用法"><a href="#函数模板-高级用法" class="headerlink" title="函数模板 高级用法"></a>函数模板 高级用法</h3><ol><li>模板特化（Template Specialization）：对于某些特定的类型，需要使用不同于模板定义的实现，这时候可以使用模板特化来实现。</li></ol><p>例如，以下代码定义了一个函数模板 <code>print</code>，用于输出传入的参数，当模板参数为 <code>int</code> 类型时，需要使用特殊的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The int value is: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.可变参数模板（Variadic Templates）：函数模板可以接受任意数量的参数，这个数量在编译期是不确定的。可变参数模板就是指能够接受可变数量参数的函数模板。</p><p>例如，以下代码定义了一个可变参数模板 <code>print</code>，可以输出任意数量的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cppCopy codetemplate &lt;typename T&gt;</span><br><span class="line">void print(T arg) &#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename... Args&gt;</span><br><span class="line">void print(T arg, Args... args) &#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; &quot;, &quot;;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3.<strong>SFINAE</strong>（Substitution Failure Is Not An Error）：这是一种编译期技术，用于在编译期对模板参数进行过滤，使得只有符合条件的模板参数才能够使用模板函数。</p><p>例如，以下代码定义了一个函数模板 <code>foo</code>，使用了 SFINAE 技术，<strong>只有当模板参数是一个整型类型时才会编译通过</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cppCopy codetemplate &lt;typename T&gt;</span><br><span class="line">typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type</span><br><span class="line">foo(T t) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Integral type&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::type</span><br><span class="line">foo(T t) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Not integral type&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板-高级用法"><a href="#类模板-高级用法" class="headerlink" title="类模板 高级用法"></a>类模板 高级用法</h3><ol><li>模板特化（Template specialization）：有时候，针对某些特定的类型，可以为类模板提供专门的实现，这被称为模板特化。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c++Copy codetemplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;generic implementation&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;specialized implementation for int&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myclass&lt;<span class="type">double</span>&gt; obj1;</span><br><span class="line">    obj1.<span class="built_in">foo</span>(); <span class="comment">// generic implementation</span></span><br><span class="line"></span><br><span class="line">    myclass&lt;<span class="type">int</span>&gt; obj2;</span><br><span class="line">    obj2.<span class="built_in">foo</span>(); <span class="comment">// specialized implementation for int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>模板嵌套（Template nesting）：在类模板中定义另一个类模板或函数模板。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c++Copy codetemplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">nested_class</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;template nesting&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myclass&lt;<span class="type">int</span>&gt;::nested_class&lt;<span class="type">double</span>&gt; obj;</span><br><span class="line">    obj.<span class="built_in">foo</span>(); <span class="comment">// template nesting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>模板模板参数（Template template parameter）：允许将模板作为模板参数传递。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c++Copy codetemplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;generic implementation&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Container&lt;<span class="type">int</span>&gt; obj;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>&lt;myclass&gt;(); <span class="comment">// generic implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go python C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go vs C++ vs python</title>
      <link href="/anxiangblog.github.io/2023/04/27/Go%20vs%20C++%20vs%20python%20%20%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AF%B9%E6%AF%94/"/>
      <url>/anxiangblog.github.io/2023/04/27/Go%20vs%20C++%20vs%20python%20%20%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="Go-vs-C-vs-python-基础知识对比"><a href="#Go-vs-C-vs-python-基础知识对比" class="headerlink" title="Go vs C++ vs python   基础知识对比"></a>Go vs C++ vs python   基础知识对比</h1><p>回顾一下这几个软件的基础知识吧，也算对过去一年的总结。ps.都是最基本的东西，同时对比也看一下各语言的差别。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Python</strong>是一种高级编程语言，它非常适合于快速开发和原型设计。它也被称为<strong>解释型</strong>语言，因为它的代码在运行时被解释成机器代码。</p><p><strong>Go</strong>是由Google开发的一种<strong>静态类型</strong>的编程语言。它在系统编程、网络编程和并发编程方面表现出色。</p><p><strong>C++<strong>是一种高效的系统级</strong>静态类型</strong>编程语言，广泛用于开发操作系统、游戏和高性能应用程序。</p><h2 id="一、变量和常量"><a href="#一、变量和常量" class="headerlink" title="一、变量和常量"></a>一、变量和常量</h2><p>变量和常量是编程中必不可少的部分，也是很好理解的一部分。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a><strong>标识符</strong></h3><p><strong>标识符</strong>就是我们在程序中需要用到的变量、常量、函数、属性、类、模块等需要我们来自己定义的名字</p><p>Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code></p><p>标识符都是一样的。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><h4 id="Go语言中有25个关键字："><a href="#Go语言中有25个关键字：" class="headerlink" title="Go语言中有25个关键字："></a>Go语言中有25个关键字：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line">    <span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line">    <span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line">    <span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line">    <span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br><span class="line"></span><br><span class="line">此外，Go语言中还有<span class="number">37</span>个保留字。</span><br><span class="line"></span><br><span class="line">    Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        Types:    <span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span>  </span><br><span class="line">                  <span class="type">uint</span>  <span class="type">uint8</span>  <span class="type">uint16</span>  <span class="type">uint32</span>  <span class="type">uint64</span>  <span class="type">uintptr</span></span><br><span class="line">                  <span class="type">float32</span>  <span class="type">float64</span>  <span class="type">complex128</span>  <span class="type">complex64</span></span><br><span class="line">                  <span class="type">bool</span>  <span class="type">byte</span>  <span class="type">rune</span>  <span class="type">string</span>  <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">                 <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">                 <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h4 id="python内置的关键字有33个"><a href="#python内置的关键字有33个" class="headerlink" title="python内置的关键字有33个"></a>python内置的关键字有33个</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(<span class="string">&quot;keywords&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3结果</span></span><br><span class="line"><span class="literal">False</span>               <span class="keyword">def</span>                 <span class="title function_">if</span>                  <span class="keyword">raise</span></span><br><span class="line"><span class="literal">None</span>                <span class="keyword">del</span>                 <span class="keyword">import</span>              <span class="keyword">return</span></span><br><span class="line"><span class="literal">True</span>                <span class="keyword">elif</span>                <span class="keyword">in</span>                  <span class="keyword">try</span></span><br><span class="line"><span class="keyword">and</span>                 <span class="keyword">else</span>                <span class="keyword">is</span>                  <span class="keyword">while</span></span><br><span class="line"><span class="keyword">as</span>                  <span class="keyword">except</span>              <span class="keyword">lambda</span>              <span class="keyword">with</span></span><br><span class="line"><span class="keyword">assert</span>              <span class="keyword">finally</span>             <span class="keyword">nonlocal</span>            <span class="keyword">yield</span></span><br><span class="line"><span class="keyword">break</span>               <span class="keyword">for</span>                 <span class="keyword">not</span></span><br><span class="line"><span class="keyword">class</span>               <span class="title class_">from</span>                <span class="keyword">or</span></span><br><span class="line"><span class="keyword">continue</span>            <span class="keyword">global</span>              <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="c-关键字ps-c-对多"><a href="#c-关键字ps-c-对多" class="headerlink" title="c++ 关键字ps c++对多"></a>c++ 关键字ps c++对多</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alignas</span>         <span class="keyword">alignof</span>         <span class="keyword">and</span>             <span class="keyword">and_eq</span>          <span class="keyword">asm</span></span><br><span class="line"><span class="keyword">auto</span>            <span class="keyword">bitand</span>          <span class="keyword">bitor</span>           <span class="type">bool</span>            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span>            <span class="keyword">catch</span>           <span class="type">char</span>            <span class="type">char16_t</span>        <span class="type">char32_t</span></span><br><span class="line"><span class="keyword">class</span>           <span class="title class_">compl</span>           <span class="type">const</span>           <span class="keyword">constexpr</span>       <span class="keyword">const_cast</span></span><br><span class="line"><span class="keyword">continue</span>        <span class="keyword">decltype</span>        <span class="keyword">default</span>         <span class="keyword">delete</span>          <span class="keyword">do</span></span><br><span class="line"><span class="type">double</span>          <span class="keyword">dynamic_cast</span>   <span class="keyword">else</span>            <span class="keyword">enum</span>            <span class="keyword">explicit</span></span><br><span class="line"><span class="keyword">export</span>          <span class="keyword">extern</span>          <span class="literal">false</span>           <span class="type">float</span>           <span class="keyword">for</span></span><br><span class="line"><span class="keyword">friend</span>          <span class="keyword">goto</span>            <span class="keyword">if</span>              <span class="keyword">inline</span>          <span class="type">int</span></span><br><span class="line"><span class="type">long</span>            <span class="keyword">mutable</span>         <span class="keyword">namespace</span>       <span class="keyword">new</span>             <span class="keyword">noexcept</span></span><br><span class="line"><span class="keyword">not</span>             <span class="keyword">not_eq</span>          <span class="literal">nullptr</span>         <span class="keyword">operator</span>        <span class="keyword">or</span></span><br><span class="line"><span class="keyword">or_eq</span>           <span class="keyword">private</span>         <span class="keyword">protected</span>       <span class="keyword">public</span>          <span class="keyword">register</span></span><br><span class="line"><span class="keyword">reinterpret_cast</span>    <span class="keyword">return</span>      <span class="type">short</span>           <span class="type">signed</span>          <span class="keyword">sizeof</span></span><br><span class="line"><span class="type">static</span>          <span class="keyword">static_assert</span>  <span class="keyword">static_cast</span>    <span class="keyword">struct</span>           <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">template</span>        <span class="keyword">this</span>            <span class="keyword">thread_local</span>   <span class="keyword">throw</span>           <span class="literal">true</span></span><br><span class="line"><span class="keyword">try</span>             <span class="keyword">typedef</span>        <span class="keyword">typeid</span>          <span class="keyword">typename</span>        <span class="keyword">union</span></span><br><span class="line"><span class="type">unsigned</span>        <span class="keyword">using</span>           <span class="keyword">virtual</span>         <span class="type">void</span>           <span class="keyword">volatile</span></span><br><span class="line"><span class="type">wchar_t</span>         <span class="keyword">while</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="Go语言的变量声明格式为："><a href="#Go语言的变量声明格式为：" class="headerlink" title="Go语言的变量声明格式为："></a>Go语言的变量声明格式为：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;zax&quot;</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="type">bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">string</span></span><br><span class="line">    b <span class="type">int</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">    d <span class="type">float32</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 切片、函数、指针变量的默认为nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此外go支持类型推导 </span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数内部，可以使用更简略的 := 方式声明并初始化变量. 注意是函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">10</span></span><br><span class="line">m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名变量</span></span><br><span class="line"><span class="comment">//在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示</span></span><br><span class="line">x, _ := foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明</span></span><br><span class="line"><span class="comment">// 函数外的每个语句都必须以关键字开始（var、const、func等）</span></span><br><span class="line"><span class="comment">// :=不能使用在函数外。</span></span><br><span class="line"><span class="comment">// _多用于占位，表示忽略值。</span></span><br></pre></td></tr></table></figure><h4 id="python语言的变量声明格式为"><a href="#python语言的变量声明格式为" class="headerlink" title="python语言的变量声明格式为:"></a>python语言的变量声明格式为:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_variable = <span class="number">42</span></span><br><span class="line">name = <span class="string">&quot;zax&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#批量声明</span></span><br><span class="line">x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line">//匿名变量</span><br><span class="line">_, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="c-语言的变量声明格式为"><a href="#c-语言的变量声明格式为" class="headerlink" title="c++语言的变量声明格式为:"></a>c++语言的变量声明格式为:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myVariable = <span class="number">42</span>;</span><br><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11 引入 auto 用来让编译器根据上下文自动推导变量类型的</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="comment">//这将声明一个变量 x，并将其类型自动推导为 int</span></span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值</strong>， <strong>常量的值必须在编译时确定</strong></p><h4 id="go："><a href="#go：" class="headerlink" title="go："></a>go：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量的声明和变量声明非常类似，只是把`var`换成了`const`，常量在定义的时候必须赋值</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">) </span><br><span class="line"><span class="comment">//上面示例中，常量n1、n2、n3的值都是100。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//iota是go语言的常量计数器，只能在常量的表达式中使用 --------定义枚举时很有用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">n3        <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h4 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python 没有内置的常量类型，通常使用全大写字母来表示常量，但实际上它们仍然是变量，只是惯例上不会在程序中改变它们的值</span></span><br><span class="line"></span><br><span class="line">MY_CONSTANT = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以通过 enum 或者 class 来模拟常量</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyConstants</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    MY_CONSTANT = <span class="number">3.14</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyConstants</span>:</span><br><span class="line">    MY_CONSTANT = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 #define 来定义常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_CONSTANT 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是，使用 #define 宏定义时，没有类型检查，容易引起错误，也不易于维护，不太推荐使用。在 C++11 引入了 constexpr 关键字，可以用来定义常量表达式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> MY_CONSTANT = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 const 来定义常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> MY_CONSTANT = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 C++ 中，可以使用 enum 来定义常量。</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyConstants</span> &#123;</span><br><span class="line">    MY_CONSTANT = <span class="number">3.14</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> 和 <span class="type">const</span> 都可以用来定义常量，但是有一些区别。</span><br><span class="line"></span><br><span class="line"><span class="comment">//const 定义的常量可以是编译时常量或运行时常量，而 constexpr 定义的常量必须是编译时常量</span></span><br><span class="line"><span class="comment">//constexpr 可以提高代码的性能和安全性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//constexpr 可以用于函数、类的成员函数以及构造函数，而 const 只能用于变量.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 在编译期间求值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * <span class="built_in">factorial</span>(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是一个使用编译时常量的例子，定义了一个 constexpr 常量 k，在编译期间就能计算出其值：</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="number">10</span>; <span class="comment">// 编译时常量</span></span><br><span class="line"><span class="type">int</span> arr[k]; <span class="comment">// 可以用 k 定义数组大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是一个使用运行时常量的例子，定义了一个 const 常量 n，需要在运行时分配内存：</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">100</span>; <span class="comment">// 运行时常量</span></span><br><span class="line"><span class="type">int</span> arr[n]; <span class="comment">// 需要在运行时分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于类的成员函数和构造函数，constexpr 表示函数可以在编译期间被计算，而 const 表示函数不会修改类的成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> : x_(x), y_(y) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x_; &#125; <span class="comment">// const 表示不会修改类的成员变量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> y_; &#125; <span class="comment">// const 表示不会修改类的成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="type">int</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 编译时计算 Point 对象的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> 变量模板</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> area = pi&lt;<span class="type">double</span>&gt; * r * r; <span class="comment">// 计算圆的面积</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p><strong>全局变量定义在函数外部</strong>，<strong>可以在程序的任何地方访问，而局部变量定义在函数内部，只能在函数内部访问。</strong></p><p>go:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量需要显式地使用 var 关键字来声明，而局部变量则可以使用简短声明（short variable declaration）的方式来声明</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalVar = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    localVar := <span class="number">20</span></span><br><span class="line">    fmt.Println(globalVar)</span><br><span class="line">    fmt.Println(localVar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">global_var = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>():</span><br><span class="line">    local_var = <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(global_var)</span><br><span class="line">    <span class="built_in">print</span>(local_var)</span><br><span class="line">    </span><br><span class="line">my_func()   <span class="comment"># 输出：10 20</span></span><br><span class="line"><span class="comment">#如果你需要在函数内部使用全局变量，你可以使用 global 关键字来显式地声明一个变量为全局变量</span></span><br></pre></td></tr></table></figure><p>c++</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++ 中有显式的全局变量和局部变量的概念，你可以在函数内部或外部使用 int、double 等关键字来声明一个变量。如果你在函数内部声明一个变量，它将被视为局部变量，而如果你在函数外部声明一个变量，它将被视为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; globalVar &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; localVar &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">my_func</span>();  <span class="comment">// 输出：10 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h2><h4 id="go"><a href="#go" class="headerlink" title="go"></a>go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、<span class="keyword">map</span>、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 整形</span><br><span class="line">分为以下两个大类： 按长度分为：<span class="type">int8</span>、<span class="type">int16</span>、<span class="type">int32</span>、<span class="type">int64</span> 对应的无符号整型：<span class="type">uint8</span>、<span class="type">uint16</span>、<span class="type">uint32</span>、<span class="type">uint64</span></span><br><span class="line">其中，<span class="type">uint8</span>就是我们熟知的<span class="type">byte</span>型，<span class="type">int16</span>对应C语言中的short型，<span class="type">int64</span>对应C语言中的long型</span><br><span class="line"></span><br><span class="line"><span class="type">uint</span><span class="number">32</span>位操作系统上就是<span class="type">uint32</span>，<span class="number">64</span>位操作系统上就是<span class="type">uint64</span></span><br><span class="line"><span class="type">int</span><span class="number">32</span>位操作系统上就是<span class="type">int32</span>，<span class="number">64</span>位操作系统上就是<span class="type">int64</span></span><br><span class="line"><span class="type">uintptr</span>无符号整型，用于存放一个指针</span><br><span class="line"></span><br><span class="line">而且还允许我们用 _ 来分隔数字，比如说： v := <span class="number">123</span>_456 表示 v 的值等于 <span class="number">123456</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 浮点型</span><br><span class="line"><span class="type">float32</span>和<span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 复数</span><br><span class="line"><span class="type">complex64</span>和<span class="type">complex128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 <span class="type">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line"><span class="type">complex64</span>的实部和虚部为<span class="number">32</span>位，<span class="type">complex128</span>的实部和虚部为<span class="number">64</span>位。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 布尔值 <span class="type">bool</span></span><br><span class="line">布尔类型变量的默认值为<span class="literal">false</span>。</span><br><span class="line">Go 语言中不允许将整型强制转换为布尔型.</span><br><span class="line">布尔型无法参与数值运算，也无法与其他类型进行转换。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> 字符串 </span><br><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br><span class="line">Go语言中要定义一个多行字符串时，就必须使用反引号字符：</span><br><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(str)求长度</span><br><span class="line">+或fmt.Sprintf拼接字符串</span><br><span class="line">strings.Split分割</span><br><span class="line">strings.contains判断是否包含</span><br><span class="line">strings.HasPrefix,strings.HasSuffix前缀/后缀判断</span><br><span class="line">strings.Index(),strings.LastIndex()子串出现的位置</span><br><span class="line">strings.Join(a[]<span class="type">string</span>, sep <span class="type">string</span>)join操作</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="type">byte</span>和<span class="type">rune</span>类型</span><br><span class="line">组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="type">rune</span>类型实际是一个<span class="type">int32</span></span><br><span class="line"></span><br><span class="line">修改字符串</span><br><span class="line">要修改字符串，需要先将其转换成[]<span class="type">rune</span>或[]<span class="type">byte</span>，完成后再转换为<span class="type">string</span>。无论哪种转换，都会重新分配内存，并复制字节数组。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line">byteS1 := []<span class="type">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">runeS2 := []<span class="type">rune</span>(s2)</span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(runeS2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T(表达式) v类型转换</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在Python中常见的数据类型有以下<span class="number">8</span>个类型，分别是：<span class="built_in">int</span>，整数类型（整形）、<span class="built_in">float</span>，浮点类型（浮点型）、<span class="built_in">bool</span>，布尔类型、<span class="built_in">str</span>，字符串类型、<span class="built_in">list</span>，列表类型、<span class="built_in">tuple</span>，元组类型、<span class="built_in">dict</span>，字典类型、<span class="built_in">set</span>，集合类型</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="built_in">int</span></span><br><span class="line">Python 中的整数没有长度限制，不像其他编程语言有 <span class="built_in">int</span>，smallint，short，long，longint，long 等</span><br><span class="line"></span><br><span class="line">十进制就不说了，正常的写法</span><br><span class="line">十六进制写法：加前缀 0x，出现 <span class="number">0</span>-<span class="number">9</span> 和 A-F 的数字和字母组合</span><br><span class="line">八进制写法：加前缀 0o，出现 <span class="number">0</span>-<span class="number">7</span> 数字组合</span><br><span class="line">二进制写法：加前缀 0b，只有 <span class="number">0</span> 和 <span class="number">1</span> 数字组合</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 浮点数 <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">a. 浮点数只能以十进制表示，不能加前缀，否则会报语法错误</span><br><span class="line">浮点数 有长度限制 边界值为：</span><br><span class="line"><span class="built_in">max</span>=<span class="number">1.7976931348623157e+308</span> <span class="built_in">min</span>=<span class="number">2.2250738585072014e-308</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 布尔值 <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">布尔值就是我们常说的逻辑，可以理解为对或错</span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> == <span class="number">100.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 复数 <span class="built_in">complex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 中的复数这样来表示： 1 + 1j  虚部为 1，仍不可省略</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">1</span> + <span class="number">2j</span>).real) <span class="comment"># 输出实部 float 类型</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">1</span> + <span class="number">2j</span>).imag) <span class="comment"># 输出虚部 float 类型</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> 字符串 <span class="built_in">str</span></span><br><span class="line">通俗来说，字符串就是字符组成的一串内容，Python 中用成对的单引号或双引号括起来，用三个单引号或双引号可以使字符串内容保持原样输出，可以包含回车等特殊字符，在 Python 中字符串是不可变对象</span><br><span class="line">Python 中用反斜杠 “\” 来转义字符</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> 列表 <span class="built_in">list</span></span><br><span class="line">ls = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ls:</span><br><span class="line">    <span class="built_in">print</span>(i) </span><br><span class="line"></span><br><span class="line">检查列表中是否存在某个元素</span><br><span class="line">使用 <span class="keyword">in</span> 关键字，返回值为布尔值   </span><br><span class="line"><span class="keyword">del</span> ls    </span><br></pre></td></tr></table></figure><h4 id="c-1"><a href="#c-1" class="headerlink" title="c++"></a>c++</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go python C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go vs C++ vs python 基本数据类型</title>
      <link href="/anxiangblog.github.io/2023/04/27/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/anxiangblog.github.io/2023/04/27/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h2 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h2><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</span><br><span class="line">其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型</span><br><span class="line"></span><br><span class="line">uint32位操作系统上就是uint32，64位操作系统上就是uint64</span><br><span class="line">int32位操作系统上就是int32，64位操作系统上就是int64</span><br><span class="line">uintptr无符号整型，用于存放一个指针</span><br><span class="line"></span><br><span class="line">而且还允许我们用 _ 来分隔数字，比如说： v := 123_456 表示 v 的值等于 123456。</span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float32和float64</span><br></pre></td></tr></table></figure><h3 id="布尔值-bool"><a href="#布尔值-bool" class="headerlink" title="布尔值 bool"></a>布尔值 bool</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">布尔类型变量的默认值为false。</span><br><span class="line">Go 语言中不允许将整型强制转换为布尔型.</span><br><span class="line">布尔型无法参与数值运算，也无法与其他类型进行转换。</span><br></pre></td></tr></table></figure><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">complex64和complex128</span><br><span class="line"></span><br><span class="line">var c1 complex64</span><br><span class="line">c1 = 1 + 2i</span><br><span class="line">var c2 complex128</span><br><span class="line">c2 = 2 + 3i</span><br><span class="line">complex64的实部和虚部为32位，complex128的实部和虚部为64位。</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 := &quot;hello&quot;</span><br><span class="line">s2 := &quot;你好&quot;</span><br><span class="line">Go语言中要定义一个多行字符串时，就必须使用反引号字符：</span><br><span class="line">s1 := `第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">`</span><br><span class="line">反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出</span><br><span class="line"></span><br><span class="line">len(str)求长度</span><br><span class="line">+或fmt.Sprintf拼接字符串</span><br><span class="line">strings.Split分割</span><br><span class="line">strings.contains判断是否包含</span><br><span class="line">strings.HasPrefix,strings.HasSuffix前缀/后缀判断</span><br><span class="line">strings.Index(),strings.LastIndex()子串出现的位置</span><br><span class="line">strings.Join(a[]string, sep string)join操作</span><br></pre></td></tr></table></figure><h3 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</span><br><span class="line">var a = &#x27;中&#x27;</span><br><span class="line">var b = &#x27;x&#x27;</span><br><span class="line">rune类型实际是一个int32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改字符串</span><br><span class="line">要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。</span><br><span class="line"></span><br><span class="line">func changeString() &#123;</span><br><span class="line">s1 := &quot;big&quot;</span><br><span class="line">// 强制类型转换</span><br><span class="line">byteS1 := []byte(s1)</span><br><span class="line">byteS1[0] = &#x27;p&#x27;</span><br><span class="line">fmt.Println(string(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := &quot;白萝卜&quot;</span><br><span class="line">runeS2 := []rune(s2)</span><br><span class="line">runeS2[0] = &#x27;红&#x27;</span><br><span class="line">fmt.Println(string(runeS2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指针类型（Pointer）"><a href="#指针类型（Pointer）" class="headerlink" title="指针类型（Pointer）"></a>指针类型（Pointer）</h3><p>在 Go 中，指针类型用于存储变量的内存地址。与 C 和 C++ 不同，Go 指针不能进行偏移和运算，因此它们更安全且更易于使用。指针类型以 <code>*</code> 开头，用于指定指针类型的底层类型。例如，<code>*int</code> 表示指向整数类型的指针。在 Go 中，通过 <code>&amp;</code> 运算符可以获取一个变量的内存地址，而通过 <code>*</code> 运算符可以获取指针所指向的变量的值，<strong>指针类型的零值为 <code>nil</code><strong>，表示指</strong>针不指向任何有效的内存地址</strong>。因此，在使用指针之前，应该先进行空指针检查</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x int = 42</span><br><span class="line">var ptr *int = &amp;x   // 获取 x 的地址，将其赋值给 ptr</span><br><span class="line">fmt.Println(*ptr)  // 输出指针所指向的变量的值，即 42</span><br></pre></td></tr></table></figure><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h3><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个长度为3元素类型为int的数组a   数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变</span><br><span class="line">var 数组变量名 [元素数量]T</span><br><span class="line">var a [3]int</span><br></pre></td></tr></table></figure><h4 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var testArray [3]int                        //数组会初始化为int类型的零值</span><br><span class="line">var numArray = [3]int&#123;1, 2&#125;                 //使用指定的初始值完成初始化</span><br><span class="line">var cityArray = [3]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125; //使用指定的初始值完成初始化</span><br><span class="line"></span><br><span class="line">一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度</span><br><span class="line">var testArray [3]int</span><br><span class="line">var numArray = [...]int&#123;1, 2&#125;</span><br><span class="line">var cityArray = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line"></span><br><span class="line">指定索引值的方式来初始化数组</span><br><span class="line">a := [...]int&#123;1: 1, 3: 5&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 方法1：for循环遍历</span><br><span class="line">for i := 0; i &lt; len(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法2：for range遍历</span><br><span class="line">for index, value := range a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二维数组</span><br><span class="line">a := [3][2]string&#123;</span><br><span class="line">&#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">&#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, v1 := range a &#123;</span><br><span class="line">for _, v2 := range v1 &#123;</span><br><span class="line">fmt.Printf(&quot;%s\t&quot;, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h4><p>数组是值类型，<strong>赋值和传参会复制整个数组</strong>。因此改变副本的值，不会改变本身的值。</p><ol><li>数组支持 “&#x3D;&#x3D;“、”!&#x3D;” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol><h3 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h3><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><h4 id="切片声明"><a href="#切片声明" class="headerlink" title="切片声明"></a>切片声明</h4><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><ol><li>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</li><li>切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）</li><li>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</li><li>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name []T</span><br><span class="line"></span><br><span class="line">简单切片表达式</span><br><span class="line">a := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">s := a[1:3]  // s := a[low:high]</span><br><span class="line">a[2:]  // 等同于 a[2:len(a)]</span><br><span class="line">a[:3]  // 等同于 a[0:3]</span><br><span class="line">a[:]   // 等同于 a[0:len(a)]</span><br><span class="line"></span><br><span class="line">完整切片表达式</span><br><span class="line">a[low : high : max]</span><br><span class="line">它会将得到的结果切片的容量cap设置为max-low</span><br></pre></td></tr></table></figure><h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make([]T, size, cap)</span><br></pre></td></tr></table></figure><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><h4 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">四维数组</span><br><span class="line">var Sites  [][][][]int</span><br><span class="line">for i := 0; i &lt; DataInfo.X; i++ &#123;</span><br><span class="line">var first [][][]int</span><br><span class="line">for j := 0; j &lt; DataInfo.Y; j++ &#123;</span><br><span class="line">var secend [][]int</span><br><span class="line">for k := 0; k &lt; DataInfo.Z; k++ &#123;</span><br><span class="line"></span><br><span class="line">third := make([]int, 2)</span><br><span class="line">secend = append(secend, third)</span><br><span class="line">&#125;</span><br><span class="line">first = append(first, secend)</span><br><span class="line">&#125;</span><br><span class="line">Sites = append(Sites, first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">切片遍历</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">append</span>()方法为切片添加元素</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">Go语言内建的<span class="built_in">copy</span>()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<span class="built_in">copy</span>()函数的使用格式如下：</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(destSlice, srcSlice []T) </span><br><span class="line"></span><br><span class="line">srcSlice: 数据来源切片</span><br><span class="line">destSlice: 目标切片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="map声明"><a href="#map声明" class="headerlink" title="map声明"></a>map声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br><span class="line"></span><br><span class="line">v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map操作"><a href="#map操作" class="headerlink" title="map操作"></a>map操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遍历</span><br><span class="line">for k, v := range scoreMap &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">遍历map时的元素顺序与添加键值对的顺序无关</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(map, key)</span><br><span class="line">delete(scoreMap, &quot;小明&quot;)//将小明:100从map中删除</span><br><span class="line"></span><br><span class="line">元素为map类型的切片</span><br><span class="line">var mapSlice = make([]map[string]string, 3)</span><br><span class="line">mapSlice[0][&quot;address&quot;] = &quot;沙河&quot;</span><br><span class="line"></span><br><span class="line">值为切片类型的map</span><br><span class="line">var sliceMap = make(map[string][]string, 3)</span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line">if !ok &#123;</span><br><span class="line">value = make([]string, 0, 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体Struct"><a href="#结构体Struct" class="headerlink" title="结构体Struct"></a>结构体Struct</h3><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p><p>Go语言中通过<code>struct</code>来实现面向对象。</p><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Go语言中并没有类的概念，而是使用结构体来实现类似的功能</span></span><br><span class="line"><span class="keyword">type</span> MyClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyClass)</span></span> setX(val <span class="type">int</span>) &#123;</span><br><span class="line">    m.x = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h4><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">city <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在定义一些临时数据结构等场景下还可以使用匿名结构体</span><br><span class="line"><span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="type">string</span>; Age <span class="type">int</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h4><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针,需要注意的是<strong>在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员</strong></p><h4 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h4><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;七米&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;七米&quot;, city:&quot;成都&quot;, age:30&#125;</span></span><br></pre></td></tr></table></figure><p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p><h4 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h4><p><strong>没有初始化的结构体，其成员变量都是对应其类型的零值。</strong><em><strong>结构体占用一块连续的内存.</strong></em>* <strong>空结构体是不占用空间的。</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用键值对初始化,,当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</span></span><br><span class="line">p5 := person&#123;</span><br><span class="line">name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用值的列表初始化</span></span><br><span class="line">p8 := &amp;person&#123;</span><br><span class="line"><span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line"><span class="string">&quot;北京&quot;</span>,</span><br><span class="line"><span class="number">28</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p9 := newPerson(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;沙河&quot;</span>, <span class="number">90</span>)</span><br></pre></td></tr></table></figure><h4 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h4><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><p>方法的定义格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">name: name,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="comment">//值类型的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针类型的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h5><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h4 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="type">string</span></span><br><span class="line">City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Gender  <span class="type">string</span></span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">City:     <span class="string">&quot;威海&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套匿名字段</span></span><br><span class="line">Address <span class="comment">//匿名字段</span></span><br><span class="line">user2.Address.Province = <span class="string">&quot;山东&quot;</span>    <span class="comment">// 匿名字段默认使用类型名作为字段名</span></span><br></pre></td></tr></table></figure><h4 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h4><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Feet    <span class="type">int8</span></span><br><span class="line">*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := &amp;Dog&#123;</span><br><span class="line">Feet: <span class="number">4</span>,</span><br><span class="line">Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h4><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）.</p><h4 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h4><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键&#x2F;值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//JSON序列化：结构体--&gt;JSON格式的字符串</span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line"></span><br><span class="line">//JSON反序列化：JSON格式的字符串--&gt;结构体</span><br><span class="line">err = json.Unmarshal([]byte(str), c1)</span><br></pre></td></tr></table></figure><h4 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h4><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`key1:<span class="string">&quot;value1&quot;</span> key2:<span class="string">&quot;value2&quot;</span>`</span><br></pre></td></tr></table></figure><p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">Gender <span class="type">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">name   <span class="type">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := Student&#123;</span><br><span class="line">ID:     <span class="number">1</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">name:   <span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体和方法补充知识点"><a href="#结构体和方法补充知识点" class="headerlink" title="结构体和方法补充知识点"></a>结构体和方法补充知识点</h4><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意.</p><p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p><h3 id="函数Func"><a href="#函数Func" class="headerlink" title="函数Func"></a>函数Func</h3><p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p><p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</strong></li><li><strong>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</strong></li><li><strong>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</strong></li><li><strong>函数体：实现指定功能的代码块。</strong></li><li><strong>函数的参数和返回值都是可选的</strong></li><li><strong>函数的参数中如果相邻变量的类型相同，则可以省略类型</strong></li></ul><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p><strong>可变参数是指函数的参数数量不固定</strong>。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p><p>注意：<strong>可变参数通常要作为函数的最后一个参数。</strong></p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p><p>返回值命名  函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p><p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 没必要返回[]int&#123;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h5><p>局部变量和全局变量重名，优先访问局部变量。</p><h5 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h5><p>定义函数类型</p><p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br><span class="line"></span><br><span class="line">fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br></pre></td></tr></table></figure><h5 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h5><p>函数可以作为参数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret2 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h5><p>函数也可以作为返回值：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err := errors.New(<span class="string">&quot;无法识别的操作符&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h5><p><strong>匿名函数多用于实现回调函数和闭包</strong>。</p><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自执行函数：匿名函数定义完加()直接执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>闭包指的是一个函数和与其相关的引用环境组合而成的实体</strong>。简单来说，<code>闭包=函数+引用环境</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = adder()</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br></pre></td></tr></table></figure><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</p><p>闭包进阶示例2：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffixFunc</span><span class="params">(suffix <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line"><span class="keyword">return</span> name + suffix</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jpgFunc := makeSuffixFunc(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">txtFunc := makeSuffixFunc(<span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">fmt.Println(jpgFunc(<span class="string">&quot;test&quot;</span>)) <span class="comment">//test.jpg</span></span><br><span class="line">fmt.Println(txtFunc(<span class="string">&quot;test&quot;</span>)) <span class="comment">//test.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例3：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base -= i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1, f2 := calc(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>)) <span class="comment">//11 9</span></span><br><span class="line">fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>)) <span class="comment">//12 8</span></span><br><span class="line">fmt.Println(f1(<span class="number">5</span>), f2(<span class="number">6</span>)) <span class="comment">//13 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p><h5 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h5><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">y := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">B <span class="number">10</span> <span class="number">2</span> <span class="number">12</span></span><br><span class="line">BB <span class="number">10</span> <span class="number">12</span> <span class="number">22</span></span><br><span class="line">AA <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="内置函数介绍"><a href="#内置函数介绍" class="headerlink" title="内置函数介绍"></a>内置函数介绍</h5><table><thead><tr><th align="center">内置函数</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">close</td><td align="center">主要用来关闭channel</td></tr><tr><td align="center">len</td><td align="center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td align="center">new</td><td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td align="center">make</td><td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td align="center">append</td><td align="center">用来追加元素到数组、slice中</td></tr><tr><td align="center">panic和recover</td><td align="center">用来做错误处理</td></tr></tbody></table><h3 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h3><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节</p><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于之前章节中讲到的那些具体类型（字符串、切片、结构体等）更注重“我是谁”，接口类型更注重“我能做什么”的问题。接口类型就像是一种约定——概括了一种类型应该具备哪些方法，在Go语言中提倡使用面向接口的编程方式实现解耦。</p><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口类型名：Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有关闭操作的接口叫<code>closer</code>等。接口名最好要能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><h4 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h4><p>接口就是规定了一个<strong>需要实现的方法列表</strong>，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口。</p><p>我们定义的<code>Singer</code>接口类型，它包含一个<code>Sing</code>方法。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singer 接口</span></span><br><span class="line"><span class="keyword">type</span> Singer <span class="keyword">interface</span> &#123;</span><br><span class="line">Sing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个<code>Bird</code>结构体类型如下。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为<code>Singer</code>接口只包含一个<code>Sing</code>方法，所以只需要给<code>Bird</code>结构体添加一个<code>Sing</code>方法就可以满足<code>Singer</code>接口的要求。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sing Bird类型的Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Sing() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就称为<code>Bird</code>实现了<code>Singer</code>接口。</p><p>只要实现了<code>Say()</code>方法都能当成<code>Sayer</code>类型的变量来处理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Sayer interface &#123;</span><br><span class="line">    Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MakeHungry 饿肚子了...</span><br><span class="line">func MakeHungry(s Sayer) &#123;</span><br><span class="line">s.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c cat</span><br><span class="line">MakeHungry(c)</span><br><span class="line">var d dog</span><br><span class="line">MakeHungry(d)</span><br></pre></td></tr></table></figure><p>Go语言中为了解决类似上面的问题引入了接口的概念，接口类型区别于我们之前章节中介绍的那些具体类型，让我们专注于该类型提供的方法，而不是类型本身。使用接口类型通常能够让我们写出更加通用和灵活的代码</p><h4 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h4><p>只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。</p><p>我们可以将具体的支付方式抽象为一个名为<code>Payer</code>的接口类型，即任何实现了<code>Pay</code>方法的都可以称为<code>Payer</code>类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Payer 包含支付方法的接口类型</span></span><br><span class="line"><span class="keyword">type</span> Payer <span class="keyword">interface</span> &#123;</span><br><span class="line">Pay(<span class="type">int64</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ZhiFuBao <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 支付宝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay 支付宝的支付方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *ZhiFuBao)</span></span> Pay(amount <span class="type">int64</span>) &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;使用支付宝付款：%.2f元。\n&quot;</span>, <span class="type">float64</span>(amount/<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WeChat <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 微信</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay 微信的支付方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WeChat)</span></span> Pay(amount <span class="type">int64</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;使用微信付款：%.2f元。\n&quot;</span>, <span class="type">float64</span>(amount/<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Checkout</span><span class="params">(obj *Payer)</span></span> &#123;</span><br><span class="line"><span class="comment">// 支付100元</span></span><br><span class="line">obj.Pay(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Checkout(&amp;ZhiFuBao&#123;&#125;) <span class="comment">// 之前调用支付宝支付</span></span><br><span class="line"></span><br><span class="line">Checkout(&amp;WeChat&#123;&#125;) <span class="comment">// 现在支持使用微信支付</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x Sayer // 声明一个Sayer类型的变量x</span><br><span class="line">a := Cat&#123;&#125;  // 声明一个Cat类型变量a</span><br><span class="line">b := Dog&#123;&#125;  // 声明一个Dog类型变量b</span><br><span class="line">x = a       // 可以把Cat类型变量直接赋值给x</span><br><span class="line">x.Say()     // 喵喵喵</span><br><span class="line">x = b       // 可以把Dog类型变量直接赋值给x</span><br><span class="line">x.Say()     // 汪汪汪</span><br></pre></td></tr></table></figure><h4 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Mover 定义一个接口类型</span><br><span class="line">type Mover interface &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Dog 狗结构体类型</span><br><span class="line">type Dog struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">//值接收者实现接口</span><br><span class="line">// Move 使用值接收者定义Move方法实现Mover接口</span><br><span class="line">func (d Dog) Move() &#123;</span><br><span class="line">fmt.Println(&quot;狗会动&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指针接收者实现接口</span><br><span class="line"></span><br><span class="line">// Cat 猫结构体类型</span><br><span class="line">type Cat struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Move 使用指针接收者定义Move方法实现Mover接口</span><br><span class="line">func (c *Cat) Move() &#123;</span><br><span class="line">fmt.Println(&quot;猫会动&quot;)</span><br><span class="line">&#125;</span><br><span class="line">ar c1 = &amp;Cat&#123;&#125; // c1是*Cat类型</span><br><span class="line">x = c1          // 可以将c1当成Mover类型</span><br><span class="line">x.Move()</span><br><span class="line"></span><br><span class="line">由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是我们并不总是能对一个值求址，所以对于指针接收者实现的接口要额外注意</span><br></pre></td></tr></table></figure><h4 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h4><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。我们完全可以分别定义<code>Sayer</code>接口和<code>Mover</code>接口，具体代码示例如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog既可以实现Sayer接口，也可以实现Mover接口。</span></span><br><span class="line"><span class="comment">//同一个类型实现不同的接口互相不影响使用。</span></span><br><span class="line"><span class="keyword">var</span> d = Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Sayer = d</span><br><span class="line"><span class="keyword">var</span> m Mover = d</span><br><span class="line"></span><br><span class="line">s.Say()  <span class="comment">// 对Sayer类型调用Say方法</span></span><br><span class="line">m.Move() <span class="comment">// 对Mover类型调用Move方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WashingMachine 洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">wash()</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干器</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> dry() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">dryer <span class="comment">//嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span></span> wash() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h4><p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库<code>io</code>源码中就有很多接口之间互相组合的示例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/io/io.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p><p>接口也可以作为结构体的一个字段，我们来看一段Go标准库<code>sort</code>源码中的示例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sort/sort.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface 定义通过索引对元素排序的接口类型</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse 结构体中嵌入了Interface接口</span></span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中还有一个需要注意的地方是<code>reverse</code>结构体本身是不可导出的（结构体类型名称首字母小写），<code>sort.go</code>中通过定义一个可导出的<code>Reverse</code>函数来让使用者创建<code>reverse</code>结构体实例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span></span> Interface &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的目的是保证得到的<code>reverse</code>结构体中的<code>Interface</code>属性一定不为<code>nil</code>，否者<code>r.Interface.Less(j, i)</code>就会出现空指针panic。</p><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 不包含任何方法的空接口类型</span></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 狗结构体</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Any</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;你好&quot;</span> <span class="comment">// 字符串型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="number">100</span> <span class="comment">// int型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = Dog&#123;&#125; <span class="comment">// 结构体类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们在使用空接口类型时不必使用<code>type</code>关键字声明，可以像下面的代码一样直接使用<code>interface&#123;&#125;</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 声明一个空接口类型变量x</span></span><br></pre></td></tr></table></figure><ol><li>空接口作为函数的参数   <code>func show(a interface&#123;&#125;)</code></li><li>空接口作为map的值 <code>var studentInfo = make(map[string]interface&#123;&#125;)</code></li></ol><h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<strong>值</strong>之外，还需要记录这个值属于的<strong>类型</strong>。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的<code>动态类型</code>和<code>动态值</code></p><table><thead><tr><th>类型type</th><th>nil</th></tr></thead><tbody><tr><td>值 value</td><td>nil</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;        <span class="keyword">type</span>  = *dog       value = 旺财</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *Car</span><br><span class="line">m = c                         <span class="keyword">type</span>  = *car      value = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</span></span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>我们可以借助标准库<code>fmt</code>包的格式化打印获取到接口值的动态类型 ,而<code>fmt</code>包内部其实是使用反射的机制在程序运行时获取到动态类型的名称</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m Mover</span><br><span class="line"></span><br><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, m) <span class="comment">// *main.Dog</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">new</span>(Car)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, m) <span class="comment">// *main.Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。</span></span><br><span class="line">x.(T)</span><br><span class="line"></span><br><span class="line">x：表示接口类型的变量</span><br><span class="line">T：表示断言x可能是的类型。</span><br><span class="line"></span><br><span class="line">v, ok := n.(*Dog)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v := x.(<span class="keyword">type</span>)</span><br></pre></td></tr></table></figure><h3 id="Error-接口"><a href="#Error-接口" class="headerlink" title="Error 接口"></a>Error 接口</h3><p>Go 语言中把错误当成一种特殊的值来处理，不支持其他语言中使用<code>try/catch</code>捕获异常的方式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>error 是一个接口类型，默认零值为<code>nil</code>。所以我们通常将调用函数返回的错误与<code>nil</code>进行比较，以此来判断函数是否返回错误.</p><h4 id="创建错误"><a href="#创建错误" class="headerlink" title="创建错误"></a>创建错误</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">errors.New(<span class="string">&quot;无效的id&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Errorf(<span class="string">&quot;查询数据库失败，err:%v&quot;</span>, err)</span><br></pre></td></tr></table></figure><h4 id="错误结构体类型"><a href="#错误结构体类型" class="headerlink" title="错误结构体类型"></a>错误结构体类型</h4><p>此外我们还可以自己定义结构体类型，实现&#96;&#96;error&#96;接口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpError 自定义结构体类型</span></span><br><span class="line"><span class="keyword">type</span> OpError <span class="keyword">struct</span> &#123;</span><br><span class="line">Op <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error OpError 类型实现error接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *OpError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;无权执行%s操作&quot;</span>, e.Op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h5 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h5><p>使用 <code>new</code> 和 <code>make</code> 可以创建新的对象或数据结构</p><p><code>new</code> 函数用于分配一块新的内存，并将其初始化为零值，返回一个指向这块内存的指针。可以用于任何数据类型，但是并没有给这块内存赋值，因此在使用前需要进行赋值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明一个指向 int 类型的指针</span><br><span class="line">var p *int</span><br><span class="line">p = new(int)  // 分配一块新的内存，并将其初始化为 0，p 指向这块内存</span><br><span class="line">*p = 123      // 给这块内存赋值</span><br></pre></td></tr></table></figure><p><code>make</code> 函数则用于分配并初始化一个引用类型的对象（如 <code>slice</code>、<code>map</code>、<code>channel</code>）。返回的是一个该类型的对象而非指针，因为这些对象本身就是引用类型，即指向某个底层数据结构的指针。<code>make</code> 函数会为这些对象分配内存，初始化其内部字段，最后返回该对象。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为 5 的 int 类型切片，初始值为 0</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个容量为 10 的 int 类型切片，长度为 2，初始值为 0</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 map，初始化为空</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 channel，容量为 10</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><ol><li>二者都是用来做内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>在Python中常见的数据类型有以下8个类型，分别是：int，整数类型（整形）、float，浮点类型（浮点型）、bool，布尔类型、str，字符串类型、list，列表类型、tuple，元组类型、dict，字典类型、set，集合类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  int</span><br><span class="line">Python 中的整数没有长度限制，不像其他编程语言有 int，smallint，short，long，longint，long 等</span><br><span class="line"></span><br><span class="line">十进制就不说了，正常的写法</span><br><span class="line">十六进制写法：加前缀 0x，出现 0-9 和 A-F 的数字和字母组合</span><br><span class="line">八进制写法：加前缀 0o，出现 0-7 数字组合</span><br><span class="line">二进制写法：加前缀 0b，只有 0 和 1 数字组合</span><br><span class="line"></span><br><span class="line">2 浮点数 float</span><br><span class="line"></span><br><span class="line">a. 浮点数只能以十进制表示，不能加前缀，否则会报语法错误</span><br><span class="line">浮点数 有长度限制 边界值为：</span><br><span class="line">max=1.7976931348623157e+308 min=2.2250738585072014e-308</span><br><span class="line"></span><br><span class="line">3 布尔值 bool</span><br><span class="line"></span><br><span class="line">布尔值就是我们常说的逻辑，可以理解为对或错</span><br><span class="line">print(100 == 100.0)</span><br><span class="line"></span><br><span class="line">4 复数 complex</span><br><span class="line"></span><br><span class="line"># Python 中的复数这样来表示： 1 + 1j  虚部为 1，仍不可省略</span><br><span class="line">print((1 + 2j).real) # 输出实部 float 类型</span><br><span class="line">print((1 + 2j).imag) # 输出虚部 float 类型</span><br><span class="line"></span><br><span class="line">5 字符串 str</span><br><span class="line">通俗来说，字符串就是字符组成的一串内容，Python 中用成对的单引号或双引号括起来，用三个单引号或双引号可以使字符串内容保持原样输出，可以包含回车等特殊字符，在 Python 中字符串是不可变对象</span><br><span class="line">Python 中用反斜杠 “\” 来转义字符</span><br><span class="line"></span><br><span class="line">6 列表 list</span><br><span class="line">ls = [1, 2, 3, 4, &#x27;a&#x27;, &#x27;b&#x27;, [8, 5, 7]]</span><br><span class="line">for i in ls:</span><br><span class="line">    print(i) </span><br><span class="line"></span><br><span class="line">检查列表中是否存在某个元素</span><br><span class="line">使用 in 关键字，返回值为布尔值   </span><br><span class="line">del ls    </span><br></pre></td></tr></table></figure><h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line">    x = 0</span><br><span class="line">    def setX(self, val):</span><br><span class="line">        self.x = val</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="c-类型"><a href="#c-类型" class="headerlink" title="c++ 类型"></a>c++ 类型</h2><h4 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef type newname; </span><br></pre></td></tr></table></figure><p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int feet;</span><br></pre></td></tr></table></figure><p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feet distance;</span><br></pre></td></tr></table></figure><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>: 整数类型，通常为 <span class="number">32</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">31</span> 到 <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span></span><br><span class="line"><span class="type">short</span>: 短整数类型，通常为 <span class="number">16</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">15</span> 到 <span class="number">2</span>^<span class="number">15</span><span class="number">-1</span></span><br><span class="line"><span class="type">long</span>: 长整数类型，通常为 <span class="number">32</span> 位或 <span class="number">64</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">31</span> 到 <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span> 或 <span class="number">-2</span>^<span class="number">63</span> 到 <span class="number">2</span>^<span class="number">63</span><span class="number">-1</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>: 长长整数类型，通常为 <span class="number">64</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">63</span> 到 <span class="number">2</span>^<span class="number">63</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>: 无符号整数类型，通常为 <span class="number">32</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">32</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>: 无符号短整数类型，通常为 <span class="number">16</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">16</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>: 无符号长整数类型，通常为 <span class="number">32</span> 位或 <span class="number">64</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">32</span><span class="number">-1</span> 或 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">64</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>: 无符号长长整数类型，通常为 <span class="number">64</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">64</span><span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="浮点型-1"><a href="#浮点型-1" class="headerlink" title="浮点型"></a>浮点型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float: 单精度浮点型，通常为 32 位，可表示范围为 1.17549e-38 到 3.40282e+38，精度为 6 位小数</span><br><span class="line">double: 双精度浮点型，通常为 64 位，可表示范围为 2.22507e-308 到 1.79769e+308，精度为 15 位小数</span><br><span class="line">long double: 长双精度浮点型，通常为 80 位或 128 位，可表示范围和精度比 double 更高</span><br></pre></td></tr></table></figure><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char: 字符类型，通常为 8 位，可表示 ASCII 码的字符，例如 &#x27;A&#x27;、&#x27;B&#x27;、&#x27;C&#x27; 等</span><br><span class="line">char16_t: Unicode 字符类型，通常为 16 位</span><br><span class="line">char32_t: Unicode 字符类型，通常为 32 位</span><br><span class="line">wchar_t: 宽字符类型，通常为 16 位或 32 位，用于支持多语言字符集</span><br></pre></td></tr></table></figure><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool: 布尔类型，通常为 1 位，可表示 true 或 false</span><br></pre></td></tr></table></figure><h4 id="复数-1"><a href="#复数-1" class="headerlink" title="复数"></a>复数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 C++ 标准库中，复数类型是通过 std::complex 实现的，它定义在 &lt;complex&gt; 头文件中。std::complex 是一个模板类，它接受一个模板参数表示元素类型，可以是 float、double、long double 等</span><br><span class="line"></span><br><span class="line">#include &lt;complex&gt;</span><br><span class="line">std::complex&lt;double&gt; z1(1.0, 2.0); // 定义并初始化一个复数</span><br><span class="line"> // 访问实部和虚部</span><br><span class="line">    std::cout &lt;&lt; &quot;real(z1) = &quot; &lt;&lt; z1.real() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;imag(z1) = &quot; &lt;&lt; z1.imag() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="枚举类型（enum）"><a href="#枚举类型（enum）" class="headerlink" title="枚举类型（enum）"></a>枚举类型（enum）</h4><p>枚举类型是一种用户自定义的类型，用于定义一些有限的命名值。例如，我们可以使用枚举类型定义一些颜色：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Color c = Green;</span><br></pre></td></tr></table></figure><h4 id="指针类型（pointer）"><a href="#指针类型（pointer）" class="headerlink" title="指针类型（pointer）"></a>指针类型（pointer）</h4><p>指针类型是一种保存了内存地址的变量类型。指针变量通常用于动态内存分配、函数调用等方面。例如，下面的代码中，我们定义了一个指针变量 <code>p</code>，并将它指向一个整型变量 <code>x</code> 的地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int* p = &amp;x;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="引用（reference）"><a href="#引用（reference）" class="headerlink" title="引用（reference）"></a>引用（reference）</h4><p>在 C++ 中，引用是一种轻量级的指针，它提供了访问变量的另一种方式，它是某个变量的别名。引用通常用于函数参数、返回值和赋值。引用的语法使用 &amp; 符号。引用和指针类似，它们都提供了对变量的间接访问。但是，引用比指针更加安全，因为它们<strong>不会出现空指针</strong>的情况。在<strong>定义引用时必须初始化它</strong>，否则会出现编译错误。另外，引用一旦初始化后，就不能再指向其他变量，因此，引用可以被视为常量指针。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int&amp; b = a; // 声明 b 为 a 的引用</span><br><span class="line"></span><br><span class="line">b = 10; // 修改 b 也会修改 a</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; // 输出 10</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数组类型（array）"><a href="#数组类型（array）" class="headerlink" title="数组类型（array）"></a>数组类型（array）</h4><p>数组类型用于保存一组相同类型的数据，可以用下标访问数组中的元素。例如，下面的代码中，我们定义了一个数组 <code>a</code>，包含了三个整型元素：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[3] = &#123;1, 2, 3&#125;;</span><br><span class="line"></span><br><span class="line">int x = a[0];  // x = 1</span><br></pre></td></tr></table></figure><h4 id="结构体类型（struct）"><a href="#结构体类型（struct）" class="headerlink" title="结构体类型（struct）"></a>结构体类型（struct）</h4><p>结构体类型可以用于组合多个不同类型的变量，形成一个新的类型。例如，下面的代码中，我们定义了一个结构体 <code>Person</code>，包含了两个成员变量 <code>name</code> 和 <code>age</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p = &#123;&quot;Tom&quot;, 18&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="共用体类型（union）"><a href="#共用体类型（union）" class="headerlink" title="共用体类型（union）"></a>共用体类型（union）</h4><p>共用体类型可以让多个不同的变量共用一段内存空间，用于节省内存。例如，下面的代码中，我们定义了一个共用体 <code>Number</code>，可以表示一个整型数、一个浮点数或一个字符：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union Number &#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">    char c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="类类型（class）"><a href="#类类型（class）" class="headerlink" title="类类型（class）"></a>类类型（class）</h4><p>在C++中，类是一种用户自定义的数据类型，可以包含数据成员、成员函数等元素。使用class关键字定义类</p><p>类是一种用户自定义的数据类型，它可以封装数据和方法。类定义了一组相关的数据和方法，它们通常是一些有意义的操作的集合。C++中的类可以看作是一种数据类型的定义方式，类的实例化（对象）是具体的这种数据类型的实现.</p><p>类是面向对象编程（OOP）的基础，其中面向对象的思想主要体现在封装、继承和多态性方面。类可以使用访问修饰符（public、protected、private）来限制成员变量和成员函数的访问权限。类还可以包含构造函数、析构函数、静态成员、常量成员函数等特殊成员函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  private:</span><br><span class="line">    int age;</span><br><span class="line">  public:</span><br><span class="line">    void setAge(int a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.setAge(25);</span><br><span class="line">int age = p.getAge(); // age = 25</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shape</span><br><span class="line">public 成员：任何地方都可以访问，包括类的外部和派生类。</span><br><span class="line">protected 成员：只能在类内部和派生类中访问，不能在类外部访问。</span><br><span class="line">private 成员：只能在类内部访问，不能在类外部和派生类中访问。</span><br><span class="line"></span><br><span class="line">class Rectangle: public Shape&#123;&#125;</span><br><span class="line"></span><br><span class="line">public：派生类可以访问基类中的公共成员，但不能访问基类的私有成员和受保护成员。</span><br><span class="line">protected：派生类可以访问基类中的公共成员和受保护成员，但不能访问基类的私有成员。</span><br><span class="line">private：派生类不能直接访问基类中的任何成员，包括公共成员、受保护成员和私有成员。</span><br></pre></td></tr></table></figure><h4 id="模板类型"><a href="#模板类型" class="headerlink" title="模板类型"></a>模板类型</h4><p>模板类型（template）是 C++ 中非常重要的一种数据类型，它可以用来定义通用的数据类型或函数。模板类型分为类模板和函数模板两种。</p><h5 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h5><p>类模板可以用来定义通用的类，例如标准库中的容器类模板 std::vector 和 std::map，它们可以用来存储任何类型的数据，<strong>类模板是用来定义类的蓝图</strong>，<strong>其中某些成员的类型不确定</strong>，而是用类型参数来表示。类型参数可以在使用类模板时指定，从而让编译器根据指定的类型生成对应的类代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Stack &#123;</span><br><span class="line">private:</span><br><span class="line">    T* data;</span><br><span class="line">    int top;</span><br><span class="line">    int capacity;</span><br><span class="line">public:</span><br><span class="line">    Stack(int capacity) : data(new T[capacity]), top(-1), capacity(capacity) &#123;&#125;</span><br><span class="line">    ~Stack() &#123; delete[] data; &#125;</span><br><span class="line">    void push(const T&amp; value) &#123; data[++top] = value; &#125;</span><br><span class="line">    T pop() &#123; return data[top--]; &#125;</span><br><span class="line">    bool empty() const &#123; return top == -1; &#125;</span><br><span class="line">    bool full() const &#123; return top == capacity - 1; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stack&lt;int&gt; intStack(10);</span><br><span class="line">intStack.push(1);</span><br><span class="line">intStack.push(2);</span><br><span class="line">intStack.push(3);</span><br><span class="line">std::cout &lt;&lt; intStack.pop() &lt;&lt; std::endl; // 输出 3</span><br><span class="line"></span><br><span class="line">在这里，我们实例化了一个 Stack 类，并将其元素类型指定为 int，然后调用了它的 push 和 pop 函数。</span><br></pre></td></tr></table></figure><h5 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h5><p>函数模板可以用来定义通用的函数，例如标准库中的算法函数 std::sort 和 std::find，它们可以用来操作任何类型的数据，函数模板则是用来定义函数的蓝图，其中某些参数或返回值的类型不确定，而是用类型参数来表示，如下所示</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(T* first, T* last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3.14</span></span><br><span class="line"></span><br><span class="line">这是因为编译器根据参数的类型生成了对应的函数代码</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换是将一个数据类型的值转换为另一种数据类型的值。</p><p>C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。</p><h5 id="静态转换（Static-Cast）"><a href="#静态转换（Static-Cast）" class="headerlink" title="静态转换（Static Cast）"></a>静态转换（Static Cast）</h5><p>静态转换是将一种数据类型的值强制转换为另一种数据类型的值。</p><p>静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。</p><p>静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">float f = static_cast&lt;float&gt;(i); // 静态将int类型转换为float类型</span><br></pre></td></tr></table></figure><h5 id="动态转换（Dynamic-Cast）"><a href="#动态转换（Dynamic-Cast）" class="headerlink" title="动态转换（Dynamic Cast）"></a>动态转换（Dynamic Cast）</h5><p>动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = new Derived;</span><br><span class="line">Derived* ptr_derived = dynamic_cast&lt;Derived*&gt;(ptr_base); // 将基类指针转换为派生类指针</span><br></pre></td></tr></table></figure><h5 id="常量转换（Const-Cast）"><a href="#常量转换（Const-Cast）" class="headerlink" title="常量转换（Const Cast）"></a>常量转换（Const Cast）</h5><p>常量转换用于将 const 类型的对象转换为非 const 类型的对象。</p><p>常量转换只能用于转换掉 const 属性，不能改变对象的类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int i = 10;</span><br><span class="line">int&amp; r = const_cast&lt;int&amp;&gt;(i); // 常量转换，将const int转换为int</span><br></pre></td></tr></table></figure><h5 id="重新解释转换（Reinterpret-Cast）"><a href="#重新解释转换（Reinterpret-Cast）" class="headerlink" title="重新解释转换（Reinterpret Cast）"></a>重新解释转换（Reinterpret Cast）</h5><p>重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。</p><p>重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">float f = reinterpret_cast&lt;float&amp;&gt;(i); // 重新解释将int类型转换为float类型</span><br></pre></td></tr></table></figure><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><ol><li>多态性：C++ 支持静态多态和动态多态，静态多态通过函数重载和运算符重载实现，动态多态通过虚函数实现。</li><li>抽象类：C++ 中可以定义纯虚函数，一个类如果包含纯虚函数，该类就是抽象类，抽象类不能实例化对象，只能被其他类继承。</li><li>友元函数：C++ 中的友元函数可以访问类的私有成员，但不是类的成员函数，友元函数可以定义在类内或类外。</li><li>内联函数：C++ 中的内联函数在函数调用处直接展开，减少函数调用的开销，可以在函数前加 inline 关键字将其声明为内联函数。</li><li>类模板：C++ 中可以定义类模板，用来创建具有不同数据类型的类，类模板可以具有成员函数和成员变量。</li><li>构造函数和析构函数：C++ 中的构造函数用来初始化类的对象，析构函数用来清理对象所占用的资源，构造函数和析构函数都是特殊的成员函数，一个类可以有多个构造函数，但只能有一个析构函数。</li><li>拷贝构造函数和移动构造函数：C++ 中的拷贝构造函数用来复制一个对象到另一个对象，移动构造函数用来移动一个对象到另一个对象，移动构造函数可以更高效地将对象转移，避免了不必要的复制操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go python C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 单元测试</title>
      <link href="/anxiangblog.github.io/2023/04/27/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/anxiangblog.github.io/2023/04/27/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="go-test工具"><a href="#go-test工具" class="headerlink" title="go test工具"></a>go test工具</h2><p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p><p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p><p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p><table><thead><tr><th align="center">类型</th><th align="center">格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">测试函数</td><td align="center">函数名前缀为Test</td><td align="center">测试程序的一些逻辑行为是否正确</td></tr><tr><td align="center">基准函数</td><td align="center">函数名前缀为Benchmark</td><td align="center">测试函数的性能</td></tr><tr><td align="center">示例函数</td><td align="center">函数名前缀为Example</td><td align="center">为文档提供示例文档</td></tr></tbody></table><p><code>go test</code>命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><p>每个测试函数必须导入<code>testing</code>包，测试函数的基本格式（签名）如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试函数的名字必须以<code>Test</code>开头，可选的后缀名必须以大写字母开头，举几个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSum</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLog</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>其中参数<code>t</code>用于报告测试失败和附加的日志信息。 <code>testing.T</code>的拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Error(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Errorf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Fail()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> FailNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Failed() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Fatal(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Fatalf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Log(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Logf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Parallel()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Run(name <span class="type">string</span>, f <span class="function"><span class="keyword">func</span><span class="params">(t *T)</span></span>) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Skip(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> SkipNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Skipf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Skipped() <span class="type">bool</span></span><br></pre></td></tr></table></figure><h2 id="测试函数示例"><a href="#测试函数示例" class="headerlink" title="测试函数示例"></a>测试函数示例</h2><p>就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。</p><p>接下来，我们定义一个<code>split</code>的包，包中定义了一个<code>Split</code>函数，具体实现如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split/split.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="type">string</span>)</span></span> (result []<span class="type">string</span>) &#123;</span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="number">1</span>:]</span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前目录下，我们创建一个<code>split_test.go</code>的测试文件，并定义一个测试函数如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split/split_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 测试函数名必须以Test开头，必须接收一个*testing.T类型参数</span></span><br><span class="line">got := Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>)         <span class="comment">// 程序输出的结果</span></span><br><span class="line">want := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;    <span class="comment">// 期望的结果</span></span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123; <span class="comment">// 因为slice不能比较直接，借助反射包中的方法比较</span></span><br><span class="line">t.Errorf(<span class="string">&quot;expected:%v, got:%v&quot;</span>, want, got) <span class="comment">// 测试失败输出错误提示</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>split</code>包路径下，执行<code>go test</code>命令，可以看到输出结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><h2 id="测试组"><a href="#测试组" class="headerlink" title="测试组"></a>测试组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 定义一个测试用例类型</span></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">input <span class="type">string</span></span><br><span class="line">sep   <span class="type">string</span></span><br><span class="line">want  []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个存储测试用例的切片</span></span><br><span class="line">tests := []test&#123;</span><br><span class="line">&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">&quot;沙河有沙又有河&quot;</span>, sep: <span class="string">&quot;沙&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历切片，逐一执行测试用例</span></span><br><span class="line"><span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;expected:%v, got:%v&quot;</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p><code>go test -cover</code>来查看测试覆盖率</p><h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h1><p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基准测试以<code>Benchmark</code>为前缀，需要一个<code>*testing.B</code>类型的参数b，基准测试必须要执行<code>b.N</code>次，这样的测试才有对照性，<code>b.N</code>的值是系统根据实际情况去调整的，从而保证测试的稳定性。 <code>testing.B</code>拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Error(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Errorf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fail()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> FailNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Failed() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fatal(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fatalf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Log(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Logf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> ReportAllocs()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> ResetTimer()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> Run(name <span class="type">string</span>, f <span class="function"><span class="keyword">func</span><span class="params">(b *B)</span></span>) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> RunParallel(body <span class="function"><span class="keyword">func</span><span class="params">(*PB)</span></span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> SetBytes(n <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> SetParallelism(p <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skip(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> SkipNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skipf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skipped() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> StartTimer()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> StopTimer()</span><br></pre></td></tr></table></figure><h2 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a>基准测试示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Split(<span class="string">&quot;沙河有沙又有河&quot;</span>, <span class="string">&quot;沙&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基准测试并不会默认执行，需要增加<code>-bench</code>参数，所以我们通过执行<code>go test -bench=Split</code>命令执行基准测试，输出结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=Split</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8        10000000               203 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.255s</span><br></pre></td></tr></table></figure><h2 id="性能比较函数"><a href="#性能比较函数" class="headerlink" title="性能比较函数"></a>性能比较函数</h2><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p><h2 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h2><p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p><p><code>RunParallel</code>会创建出多个<code>goroutine</code>，并将<code>b.N</code>分配给这些<code>goroutine</code>执行， 其中<code>goroutine</code>数量的默认值为<code>GOMAXPROCS</code>。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在<code>RunParallel</code>之前调用<code>SetParallelism</code> 。<code>RunParallel</code>通常会与<code>-cpu</code>标志一同使用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplitParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// b.SetParallelism(1) // 设置使用的CPU数</span></span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">Split(<span class="string">&quot;沙河有沙又有河&quot;</span>, <span class="string">&quot;沙&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下基准测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8                10000000               131 ns/op</span><br><span class="line">BenchmarkSplitParallel-8        50000000                36.1 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       3.308s</span><br></pre></td></tr></table></figure><p>还可以通过在测试命令后添加<code>-cpu</code>参数如<code>go test -bench=. -cpu 1</code>来指定使用的CPU数量。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go vs C++ vs python 反射</title>
      <link href="/anxiangblog.github.io/2023/04/27/%E5%8F%8D%E5%B0%84/"/>
      <url>/anxiangblog.github.io/2023/04/27/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="go"><a href="#go" class="headerlink" title="go"></a>go</h1><p>Go语言中的变量是分为两部分的:</p><ul><li>类型信息：预先定义好的元信息。</li><li>值信息：程序运行过程中可动态变化的。</li></ul><h3 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h3><p>反射是指在程序运行期间对程序本身进行访问和修改的能力。<strong>程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息</strong>。</p><p>支持反射的语言可以在程序编译期间将<strong>变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改它们。</strong></p><p>Go程序在运行期间使用reflect包访问程序的反射信息。</p><p>在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息</p><h3 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h3><p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p><h4 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%v\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">reflectType(a) <span class="comment">// type:float32</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">reflectType(b) <span class="comment">// type:int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="type-name和type-kind"><a href="#type-name和type-kind" class="headerlink" title="type name和type kind"></a>type name和type kind</h5><p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">float32</span> <span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">reflectType(a) <span class="comment">// type: kind:ptr</span></span><br><span class="line">reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span>&#123; title <span class="type">string</span> &#125;</span><br><span class="line"><span class="keyword">var</span> d = person&#123;</span><br><span class="line">name: <span class="string">&quot;沙河小王子&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e = book&#123;title: <span class="string">&quot;《跟小王子学Go语言》&quot;</span>&#125;</span><br><span class="line">reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">reflectType(e) <span class="comment">// type:book kind:struct</span></span><br></pre></td></tr></table></figure><p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回<code>空</code>。</p><p>在<code>reflect</code>包中定义的Kind类型如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span>  <span class="comment">// 非法类型</span></span><br><span class="line">    Bool                 <span class="comment">// 布尔型</span></span><br><span class="line">    Int                  <span class="comment">// 有符号整型</span></span><br><span class="line">    Int8                 <span class="comment">// 有符号8位整型</span></span><br><span class="line">    Int16                <span class="comment">// 有符号16位整型</span></span><br><span class="line">    Int32                <span class="comment">// 有符号32位整型</span></span><br><span class="line">    Int64                <span class="comment">// 有符号64位整型</span></span><br><span class="line">    Uint                 <span class="comment">// 无符号整型</span></span><br><span class="line">    Uint8                <span class="comment">// 无符号8位整型</span></span><br><span class="line">    Uint16               <span class="comment">// 无符号16位整型</span></span><br><span class="line">    Uint32               <span class="comment">// 无符号32位整型</span></span><br><span class="line">    Uint64               <span class="comment">// 无符号64位整型</span></span><br><span class="line">    Uintptr              <span class="comment">// 指针</span></span><br><span class="line">    Float32              <span class="comment">// 单精度浮点数</span></span><br><span class="line">    Float64              <span class="comment">// 双精度浮点数</span></span><br><span class="line">    Complex64            <span class="comment">// 64位复数类型</span></span><br><span class="line">    Complex128           <span class="comment">// 128位复数类型</span></span><br><span class="line">    Array                <span class="comment">// 数组</span></span><br><span class="line">    Chan                 <span class="comment">// 通道</span></span><br><span class="line">    Func                 <span class="comment">// 函数</span></span><br><span class="line">    Interface            <span class="comment">// 接口</span></span><br><span class="line">    Map                  <span class="comment">// 映射</span></span><br><span class="line">    Ptr                  <span class="comment">// 指针</span></span><br><span class="line">    Slice                <span class="comment">// 切片</span></span><br><span class="line">    String               <span class="comment">// 字符串</span></span><br><span class="line">    Struct               <span class="comment">// 结构体</span></span><br><span class="line">    UnsafePointer        <span class="comment">// 底层指针</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h4><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Interface() interface {}</td><td align="center">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td align="center">Int() int64</td><td align="center">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td align="center">Uint() uint64</td><td align="center">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td align="center">Float() float64</td><td align="center">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td align="center">Bool() bool</td><td align="center">将值以 bool 类型返回</td></tr><tr><td align="center">Bytes() []bytes</td><td align="center">将值以字节数组 []bytes 类型返回</td></tr><tr><td align="center">String() string</td><td align="center">将值以字符串类型返回</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure><h4 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h4><p>想要在函数中通过反射修改变量的值，<strong>需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值</strong>。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line"><span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">reflectSetValue2(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isNil-和isValid"><a href="#isNil-和isValid" class="headerlink" title="isNil()和isValid()"></a>isNil()和isValid()</h4><p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><p><strong><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">c := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">&quot;娜   扎&quot;</span>)).IsValid())</span><br></pre></td></tr></table></figure><h2 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h2><h3 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h3><table><thead><tr><th>ield(i int) StructField</th><th>根据索引，返回索引对应的结构体字段的信息。</th></tr></thead><tbody><tr><td>NumField() int</td><td>返回结构体成员字段数量。</td></tr><tr><td>FieldByName(name string) (StructField, bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td>FieldByIndex(index []int) StructField</td><td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td></tr><tr><td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td>根据传入的匹配函数匹配需要的字段。</td></tr><tr><td>NumMethod() int</td><td>返回该类型的方法集中方法的数目</td></tr><tr><td>Method(int) Method</td><td>返回该类型方法集中的第i个方法</td></tr><tr><td>MethodByName(string)(Method, bool)</td><td>根据方法名返回该类型方法集中的方法</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">field := t.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射是把双刃剑"><a href="#反射是把双刃剑" class="headerlink" title="反射是把双刃剑"></a>反射是把双刃剑</h2><p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p><ol><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li><li>大量使用反射的代码通常难以理解。</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li></ol><h1 id="python反射"><a href="#python反射" class="headerlink" title="python反射"></a>python反射</h1><p>在 Python 中，我们可以使用反射机制来查看和修改对象的属性和方法，包括动态获取对象的属性和方法列表、获取和修改对象的属性值、动态调用对象的方法等。Python 中的反射机制主要通过内置函数 <code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code>、<code>delattr()</code> 和 <code>vars()</code> 等实现。</p><ul><li><code>getattr()</code> 函数可以用于获取对象的属性或方法，如果属性或方法不存在，会抛出 <code>AttributeError</code> 异常。</li><li><code>setattr()</code> 函数可以用于设置对象的属性或方法，如果属性或方法不存在，会自动添加。</li><li><code>hasattr()</code> 函数可以用于判断对象是否有指定的属性或方法，返回布尔值。</li><li><code>delattr()</code> 函数可以用于删除对象的属性或方法。</li><li><code>vars()</code> 函数可以返回对象的 <code>__dict__</code> 属性，也就是对象的属性和值组成的字典。</li><li><code>type(object)</code>: 返回对象的类型。</li><li><code>isinstance(object, classinfo)</code>: 判断对象是否为指定类型或其子类的实例。</li><li><code>issubclass(class, classinfo)</code>: 判断一个类是否为另一个类的子类。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello, my name is <span class="subst">&#123;self.name&#125;</span>. I&#x27;m <span class="subst">&#123;self.age&#125;</span> years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态获取对象的属性列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(person))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态获取对象的属性值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(person, <span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(person, <span class="string">&quot;age&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(person, <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;Unknown&quot;</span>)) <span class="comment"># 第三个参数为默认值，避免属性不存在时抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态调用对象的方法</span></span><br><span class="line">method_name = <span class="string">&quot;say_hello&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(person, method_name):</span><br><span class="line">    method = <span class="built_in">getattr</span>(person, method_name)</span><br><span class="line">    method()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态设置对象的属性</span></span><br><span class="line"><span class="built_in">setattr</span>(person, <span class="string">&quot;age&quot;</span>, <span class="number">26</span>)</span><br><span class="line"><span class="built_in">print</span>(person.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态添加对象的属性</span></span><br><span class="line"><span class="built_in">setattr</span>(person, <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;Female&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(person.gender)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除对象的属性</span></span><br><span class="line"><span class="built_in">delattr</span>(person, <span class="string">&quot;gender&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(person, <span class="string">&quot;gender&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="c-反射"><a href="#c-反射" class="headerlink" title="c++ 反射"></a>c++ 反射</h1><p>C++ 是一门静态语言，其并没有直接支持反射。C++ 可以通过元编程技术实现类似于反射的功能，比如使用模板元编程（TMP，Template Meta-Programming）技术。TMP 可以让程序在编译期间进行一些计算，从而达到运行期间反射的效果。</p><p>另外，C++11 开始支持了一种叫做 <code>type_traits</code> 的库，它提供了一些模板类型特性（Traits），可以在编译期间查询和操作类型的信息。通过这些模板类型特性，可以实现一些类似于反射的功能，比如查询类型是否具有某个成员函数、成员变量等信息。</p><p>虽然 C++ 并没有直接支持反射，但是通过 TMP 和 <code>type_traits</code> 库，可以实现类似于反射的功能。不过相比于动态语言，C++ 反射的实现较为复杂，需要更多的编码工作。</p><h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type_traits"></a><code>type_traits</code></h2><p><code>type_traits</code> 是 C++11 引入的一个头文件，它定义了一系列的类型特征（type traits），用于在编译时对类型进行分析和操作，从而更好地支持泛型编程。由于 C++ 是静态类型语言，编译器在编译阶段需要明确每个变量和函数的类型，因此使用 <code>type_traits</code> 可以在编译期间进行类型检查和操作，而不需要运行时判断，提高了代码的效率和可靠性。</p><p>它的作用有以下几个方面：</p><ol><li><strong>提供编译时对类型进行分析的功能，如判断一个类型是否为指针类型、是否为 const 类型等等。</strong></li><li><strong>提供一些转换类型的方法，如将一个类型转换为指针类型、将一个类型转换为 const 类型等等。</strong></li><li><strong>提供一些特定类型的方法，如获取一个类型的指针类型、获取一个类型的 const 类型等等。</strong></li><li><strong>支持模板元编程，即将模板作为参数，然后在编译时对模板进行处理，从而得到另一个模板。</strong></li></ol><p>下面是一些 <code>type_traits</code> 库中常用的类型特征：</p><ol><li><code>is_void</code>：判断一个类型是否为 <code>void</code>。</li><li><code>is_integral</code>：判断一个类型是否为整数类型，包括有符号整数、无符号整数和布尔类型。</li><li><code>is_floating_point</code>：判断一个类型是否为浮点数类型。</li><li><code>is_array</code>：判断一个类型是否为数组类型。</li><li><code>is_pointer</code>：判断一个类型是否为指针类型。</li><li><code>is_reference</code>：判断一个类型是否为引用类型。</li><li><code>is_const</code>：判断一个类型是否为 <code>const</code> 类型。</li><li><code>is_function</code>：判断一个类型是否为函数类型。</li><li><code>is_member_pointer</code>：判断一个类型是否为成员指针类型。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void check_type()</span><br><span class="line">&#123;</span><br><span class="line">    if(std::is_floating_point&lt;T&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; &quot;Type is float or double&quot; &lt;&lt; std::endl;</span><br><span class="line">    else</span><br><span class="line">        std::cout &lt;&lt; &quot;Type is not float or double&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    check_type&lt;int&gt;();   // Type is not float or double</span><br><span class="line">    check_type&lt;float&gt;(); // Type is float or double</span><br><span class="line">    check_type&lt;double&gt;();// Type is float or double</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>std::is_floating_point</code> 模板可以检查给定类型是否为浮点类型，如果是则返回 <code>true</code>，否则返回 <code>false</code>。在 <code>check_type</code> 函数中，我们可以使用 <code>if</code> 语句根据 <code>std::is_floating_point</code> 的返回值来判断类型是否为浮点类型。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go python C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LammpsNN安装</title>
      <link href="/anxiangblog.github.io/2023/04/23/lampnn/"/>
      <url>/anxiangblog.github.io/2023/04/23/lampnn/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="laspnn"><a href="#laspnn" class="headerlink" title="laspnn"></a>laspnn</h1><p>laspnn 安装需要intel com 和 Intelmpi，所以就学习安装一下</p><h2 id="部署oneapi-HPC版本"><a href="#部署oneapi-HPC版本" class="headerlink" title="部署oneapi HPC版本"></a>部署oneapi HPC版本</h2><p>记录一下部署<a href="https://so.csdn.net/so/search?q=oneapi&spm=1001.2101.3001.7020">oneapi</a> HPC版本的部署过程。<br>本次部署使用的是offline的方式，使用的是silent模式<br>我的操作系统版本是centos7.6</p><h3 id="offline脚本获取"><a href="#offline脚本获取" class="headerlink" title="offline脚本获取"></a>offline脚本获取</h3><p>直接从官网上获获取offline的安装脚本，offline的安装模式是最合适的。</p><p>官网地址<br>链接: <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/hpc-toolkit-download.html">https://www.intel.com/content/www/us/en/developer/tools/oneapi/hpc-toolkit-download.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://registrationcenter-download.intel.com/akdlm/irc_nas/18679/l_HPCKit_p_2022.3.0.8751_offline.sh</span><br><span class="line"></span><br><span class="line">安装模式：-a -s --eula accept</span><br><span class="line">安装路径：--install-dir /HPC/software/oneapi/2022.3.0.8751</span><br><span class="line"></span><br><span class="line">#创建部署路径</span><br><span class="line">mkdir -p /HPC/software/oneapi/2022.3.0.8751</span><br><span class="line"></span><br><span class="line">#开始部署</span><br><span class="line">sh l_HPCKit_p_2022.3.0.8751_offline.sh -a -s --eula accept  --action install  --install-dir /HPC/software/oneapi/2022.3.0.8751</span><br><span class="line">#等待部署完毕即可</span><br><span class="line"></span><br><span class="line">环境变量配置    </span><br><span class="line">export PATH=..../bin    lib   等</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装mkl"><a href="#安装mkl" class="headerlink" title="安装mkl"></a>安装mkl</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">和上面类似   </span><br><span class="line">安装模式：-a -s --eula accept</span><br><span class="line">安装路径：--install-dir</span><br><span class="line"></span><br><span class="line">完成后要配置环境变量</span><br></pre></td></tr></table></figure><h3 id="laspnn安装"><a href="#laspnn安装" class="headerlink" title="laspnn安装"></a>laspnn安装</h3><p>laspnn解压后有patch文件夹和Makefile文件 ，把patch文件下的拷贝到lammps&#x2F;src下，编辑SRC&#x2F;MAKE&#x2F;OPTRIONS&#x2F;下的makefile.intel_cpu ,拷贝 laspnn中Makefile文件到makefile.intel_cpu，src下make intel_cpu，就会生成可执行文件</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>口红和显卡</title>
      <link href="/anxiangblog.github.io/2023/04/21/%E5%8F%A3%E7%BA%A2%E5%92%8C%E6%98%BE%E5%8D%A1%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%8C%E5%93%88%E5%93%88%E5%93%88/"/>
      <url>/anxiangblog.github.io/2023/04/21/%E5%8F%A3%E7%BA%A2%E5%92%8C%E6%98%BE%E5%8D%A1%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%8C%E5%93%88%E5%93%88%E5%93%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><p>看到一个关于口红和显卡的对比，哈哈哈</p><p>6500XT       —》     卡姿兰</p><p>6600           —》      美宝莲 欧莱雅</p><p>3060ti        —》       mac</p><p>3070ti       —》        植村秀  nars</p><p>3080         —》        兰蔻   香奈儿 纪梵希  阿玛尼</p><p>3090ti      —》         圣罗兰  迪奥</p><p>4080        —-》        cpb   卢丹氏</p><p>4090       —-》         女王权杖萝卜丁</p>]]></content>
      
      
      <categories>
          
          <category> 娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elsarticle-num.bst 格式调整</title>
      <link href="/anxiangblog.github.io/2023/04/20/elsarticle-num.bst/"/>
      <url>/anxiangblog.github.io/2023/04/20/elsarticle-num.bst/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="elsarticle-num-bst"><a href="#elsarticle-num-bst" class="headerlink" title="elsarticle-num.bst"></a>elsarticle-num.bst</h1><h2 id="格式调整"><a href="#格式调整" class="headerlink" title="格式调整"></a>格式调整</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">输出文章   不想用可以注释掉</span><br><span class="line"></span><br><span class="line">FUNCTION &#123;article&#125;</span><br><span class="line">&#123;</span><br><span class="line">  output.bibitem        <span class="comment">% 输出文献条目开始</span></span><br><span class="line">  format.authors &quot;author&quot; output.check <span class="comment">% 输出作者</span></span><br><span class="line">  title empty<span class="built_in">$</span> &#x27;skip<span class="built_in">$</span> &#x27;setup.inlinelink if<span class="built_in">$</span> <span class="comment">% urlbst</span></span><br><span class="line">  format.title &quot;title&quot; output.check      <span class="comment">% 输出题目</span></span><br><span class="line">  crossref missing<span class="built_in">$</span>     <span class="comment">% 如果没有引用其他文献</span></span><br><span class="line">    &#123; format.journal    <span class="comment">% 输出期刊名称缩写</span></span><br><span class="line">      &quot;journal&quot; output.check</span><br><span class="line">      <span class="comment">% add.blank</span></span><br><span class="line">      before.all &#x27;output.state :=</span><br><span class="line">      format.vol.num.pages output <span class="comment">% 输出卷、号、页码</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123; format.article.crossref output.nonnull <span class="comment">% 如果引用了其他文献，则输出交叉引用的信息</span></span><br><span class="line">      format.pages output</span><br><span class="line">    &#125;</span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">  format.journal.pages  <span class="comment">% 输出期刊页码范围</span></span><br><span class="line">  format.note output     <span class="comment">% 输出附注信息</span></span><br><span class="line">  pages empty<span class="built_in">$</span>           <span class="comment">% 如果没有页码信息</span></span><br><span class="line">    &#123; format.date &quot;year&quot; output.check &#125; <span class="comment">% 输出年份</span></span><br><span class="line">    &#x27;skip<span class="built_in">$</span> </span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">  fin.entry              <span class="comment">% 文献条目结束</span></span><br><span class="line">  write.url              <span class="comment">% 输出网址信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个format都对应一个函数，比如 format.journal</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">journal 替换为简写的形式</span><br><span class="line">FUNCTION &#123;format.journal&#125;</span><br><span class="line">&#123; </span><br><span class="line">  journal empty<span class="built_in">$</span></span><br><span class="line">    &#123; &quot;&quot; &#125;</span><br><span class="line">    &#123; </span><br><span class="line">      journal &quot;Journal of Nuclear Materials&quot; = </span><br><span class="line">        &#123; &quot;J. Nucl. Mater.&quot; &#125;</span><br><span class="line">        &#123; journal &quot;Materials <span class="built_in">&amp;</span> Design&quot; = </span><br><span class="line">            &#123; &quot;MATER DESIGN.&quot; &#125;</span><br><span class="line">            &#123; journal &quot;Scripta Materialia&quot; = </span><br><span class="line">                &#123; &quot;Scripta Mater.&quot; &#125;</span><br><span class="line">                &#123; journal &quot;Physical Review B&quot; = </span><br><span class="line">                    &#123; &quot;Phys. Rev. B &quot; &#125;</span><br><span class="line">                    &#123; journal &#125;</span><br><span class="line">                  if<span class="built_in">$</span></span><br><span class="line">                &#125;</span><br><span class="line">              if<span class="built_in">$</span></span><br><span class="line">            &#125;</span><br><span class="line">          if<span class="built_in">$</span></span><br><span class="line">        &#125;</span><br><span class="line">      if<span class="built_in">$</span></span><br><span class="line">    &#125;</span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">format.vol.num.pages  输出卷 页码 等</span><br><span class="line"></span><br><span class="line">FUNCTION &#123;format.vol.num.pages&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">% volume field.or.null</span></span><br><span class="line">  &quot; &quot;</span><br><span class="line">  volume empty<span class="built_in">$</span></span><br><span class="line">    &#123; pop<span class="built_in">$</span> &quot;&quot; &#125;</span><br><span class="line">    &#123; volume * &#125;            //vol</span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">  number empty<span class="built_in">$</span></span><br><span class="line">    &#x27;skip<span class="built_in">$</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">%&quot;~(&quot; number * &quot;)&quot; * *      //num</span></span><br><span class="line">      volume empty<span class="built_in">$</span></span><br><span class="line">        &#123; &quot;there&#x27;s a number but no volume in &quot; cite<span class="built_in">$</span> * warning<span class="built_in">$</span> &#125;</span><br><span class="line">        &#x27;skip<span class="built_in">$</span></span><br><span class="line">      if<span class="built_in">$</span></span><br><span class="line">    &#125;</span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 语言规范</title>
      <link href="/anxiangblog.github.io/2023/04/20/go%20%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/"/>
      <url>/anxiangblog.github.io/2023/04/20/go%20%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="go-语言规范"><a href="#go-语言规范" class="headerlink" title="go 语言规范"></a>go 语言规范</h1><p>System:</p><ul><li>par_ltc: 晶体结构类型</li><li>nx, ny, nz: 模拟系统在三个维度上的大小</li><li>par_compB: 杂质浓度</li><li>par_compV: 空位浓度</li><li>Mutiple: 是否允许多个空位存在</li></ul><p>Simulation time parameters:</p><ul><li>par_time: 模拟总时间</li><li>time_conf: 输出体系状态的时间间隔</li><li>par_step: 总步数</li><li>step_log: 输出log文件的步数间隔</li></ul><p>Read File:</p><ul><li>read_file: 是否从文件中读取系统信息</li><li>filepath: 文件路径</li></ul><p>Kinetic parameters:</p><ul><li>par_temp: 模拟温度</li><li>par_beta: 波尔兹曼常数</li><li>par_dis_rec: 再生中心到复合中心的距离</li><li>par_muvA: 空位在缺陷中移动的速率</li></ul><p>Starting number of atoms:</p><ul><li>par_radius_start: 起始原子数量</li></ul><p>Energy parameters:</p><ul><li>par_eSPA, par_eSPB: A-B, B-B之间相互作用的势能参数</li><li>par_eSPA1A, par_eSPA2A, par_eSPA1B, par_eSPA2B, par_eSPA1V, par_eSPA2V: A-A, A-B, A-V之间相互作用的势能参数</li><li>par_eSPB1B, par_eSPB2B, par_eSPB1V, par_eSPB2V, par_eSPV1V, par_eSPV2V: B-B, B-V, V-V之间相互作用的势能参数</li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a><strong>命名规范</strong></h2><ol><li><p>当命名（包括常量、变量、类型、函数名、结构字段等等）以一个<strong>大写字母开头</strong>，如：Group1，那么使用这种形式的标识符的对象就<strong>可以被外部包的代码所使用</strong>（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；</p></li><li><p><strong>命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的</strong>（像面向对象语言中的 private ）</p></li><li><p>保持<strong>package</strong>的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为<strong>小写</strong>单词，不要使用下划线或者混合大小写</p></li><li><p>尽量采取有意义的文件名，简短，有意义，应该为<strong>小写</strong>单词，使用<strong>下划线</strong>分隔各个单词</p></li></ol><hr><h3 id="结构体命名"><a href="#结构体命名" class="headerlink" title="结构体命名"></a><strong>结构体命名</strong></h3><ul><li><p>采用驼峰命名法，首字母根据访问控制大写或者小写</p></li><li><p>struct 申明和初始化格式采用多行，例如下面：</p></li><li><pre><code class="go">type User struct&#123;    Username  string    Email     string&#125;// 多行初始化u := User&#123;    Username: &quot;astaxie&quot;,    Email:    &quot;astaxie@gmail.com&quot;,&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### **接口命名**</span><br><span class="line"></span><br><span class="line">- 命名规则基本和上面的结构体类型</span><br><span class="line">- 单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">type Reader interface &#123;</span><br><span class="line">        Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a><strong>变量命名</strong></h3><ul><li>和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则：</li><li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li><li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li><li>错误示例：UrlArray，应该写成 urlArray 或者 URLArray</li><li>若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> hasConflict <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> canManage <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> allowGitHook <span class="type">bool</span></span><br></pre></td></tr></table></figure><h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a><strong>常量命名</strong></h3><p>常量均需使用全部大写字母组成，并使用下划线分词</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> APP_VER = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure><p>如果是枚举类型的常量，需要先创建相应类型：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP  Scheme = <span class="string">&quot;http&quot;</span></span><br><span class="line">    HTTPS Scheme = <span class="string">&quot;https&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>下面的列表显示了Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。</p><p><img src="https://pic2.zhimg.com/80/v2-6f2ead24b6b775c30f025cdbd2dff911_720w.webp" alt="img"></p><p>Go提供C风格的<code>/* */</code>块注释和C ++风格的<code>//</code>行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。</p><ul><li>单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释</li><li>多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段</li></ul><p>go 语言自带的 godoc 工具可以根据注释生成文档，生成可以自动生成对应的网站（ <a href="https://link.zhihu.com/?target=http://golang.org">http://golang.org</a> 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在package子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在<code>godoc</code>页面上，并应设置下面的详细文档</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><h3 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a><strong>包注释</strong></h3><p>每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）：</p><ul><li>包的基本简介（包名，简介）</li><li>创建者，格式： 创建人： rtx 名</li><li>创建时间，格式：创建时间： yyyyMMdd</li></ul><p>例如 util 包的注释示例如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。</span></span><br><span class="line"><span class="comment">// 创建人： hanru</span></span><br><span class="line"><span class="comment">// 创建时间： 20190419</span></span><br></pre></td></tr></table></figure><h3 id="结构（接口）注释"><a href="#结构（接口）注释" class="headerlink" title="结构（接口）注释"></a><strong>结构（接口）注释</strong></h3><p>每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User ， 用户对象，定义了用户的基础信息</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="type">string</span> <span class="comment">// 用户名</span></span><br><span class="line">    Email     <span class="type">string</span> <span class="comment">// 邮箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数（方法）注释"><a href="#函数（方法）注释" class="headerlink" title="函数（方法）注释"></a><strong>函数（方法）注释</strong></h3><p>每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）：</p><ul><li>简要说明，格式说明：以函数名开头，“，”分隔说明部分</li><li>参数列表：每行一个参数，参数名开头，“，”分隔说明部分</li><li>返回值： 每行一个返回值</li></ul><p>示例如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewtAttrModel ， 属性数据层操作类的工厂方法</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      ctx ： 上下文信息</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      属性操作类指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAttrModel</span><span class="params">(ctx *common.Context)</span></span> *AttrModel &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码逻辑注释"><a href="#代码逻辑注释" class="headerlink" title="代码逻辑注释"></a><strong>代码逻辑注释</strong></h3><p>对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br><span class="line">xxxxx</span><br><span class="line">xxxxxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure><h3 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a><strong>注释风格</strong></h3><p>统一使用中文注释，对于中英文字符之间严格使用<strong>空格分隔</strong>， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br><span class="line">建议全部使用单行注释</span><br><span class="line">和代码的规范一样，单行注释不要过长，禁止超过 <span class="number">120</span> 字符</span><br></pre></td></tr></table></figure><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a><strong>代码风格</strong></h2><h3 id="1、缩进和折行"><a href="#1、缩进和折行" class="headerlink" title="1、缩进和折行"></a><strong>1、缩进和折行</strong></h3><ul><li>缩进直接使用 gofmt 工具格式化即可（gofmt 是使用 <strong>tab</strong> 缩进的）；</li><li>折行方面，一行最长不超过<strong>120个字符</strong>，超过的请使用换行展示，尽量保持格式优雅。</li></ul><p>我们使用Goland开发工具，可以直接使用快捷键：ctrl+alt+L，即可。</p><h3 id="2、语句的结尾"><a href="#2、语句的结尾" class="headerlink" title="2、语句的结尾"></a><strong>2、语句的结尾</strong></h3><p>Go语言中是不需要类似于Java需要冒号结尾，默认一行就是一条数据</p><p>如果你打算将多个语句写在同一行，它们则必须使用 <strong>;</strong></p><h3 id="3、括号和空格"><a href="#3、括号和空格" class="headerlink" title="3、括号和空格"></a>3、<strong>括号和空格</strong></h3><p>括号和空格方面，也可以直接使用 gofmt 工具格式化（go 会强制左大括号不换行，换行会报语法错误），所有的运算符和操作数之间要留空格。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的方式</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的方式</span></span><br><span class="line"><span class="keyword">if</span> a&gt;<span class="number">0</span>  <span class="comment">// a ，0 和 &gt; 之间应该空格</span></span><br><span class="line">&#123;       <span class="comment">// 左大括号不可以换行，会报语法错误</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、import-规范"><a href="#4、import-规范" class="headerlink" title="4、import 规范"></a><strong>4、import 规范</strong></h3><p>import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;myproject/models&quot;</span></span><br><span class="line">    <span class="string">&quot;myproject/controller&quot;</span></span><br><span class="line">    <span class="string">&quot;myproject/utils&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/astaxie/beego&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)   </span><br></pre></td></tr></table></figure><p>有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。</p><p>在项目中不要使用相对路径引入包：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是不好的导入</span></span><br><span class="line"><span class="keyword">import</span> “../net”</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是正确的做法</span></span><br><span class="line"><span class="keyword">import</span> “github.com/repo/proj/src/net”</span><br></pre></td></tr></table></figure><p>但是如果是引入本项目中的其他包，最好使用相对路径</p><h3 id="5、错误处理"><a href="#5、错误处理" class="headerlink" title="5、错误处理"></a><strong>5、错误处理</strong></h3><ul><li>错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来</li><li>尽早return：一旦有错误发生，马上返回</li><li>尽量不要使用panic，除非你知道你在做什么</li><li>错误描述如果是英文必须为小写，不需要标点结尾</li><li>采用独立的错误流进行处理</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a><strong>6、测试</strong></h3><p>单元测试文件名命名规范为 example_test.go 测试用例的函数名称必须以 Test 开头，例如：TestExample 每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include#include#includeusing namespace std;void main() &#123;  vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;a1;//定义三维数组  vector&lt;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&gt;a2;//定义四维数组  vector&lt;vector&lt;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&gt;&gt;a3;//定义五维数组    int n = 5, m = 4, k = 6, p = 3, q = 2;//可以改变，可以根据自己要求输入  //三维数组a1实例化  </span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;    </span><br><span class="line">vector&lt;vector&lt;int&gt;&gt;temp1;    </span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;     </span><br><span class="line">vector&lt;int&gt;temp2;      </span><br><span class="line">for (int v = 0; v &lt; k; v++) &#123;        </span><br><span class="line">temp2.push_back(3);//三维数组a1[n][m][k]全部赋值为3      </span><br><span class="line">&#125;     </span><br><span class="line">temp1.push_back(temp2);    </span><br><span class="line">&#125;  </span><br><span class="line">a1.push_back(temp1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//四维数组a2实例化  </span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;   </span><br><span class="line">vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;temp3;   </span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;    </span><br><span class="line">vector&lt;vector&lt;int&gt;&gt;temp4;     </span><br><span class="line">for (int v = 0; v &lt; k; v++) &#123;       </span><br><span class="line">vector&lt;int&gt;temp5;        </span><br><span class="line">for (int c = 0; c &lt; p; c++) &#123;         </span><br><span class="line">temp5.push_back(4);//四维数组a2[n][m][k][p]全部赋值为4      </span><br><span class="line">&#125;       </span><br><span class="line">temp4.push_back(temp5);    </span><br><span class="line">&#125;     </span><br><span class="line">temp3.push_back(temp4);   </span><br><span class="line">&#125;    </span><br><span class="line">a2.push_back(temp3);  &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//五维数组a3实例化  for (int i = 0; i &lt; n; i++) &#123;    vector&lt;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&gt;temp6;    for (int j = 0; j &lt; m; j++) &#123;      vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;temp7;      for (int v = 0; v &lt; k; v++) &#123;        vector&lt;vector&lt;int&gt;&gt;temp8;        for (int c = 0; c &lt; p; c++) &#123;          vector&lt;int&gt;temp9;          for (int b = 0; b &lt; q; b++) &#123;            temp9.push_back(5);//五维数组a3[n][m][k][p][q]全部赋值为5          &#125;          temp8.push_back(temp9);        &#125;        temp7.push_back(temp8);      &#125;      temp6.push_back(temp7);    &#125;    a3.push_back(temp6);  &#125;    //打印数组a3[n][m][k][p][q]，显示是否正确    for (int i = 0; i &lt; n; i++) &#123;      for (int j = 0; j &lt; m; j++) &#123;        for (int v = 0; v &lt; k; v++) &#123;          for (int c = 0; c &lt; p; c++)          &#123;            for (int b = 0; b &lt; q; b++) &#123;              a3[i][j][v][c][b] = 5;//给五维数组赋值              printf(&quot;a3[%d][%d][%d][% d][%d]=%d\t&quot;,i,j,v,c,b,a3[i][j][v][c][b]);            &#125;            //printf(&quot;\n&quot;);          &#125;          printf(&quot;\n&quot;);        &#125;        printf(&quot;\n&quot;);      &#125;      printf(&quot;\n&quot;);    &#125;    //同理可以输出三维数组a1[n][m][k]和四维数组a2[n][m][k][p]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡方测验</title>
      <link href="/anxiangblog.github.io/2023/04/19/%E5%8D%A1%E6%96%B9/"/>
      <url>/anxiangblog.github.io/2023/04/19/%E5%8D%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="卡方测验"><a href="#卡方测验" class="headerlink" title="卡方测验"></a>卡方测验</h1><p><strong>卡方检验</strong>是一种用于<strong>确定观察到的频率与期望频率之间差异</strong>的统计检验。它可以用于比较两个或更多组分类变量的频率分布，以确定它们是否来自<strong>同一总体。</strong></p><p>下面是进行卡方检验的基本步骤：</p><ol><li>提出假设：你需要提出原假设和备择假设。原假设是指两个或更多组之间没有显著差异，而备择假设则是指它们之间存在显著差异。</li><li>确定显著性水平：在进行卡方检验之前，你需要确定显著性水平，通常为0.05或0.01。这表示如果计算出的p值小于显著性水平，则可以拒绝原假设。</li><li>收集数据：你需要收集每个组的样本数据，并计算每个组的观察频率。</li><li>计算期望频率：根据原假设，计算每个组的期望频率。</li><li>计算卡方值：将观察频率和期望频率之间的<strong>差异平方除以期望频率</strong>，然后将所有结果相加，即可得到卡方值。</li><li>查找临界值：使用自由度和显著性水平查找卡方分布表格，以确定拒绝原假设所需的临界值。</li><li>进行统计检验：比较卡方值和临界值。如果卡方值大于临界值，则可以拒绝原假设，并认为组之间存在显著差异。如果卡方值小于或等于临界值，则不能拒绝原假设。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设你是一位研究人员，想要确定在某个城市中，男性和女性的吸烟率是否存在显著差异。你随机选择了200名男性和200名女性，并记录了他们是否吸烟的情况。你的原假设是男性和女性的吸烟率没有显著差异，备择假设是男性和女性的吸烟率存在显著差异。</p><p>下面是卡方检验的步骤：</p><ol><li>提出假设： <strong>原假设：男性和女性的吸烟率没有显著差异</strong>。 <strong>备择假设：男性和女性的吸烟率存在显著差异</strong>。</li><li>确定显著性水平：假设我们将显著性水平设置为<strong>0.05</strong>。</li><li>收集数据：你收集了200名男性和200名女性的数据，并记录了他们是否吸烟。结果如下：</li></ol><table><thead><tr><th></th><th>吸烟</th><th>不吸烟</th><th>总数</th></tr></thead><tbody><tr><td>男性</td><td>50</td><td>150</td><td>200</td></tr><tr><td>女性</td><td>30</td><td>170</td><td>200</td></tr><tr><td>总数</td><td>80</td><td>320</td><td>400</td></tr></tbody></table><p>计算期望频率：根据原假设，男性和女性的吸烟率相同。因此，期望频率可以通过以下公式计算：</p><p>男性吸烟人数的期望频率 &#x3D; (男性总人数 × 吸烟总人数) &#x2F; 样本总人数 &#x3D; (200 × 80) &#x2F; 400 &#x3D; 40 </p><p>男性不吸烟人数的期望频率 &#x3D; (男性总人数 × 不吸烟总人数) &#x2F; 样本总人数 &#x3D; (200 × 320) &#x2F; 400 &#x3D; 160 </p><p>女性吸烟人数的期望频率 &#x3D; (女性总人数 × 吸烟总人数) &#x2F; 样本总人数 &#x3D; (200 × 80) &#x2F; 400 &#x3D; 40 </p><p>女性不吸烟人数的期望频率 &#x3D; (女性总人数 × 不吸烟总人数) &#x2F; 样本总人数 &#x3D; (200 × 320) &#x2F; 400 &#x3D; 160</p><ol><li><p>计算卡方值：根据上面的期望频率，我们可以计算出每个单元格的卡方值，然后将所有单元格的卡方值相加，得到总的卡方值。计算公式为：</p><p>​</p></li></ol><p>​<strong>卡方值 &#x3D; Σ [ (观察频率 - 期望频率)² &#x2F; 期望频率 ]</strong></p><p>​    卡方值 &#x3D; [(50-40)² &#x2F; 40] + [(150-160)² &#x2F; 160] + [(30-40)² &#x2F; 40] + [(170-160)² &#x2F; 160] &#x3D; 2.5</p><p>  2.确定自由度：自由度的计算公式为自由度 &#x3D; (行数-1) × (列数-1)，在这个例子中，自由度为 (2-1) × (2-1) &#x3D; 1。</p><p>  3.查找卡方分布表：在自由度为1时，显著性水平0.05对应的卡方值为3.84，而计算得出的卡方值2.5小于3.84。</p><p>  4.得出结论：因为计算得出的卡方值小于临界值3.84，所以在显著性水平0.05下，我们无法拒绝原假设，即男性     和女性的吸烟率没有显著差异。</p><p><strong>卡方检验的重点在于通过计算卡方值来判断两个变量之间是否存在显著性关联。具体来说，卡方值是通过比较观察频率和期望频率之间的差异来计算的，如果两者之间差异很大，则卡方值会比较大，反之则会比较小</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>口琴乐谱</title>
      <link href="/anxiangblog.github.io/2023/04/19/%E5%8F%A3%E7%90%B4%E4%B9%90%E8%B0%B1/"/>
      <url>/anxiangblog.github.io/2023/04/19/%E5%8F%A3%E7%90%B4%E4%B9%90%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="口琴乐谱"><a href="#口琴乐谱" class="headerlink" title="口琴乐谱"></a>口琴乐谱</h1><p>搜集的几个比较简单，适合初学者的乐曲</p><h2 id="漠河舞厅"><a href="#漠河舞厅" class="headerlink" title="漠河舞厅"></a>漠河舞厅</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1#1#23#5    #4#5【#2】【#1】#5 </span><br><span class="line">#4#5【#2】【#1】#4    3#23#2(#5)</span><br><span class="line"></span><br><span class="line">(#5)#1#1#23#4#53 #5#5#57#5   </span><br><span class="line">#5#5#4#4#4#56 (#5)#5#5#5#4#2</span><br><span class="line">#1#23#4#53#53#5#5#57#5  </span><br><span class="line">#5#5#4#4#4#56  (#5)#5#5#4#2</span><br><span class="line">【#1】#5#1  #176 #56  7#4(7) (7)7#5 6#56#5  </span><br><span class="line">【#1】#5#1  #176 #56  6#56#56 6#56#56#5</span><br><span class="line"></span><br><span class="line">#3#3#3#4#5  #1【#1】#5766#56 </span><br><span class="line">66673737  77【2】 【2】【#1】【#1】【1】【#1】</span><br><span class="line">【#1】【#1】【#1】777【#1】【2】 【2】【2】【2】6667【#1】 </span><br><span class="line">【#1】【#1】77【#1】【#1】 【4】【#1】7#5 #56#4 #1#5#4</span><br><span class="line"></span><br><span class="line">#1#1#1#23#4#53 #5#5#57#5   </span><br><span class="line">#5#5#4#4#4#56 (#5)#5#5#5#4#2 </span><br><span class="line">#1#23#4#53#53#5#5#57#5  </span><br><span class="line">#5#5#4#4#4#56  (#5)#5#5#4#2</span><br><span class="line"> </span><br><span class="line">【#1】#5#1  (#5)76 #56  7【#1】【#2】7#4 6  #5#5  </span><br><span class="line">#53#1  (#5)#5#4 #56  6#56#56 6#56#56#5</span><br><span class="line"></span><br><span class="line">#3#3#3#4#5  #1【#1】#5766#56 </span><br><span class="line">66673737  77【2】 【2】【#1】【#1】【1】【#1】</span><br><span class="line">【#1】【#1】【#1】777【#1】【2】 【2】【2】【2】6667【#1】 </span><br><span class="line">【#1】【#1】77【#1】【#1】 【4】【#1】7#5 #56#4 #4#5#4</span><br><span class="line"></span><br><span class="line">#3#3#3#4#5  #1【#1】#5766#56 </span><br><span class="line">66673737  77【2】 【2】【#1】【#1】7【#1】</span><br><span class="line">【#1】【#1】【#1】777【#1】【2】 【2】【2】【3】【#1】【#1】【#1】【#5】【6】  </span><br><span class="line">【6】【#5】 【#4】【4】 【#5】【#1】【#4】 【6】【#5】 【#5】【#1】【#4】 </span><br><span class="line"></span><br><span class="line">#4#4#4 #56 7【#1】6    【#1】【#1】7【#1】【#1】</span><br><span class="line">777【#1】【2】 7【2】7【#1】【#1】【#1】7#5</span><br></pre></td></tr></table></figure><h2 id="星月神话"><a href="#星月神话" class="headerlink" title="星月神话"></a>星月神话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32121(7)1(7)(6)(5)</span><br><span class="line">(6)1(7)(5)(3)</span><br><span class="line">1232121(7)1(7)(6)(5)</span><br><span class="line">(6)3(7)121</span><br><span class="line"></span><br><span class="line">(6)1(7)12353 (6)1(7)121</span><br><span class="line"></span><br><span class="line">1232121(7)1(7)(6)(5)</span><br><span class="line">(6)1(7)1232</span><br><span class="line">1232121(7)1(7)(6)(5)</span><br><span class="line">(7)(5)(6)3(7)121</span><br><span class="line"></span><br><span class="line">356652531(6)</span><br><span class="line">(6)(7)13253</span><br><span class="line">356652531(6)</span><br><span class="line">321323(6)</span><br><span class="line"></span><br><span class="line">副歌第二段：</span><br><span class="line">356652531(6)</span><br><span class="line">3213253</span><br><span class="line">356652531(6)</span><br><span class="line">321323(6)</span><br></pre></td></tr></table></figure><h2 id="蒲公英的约定"><a href="#蒲公英的约定" class="headerlink" title="蒲公英的约定"></a>蒲公英的约定</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(#5)(6)(7)(7)(7)(7)#1#23</span><br><span class="line">3#2#4#1(7)(7)#43#5#5</span><br><span class="line">3#4#5#5#56#5#4#53</span><br><span class="line">#1#23#433#1#5#5#4</span><br><span class="line"></span><br><span class="line">(#5)(6)(7)(7)(7)(7)#1#2(7)#43</span><br><span class="line">3#2#4#1(7)(7)#43#5#5</span><br><span class="line">3#4#5#5#56#5#4#5#43</span><br><span class="line">#1#23#433#1#5#5#4</span><br><span class="line"></span><br><span class="line">(#5)(7)3#5#56#4  #47#23</span><br><span class="line">#56733#4#5#5</span><br><span class="line">(#5)(7)3#5#56#4  #47#23</span><br><span class="line">#56733#433</span><br><span class="line"></span><br><span class="line">第二遍结尾：</span><br><span class="line">【#1】7#5#43#56#4  【#1】7#23</span><br><span class="line">#56733#4#5#5</span><br><span class="line">(#5)(7)3#5#5#4#4  #47#2#43</span><br><span class="line">#56733#433</span><br></pre></td></tr></table></figure><h2 id="起风了"><a href="#起风了" class="headerlink" title="起风了"></a>起风了</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)#1(#6)</span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)(#5)(#4#2)</span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)#1(#6) (#5)(#6)(#5)(#4)(#5)</span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)#1(#6) (#5)(#6)(#5)(#4#2)</span><br><span class="line">(#6)(#5)(#4)(#5)(#4) (#6)(#5)(#4)(#5)(#4)（#1）</span><br><span class="line">(#6)(#5)(#4)(#5)(#4)</span><br><span class="line"></span><br><span class="line">(#4)(#5)(#6)(#4) #2#1#2（#4）#3#2#3</span><br><span class="line">#3#2#3 (#6)#4#5#4#3#2#1</span><br><span class="line">#2#1#2#1#2#1#2#1(#5)#1(#6)</span><br><span class="line">(#4)(#5)(#6)(#4) #2#1#2（#4）#3#2#3</span><br><span class="line">#3#2#3 (#6)#4#5#4#3#2#1</span><br><span class="line">#2#6#6 #1#2#6#6#1#2</span><br><span class="line"></span><br><span class="line">#4#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】</span><br><span class="line">#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】#6</span><br><span class="line">#5#4#2#4 #5#4#2#4#67#6#5#6#5</span><br><span class="line">#4#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】</span><br><span class="line">#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】#6</span><br><span class="line">#5#4#2#6 #5#4#2#4#4</span><br><span class="line">#2#6 #5#4#2 #6#5#4#2 #4#4</span><br><span class="line">  间奏：</span><br><span class="line">#1 #4 #5 #6 #1【#1】  #6</span><br><span class="line"> #3#4 #5 #6  #1【#1】  #6</span><br><span class="line"> #6【#1】 #5 6 #5#4#2#4</span><br><span class="line">(#6)(7)(#6) #1 #2(#6)(#5) （#4） （#2） （#4）(#6)</span><br><span class="line">(#6)(#6) (#2) (#6)(#6) (#2)</span><br><span class="line">(#6)(#6)#2#1#2</span><br><span class="line">【#1 】#6 #5#4#2#1(#6)(#5) (#4) (#2) (#1) (#2) (#4)</span><br><span class="line"> (#3) (#4)(#5)(#6)#2#1(7)(#6) (#3) (#4) #1</span><br><span class="line">  尾音：</span><br><span class="line">【#2#1】#6  【#2#1】#6【#1 】  【#2#1】#6</span><br></pre></td></tr></table></figure><h2 id="Clannad团子大家族"><a href="#Clannad团子大家族" class="headerlink" title="Clannad团子大家族"></a>Clannad团子大家族</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1=C</span><br><span class="line">【#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6 #6#7#7#5</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6#6#5  】</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6 #6#7#6</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6#5</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6 #6#7#6</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6#5</span><br><span class="line">【#1】#7#5#3 #5#6#3 #5#2#3#5</span><br><span class="line">【#1】#7#5#3 #5#6#3 #5</span><br><span class="line">【#1】#7#5#3 #5#6#3 #5#2#3#5 #2#5#1 </span><br><span class="line">#2#1#2#1</span><br><span class="line">(#6)#2#5#6 #6#5#3 #5#6#7【#2】#6#7#5</span><br><span class="line">#2#5#6 #6#5#3 #6#5【#2】#7</span><br><span class="line">(#6)#2#5#6 #6#5#3 #5#6#7【#2】#6#7</span><br><span class="line">#554 45#55#5#5</span><br><span class="line">(#6)#2#5#6 #6#5#3 #5#6#7【#2】#6#7#5</span><br><span class="line">#2#5#6 #6#5#3 #6#5【#2】#7</span><br><span class="line">(#6)#2#5#6 #6#5#3 #5#6#7【#2】#6#7</span><br><span class="line">#554 45#55#5   </span><br><span class="line"></span><br><span class="line">间奏   #5 5 4 #2   #6#54#5 #6#5【#21】  </span><br><span class="line">#6#54#5 #6#5【#21】     #6#54#5 #6#5【#21】</span><br></pre></td></tr></table></figure><h2 id="打上花火"><a href="#打上花火" class="headerlink" title="打上花火"></a>打上花火</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1=C</span><br><span class="line">(#6)#1#2#4#5 #3#1(7#6)#1#3#4 #4#3#2#4#3#1#1</span><br><span class="line">(#6)#1#2#4#5 #3#1(7#6)#1#3#4 #4#3#2#4#3#1#1#2 </span><br><span class="line">#2#3#4 #3#2#3#4 #3#2#3#4#1#1#2#1(#4#4) #2#1(#4#5#6) </span><br><span class="line">#2#3#4 #3#2#3#4 #3#2#3#4#5#67 #4#4#6#5#4#4</span><br><span class="line"></span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4</span><br><span class="line">#6[#1]#6#5 #6[#1#1#2] [#1]7#6</span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4</span><br><span class="line">#4#3#2#3#2 #5#3#2#3#3#4 </span><br><span class="line"></span><br><span class="line">#4#5#6 #5#4#4 #2#3#4 #3#2#1 (#6)#1#2  #3#4#3#2#1#2#1</span><br><span class="line">(#6#67)#1#2 #3#4#3 #4#5#6 #5#4#3 #1#1</span><br><span class="line">#4#5#6 #5#4#4 #2#3#4 #3#2#1 (#6)#1#2  #3#4#3#2#1#2#1 </span><br><span class="line">#2#1#2#4 #5 #6#5#4</span><br><span class="line">[#2#1]7#6 #5#67 #6#5#4 #5#67 #6#5#4</span><br><span class="line">#2#3#4#3#2#1 #1#2#4#3#1(#6)#2 </span><br><span class="line">[#2#1]7#6 #5#67 #6#5#6 7#6#5#4 #4</span><br><span class="line"></span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4 </span><br><span class="line">#6[#1]#6#5 #6[#1#1#2] [#1]7#6 </span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4 </span><br><span class="line">#4#3#2#3#2 #5#3#1(#6)#3#4</span><br><span class="line"></span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#2#1]7#6[#1#1] #2#1(7#6)#1#1</span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#1]#6#5#4#5#5 #4#5#67#5</span><br><span class="line"></span><br><span class="line">(#6)#1#2#4#5 #3#1(7#6)#1#3#4 #4#3#2#4#3#1#1</span><br><span class="line">(#6)#1#2#4#5 #3#1(7#6)#1#3#4 #4#3#2#4#3#1#1#2</span><br><span class="line"></span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4</span><br><span class="line">#6[#1]#6#5 #6[#1#1#2] [#1]7#6</span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4</span><br><span class="line">#4#3#2#3#2 #5#3#2#3#3#4 </span><br><span class="line"></span><br><span class="line">#2 #4#5 #6#4 #6#5#4#5[#1]#6 #4#1#2 #1(7)#1</span><br><span class="line">#2 #4#5 #6#4 #6#5#4#5[#1#2] #6#5 #4#5#6 #5#4#4</span><br><span class="line">#2 #4#5 #6#4 #6#5#4#5[#1]#6 #4#1#2 #1(7)#1</span><br><span class="line">#2 #4#5 #6#4 #6#5#4#5[#1#2] #6#5 #4#5#6 #5#4#4</span><br></pre></td></tr></table></figure><p>先搜集这么多，剩下的下次在更新 22333</p>]]></content>
      
      
      <categories>
          
          <category> 娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lammps安装</title>
      <link href="/anxiangblog.github.io/2023/04/19/Lammps/"/>
      <url>/anxiangblog.github.io/2023/04/19/Lammps/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="Lammps"><a href="#Lammps" class="headerlink" title="Lammps"></a>Lammps</h1><p>最近一个老师让我帮他装一个lammps跑模拟用，就花了几天时间学习了一下，总共需要配置3个包</p><p>配置环境为centos，其他同理。下载包的话<strong>最新版本</strong>。</p><h2 id="openmpi"><a href="#openmpi" class="headerlink" title="openmpi"></a>openmpi</h2><p><strong>下载地址</strong> <a href="https://link.zhihu.com/?target=https://www.open-mpi.org/software/ompi/v4.0/">https://link.zhihu.com/?target=https%3A//www.open-mpi.org/software/ompi/v4.0/</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf openmpi的文件名</span><br><span class="line">cd openmpi文件名</span><br><span class="line">./configure --prefix=openmpi安装路径   #安装路径可以新建一个local/openmpi文件夹 </span><br><span class="line">make -j 8  #多少核make        </span><br><span class="line">make check</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">安装完成没有报错配置环境变量</span><br><span class="line">vi .bashrc</span><br><span class="line">#openmpi 这是我的环境变量</span><br><span class="line">export PATH=/home/liaosi/local/openmpi/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/home/liaosi/local/openmpi/lib:LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">安装后检查一下</span><br><span class="line"></span><br><span class="line">mpicc --version：该命令将显示MPI编译器的版本信息，如果MPI已经安装，则将显示版本信息。</span><br><span class="line"></span><br><span class="line">mpirun --version：该命令将显示MPI运行时的版本信息，如果MPI已经安装，则将显示版本信息。</span><br><span class="line"></span><br><span class="line">mpiexec --version：该命令将显示MPI运行时的版本信息，如果MPI已经安装，则将显示版本信息。</span><br></pre></td></tr></table></figure><h2 id="fftw3"><a href="#fftw3" class="headerlink" title="fftw3"></a>fftw3</h2><p><strong>下载地址</strong> <a href="https://link.zhihu.com/?target=https://www.fftw.org/download.html">https://link.zhihu.com/?target=https%3A//www.fftw.org/download.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf fftw3的文件名</span><br><span class="line">cd openmpi文件名</span><br><span class="line">./configure --prefix=fftw3安装路径   #安装路径可以新建一个local/fftw3文件夹 </span><br><span class="line">make -j 8  #多少核make        </span><br><span class="line">make check</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">安装完成没有报错配置环境变量</span><br><span class="line">vi .bashrc</span><br><span class="line">#openmpi 这是我的环境变量</span><br><span class="line">export PATH=/home/liaosi/local/fft/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/home/liaosi/local/fft/lib:LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><h2 id="lammps"><a href="#lammps" class="headerlink" title="lammps"></a>lammps</h2><p><strong>下载地址</strong> <a href="https://link.zhihu.com/?target=https://www.lammps.org/download.html">https://link.zhihu.com/?target=https%3A//www.lammps.org/download.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解压lammps包，进入/src/MAKE/OPTION</span><br><span class="line"></span><br><span class="line">修改Makefile.fftw内容</span><br><span class="line">将fftw3路径改为自己的fftw3安装路径(默认路径是/usr/local)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改Makefile.g++_openmpi</span><br><span class="line">将openmpi的路径改为自己的openmpi安装路径(默认路径是/usr/local)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回到src目录，安装所需的包（可以用make package-status查看包的安装情况，这里的包是指lammps提供的一些实现特定功能的脚本，可以理解为类似于python里面的库）</span><br><span class="line"></span><br><span class="line">make yes-molecule</span><br><span class="line">make yes-rigid</span><br><span class="line">make yes-kspace</span><br><span class="line">make yes-body</span><br><span class="line">make yes-manybody</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make mpi   #会生成一个lmp_mpi 文件</span><br><span class="line"></span><br><span class="line">配置环境变量</span><br><span class="line">“#lammps2022</span><br><span class="line"></span><br><span class="line">export PATH=/home/liaosi/opt/lammps/lammps-23Jun2022/src:$PATH”</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>都按照完成后 source ~&#x2F;.bashrc 更新一下环境变量</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpirun -np 4 ../../src/lmp_mpi -in in.file    in.file 在examp文件下</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++</title>
      <link href="/anxiangblog.github.io/2023/04/18/C++%20%20%E9%87%8D%E7%82%B9/"/>
      <url>/anxiangblog.github.io/2023/04/18/C++%20%20%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="C-重点"><a href="#C-重点" class="headerlink" title="C++  重点"></a>C++  重点</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>常类型是指使用类型修饰符****const****说明的类型，常类型的变量或对象的值是不能被更新的</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1.可以定义常量const int a&#x3D;100;  </p><p>2.防止修改，起保护作用，增加程序健壮性</p><p>3.类型检查 const定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。其他情况下它只是一个 <code>const</code> 限定的变量，不要将与常量混淆。</p><p>4.可以节省空间，避免不必要的内存分配const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像<code>#define</code>一样给出的是立即数。const定义的常量在程序运行过程中只有一份拷贝，而<code>#define</code>定义的常量在内存中有若干个拷贝。</p><h3 id="const对象默认为文件局部变量"><a href="#const对象默认为文件局部变量" class="headerlink" title="const对象默认为文件局部变量"></a><strong>const对象默认为文件局部变量</strong></h3><p>非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">未被const修饰的变量在不同文件的访问</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">// file1.cpp</span><br><span class="line">int ext;</span><br><span class="line">// file2.cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">extern int ext;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;(ext+10)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&gt; const常量在不同文件的访问</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">//extern_file1.cpp</span><br><span class="line">extern const int ext=12;</span><br><span class="line">//extern_file2.cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">extern const int ext;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;ext&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.定义常量</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">const int b = 10;</span><br><span class="line">b = 0; // error: assignment of read-only variable ‘b’</span><br><span class="line">const string s = &quot;helloworld&quot;;</span><br><span class="line">const int i,j=0 // error: uninitialized const ‘i’</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">上述有两个错误：</span><br><span class="line">+ b 为常量，不可更改！</span><br><span class="line">+ i 为常量，必须进行初始化！(因为常量在定义后就不能被修改，所以定义时必须初始化。)</span><br></pre></td></tr></table></figure><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a><strong>指针与const</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char * a; //指向const对象的指针或者说指向常量的指针。</span><br><span class="line">char const * a; //同上</span><br><span class="line">char * const a; //指向类型对象的const指针。或者说常指针、const指针。</span><br><span class="line">const char * const a; //指向const对象的const指针。</span><br></pre></td></tr></table></figure><p>如果<strong>const</strong>位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br>如果const位于<code>*</code>的右侧，<strong>const</strong>就是修饰指针本身，即指针本身是常量。</p><h4 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int *ptr;</span><br><span class="line">*ptr = 10; //error</span><br><span class="line">ptr是一个指向int类型const对象的指针，const定义的是int类型，也就是ptr所指向的对象类型，而不是ptr本身，所以ptr可以不用赋初始值。但是不能通过ptr去修改所指对象的值。</span><br><span class="line">除此之外，也不能使用void`*`指针保存const对象的地址，必须使用const void`*`类型的指针保存const对象的地址</span><br><span class="line"></span><br><span class="line">const int p = 10;</span><br><span class="line">const void * vp = &amp;p;</span><br><span class="line">void *vp = &amp;p; //error</span><br><span class="line"></span><br><span class="line">允许把非const对象的地址赋给指向const对象的指针</span><br><span class="line">const int *ptr;</span><br><span class="line">int val = 3;</span><br><span class="line">ptr = &amp;val; //ok</span><br><span class="line">我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!</span><br><span class="line"></span><br><span class="line">我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：</span><br><span class="line">int *ptr1 = &amp;val;</span><br><span class="line">*ptr1=4;</span><br><span class="line">cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.对于指向常量的指针，不能通过指针来修改对象的值。<br>2.不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。<br>3.允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。</p><h4 id="常指针"><a href="#常指针" class="headerlink" title="常指针"></a><strong>常指针</strong></h4><p>const指针必须进行初始化，且const指针的值不能修改。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int num=0;</span><br><span class="line">    int * const ptr=&amp;num; //const指针必须初始化！且const指针的值不能修改</span><br><span class="line">    int * t = &amp;num;</span><br><span class="line">    *t = 1;</span><br><span class="line">    cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">上述修改ptr指针所指向的值，可以通过非const指针来修改。</span><br><span class="line"></span><br><span class="line">最后，当把一个const常量的地址赋值给ptr时候，由于ptr指向的是一个变量，而不是const常量，所以会报错，出现：const int`*` -&gt; int `*`错误！</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    const int num=0;</span><br><span class="line">    int * const ptr=&amp;num; //error! const int* -&gt; int*</span><br><span class="line">    cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">上述若改为 const int `*`ptr或者改为const int `*`const ptr，都可以正常！</span><br></pre></td></tr></table></figure><h4 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a><strong>指向常量的常指针</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int p = 3;</span><br><span class="line">const int * const ptr = &amp;p; </span><br><span class="line">ptr是一个const指针，然后指向了一个int 类型的const对象。</span><br></pre></td></tr></table></figure><h3 id="函数中使用const"><a href="#函数中使用const" class="headerlink" title="函数中使用const"></a><strong>函数中使用const</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传递过来的参数及指针本身在函数内不可变，无意义！</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">void func(const int var); // 传递过来的参数不可变</span><br><span class="line">void func(int *const var); // 指针本身不可变</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">表明参数在函数体内不能被修改，但此处没有任何意义，var本身就是形参，在函数内不会改变。包括传入的形参是指针也是一样。</span><br><span class="line"></span><br><span class="line">输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**参数指针所指内容为常量不可变**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">void StringCopy(char *dst, const char *src);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。</span><br></pre></td></tr></table></figure><p><em><strong>*参数为引用，为了增加效率同时防止修改。*</strong></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void func(const A &amp;a)</span><br></pre></td></tr></table></figure><p>对于非内部数据类型的参数而言，像void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。为了提高效率，可以将函数声明改为void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。</p><p>但是函数void func(A &amp;a) 存在一个缺点：“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为void func(const A &amp;a)。</p><p>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &amp;a)。2.对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &amp;x)。</p><h3 id="类中使用const"><a href="#类中使用const" class="headerlink" title="类中使用const"></a><strong>类中使用const</strong></h3><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改 数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。</p><p>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="type">int</span> i); </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Apple::<span class="built_in">Apple</span>(<span class="type">int</span> i):<span class="built_in">apple_number</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span>对象只能访问<span class="type">const</span>成员函数,而非<span class="type">const</span>对象可以访问任意的成员函数,包括<span class="type">const</span>成员函数.</span><br><span class="line"></span><br><span class="line">此时报错，上面<span class="built_in">getCount</span>()方法中调用了一个add方法，而add方法并非<span class="type">const</span>修饰，所以运行报错。也就是说<span class="type">const</span>成员函数只能访问<span class="type">const</span>成员函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们除了上述的初始化<span class="type">const</span>常量用初始化列表方式外，也可以通过下面方法：</span><br><span class="line"></span><br><span class="line">第一：将常量定义与<span class="type">static</span>结合，也就是：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">第二：在外面初始化：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Apple::apple_number=<span class="number">10</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">当然，如果你使用c++<span class="number">11</span>进行编译，直接可以在定义出初始化，可以直接写成：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这两种都在c++<span class="number">11</span>中支持！</span><br><span class="line"></span><br><span class="line">编译的时候加上`-std=c++<span class="number">11</span>`即可！</span><br><span class="line"></span><br><span class="line">这里提到了<span class="type">static</span>，下面简单的说一下：</span><br><span class="line"></span><br><span class="line">在C++中，<span class="type">static</span>静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。</span><br><span class="line"></span><br><span class="line">在类中声明：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ap;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">在类实现文件中使用：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">int</span> Apple::ap=<span class="number">666</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">对于此项，c++<span class="number">11</span>不能进行声明并初始化，也就是上述使用方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>当与不同类型一起使用时，Static关键字具有不同的含义。我们可以使用static关键字：</p><p><em><strong>*静态变量：*</strong></em> 函数中的变量，类中的变量</p><p><em><strong>*静态类的成员：*</strong></em> 类对象和类中的函数</p><h4 id="函数中的静态变量"><a href="#函数中的静态变量" class="headerlink" title="函数中的静态变量"></a>函数中的静态变量</h4><p>当变量声明为static时，空间****将在程序的生命周期内分配*<em><strong>。即使多次调用该函数，静态变量的空间也</strong></em>*只分配一次****，前一次调用中的变量值通过下一次函数调用传递。这对于在C &#x2F; C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p><h4 id="类中的静态变量"><a href="#类中的静态变量" class="headerlink" title="类中的静态变量"></a>类中的静态变量</h4><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量****由对象共享。****对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。</p><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="*静态成员*"></a><em><strong>*静态成员*</strong></em></h4><p>类对象为静态.就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。考虑以下程序，其中对象是非静态的。</p><p>您可以清楚地看到输出的变化。现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期</p><h4 id="类中的静态函数"><a href="#类中的静态函数" class="headerlink" title="类中的静态函数"></a>类中的静态函数</h4><p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和’.’来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。</p><p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">class Apple </span><br><span class="line">&#123; </span><br><span class="line">    public: </span><br><span class="line">        // static member function </span><br><span class="line">        static void printMsg() </span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;Welcome to Apple!&quot;; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// main function </span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    // invoking a static member function </span><br><span class="line">    Apple::printMsg(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="限定访问范围"><a href="#限定访问范围" class="headerlink" title="限定访问范围**"></a><strong>限定访问范围*</strong>*</h4><p>static还有限定访问范围的作用（类似于匿名名字空间）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// source1.cpp</span><br><span class="line">extern void sayHello();</span><br><span class="line">const char* msg = &quot;Hello World!\n&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    sayHello();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// source2.cpp</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">extern char* msg;</span><br><span class="line">void sayHello()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s&quot;, msg);</span><br><span class="line">&#125;</span><br><span class="line">g++对于上面两个代码文件是可以正常编译并且打印Hello World!，但如果给source1.cpp中的msg加上static，则会导致undefined reference to &#x27;msg&#x27;的编译错误：</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><strong>this指针</strong></h2><p>相信在坐的很多人，都在学Python，对于Python来说有self，类比到C++中就是this指针，那么下面一起来深入分析this指针在类中的使用！</p><p>首先来谈谈this指针的用处：</p><p>（1）一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</p><p>（2）this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p><p>其次，this指针的使用：</p><p>（1）在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。</p><p>（2）当参数与成员变量名相同时，如this-&gt;n &#x3D; n （不能写成n &#x3D; n)。</p><p>另外，在网上大家会看到this会被编译器解析成<code>A *const </code>，<code>A const * </code>，究竟是哪一个呢？下面通过断点调试分析：</p><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。上述的get_age函数会被解析成<code>get_age(const A * const this)</code>,<code>add_age</code>函数会被解析成<code>add_age(A* const this,int a)</code>。在C++中类和结构是只有一个区别的：类的成员默认是private，而结构是public。this是类的指针，如果换成结构，那this就是结构的指针了</p><h2 id="inline那些事"><a href="#inline那些事" class="headerlink" title="inline那些事"></a><strong>inline那些事</strong></h2>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇当然是写给倩妮啦~</title>
      <link href="/anxiangblog.github.io/2023/04/18/first/"/>
      <url>/anxiangblog.github.io/2023/04/18/first/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><p>我行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过一个正当最好年龄的人。</p><p><img src="/anxiangblog.github.io/anxiangblog.github/../img/1.jpg" alt="爱你"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
