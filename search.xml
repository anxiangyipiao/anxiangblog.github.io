<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql</title>
      <link href="/anxiangblog.github.io/2023/10/09/mysql/"/>
      <url>/anxiangblog.github.io/2023/10/09/mysql/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h1><h2 id="sql语法"><a href="#sql语法" class="headerlink" title="sql语法"></a>sql语法</h2><p>数据定义DDL          </p><p>数据操纵DML</p><p>数据查询DQL</p><p>数据控制DCL</p><p>事务管理TPL</p><p>指针控制</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p </span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>数据定义DDL</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database database_name <span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8；</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> database database_name;</span><br><span class="line"></span><br><span class="line">use database_name ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tablename(字段名<span class="number">1</span> 字段类型<span class="number">1</span>(字段长度),字段名<span class="number">2</span> 字段类型<span class="number">2</span>(字段长度));</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">desc</span> tablename;  查看表结构</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tablename;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename xxx(操作) 修改表</span><br><span class="line"></span><br><span class="line">修改列名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename change 原列名 想改成的列名 列类型;</span><br><span class="line">修改表的名字</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename rename 新表名 ;</span><br><span class="line">修改列的类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename modify  列名 想改的类型;</span><br><span class="line">增加某列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">add</span> 列名 类型;</span><br><span class="line">删除某列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">drop</span> 列名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);#值的个数、顺序要和字段的个数、顺序一样</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename.列名<span class="number">1</span>,tablename.列名<span class="number">2</span> <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);#给某一列添加数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tablename <span class="keyword">set</span> 字段名 <span class="operator">=</span> 值；</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tablename;<span class="comment">---删除全部表记录(表还在)</span></span><br><span class="line"></span><br><span class="line">防止中文乱码</span><br><span class="line"><span class="keyword">set</span> name gbk;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### 主键约束</span><br><span class="line"></span><br><span class="line">create table tablename(字段名1 字段类型1(字段长度) **primary key auto_increment**,</span><br><span class="line">                字段名2 字段类型2(字段长度));</span><br><span class="line"></span><br><span class="line">#### 非空约束</span><br><span class="line"></span><br><span class="line">create table tablename(字段名1 字段类型1(字段长度),</span><br><span class="line">                字段名2 字段类型2(字段长度) **not null** );</span><br><span class="line"></span><br><span class="line">#### 唯一约束</span><br><span class="line"></span><br><span class="line">create table tablename(字段名1 字段类型1(字段长度),</span><br><span class="line">                字段名2 字段类型2(字段长度) **unique** );</span><br><span class="line"></span><br><span class="line">#### 默认约束</span><br><span class="line"></span><br><span class="line">sex CHAR(2) **DEFAULT** &#x27;男&#x27;</span><br><span class="line"></span><br><span class="line">#### 检查约束</span><br><span class="line"></span><br><span class="line">create table tablename(</span><br><span class="line">age INT, </span><br><span class="line">CHECK (age&gt;0 AND age&lt;=200)</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">#### 外检约束</span><br><span class="line"></span><br><span class="line">FOREIGN KEY (本表(子表)主键) REFERENCES 外表(主表)名(外表主键)</span><br></pre></td></tr></table></figure><h2 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全转小写：lower</span><br><span class="line">SELECT lower(ename) FROM emp;</span><br><span class="line">全转大写：upper</span><br><span class="line">SELECT upper(ename) FROM emp;</span><br><span class="line">获取长度：length</span><br><span class="line">一个字母、数字长度为1，一个汉字为3。跟底层编码表有关</span><br><span class="line">SELECT dname,LENGTH(dname) FROM dept;</span><br><span class="line"></span><br><span class="line">concat：拼接字符串</span><br><span class="line">SELECT concat(dname,&#x27;hello&#x27;) FROM dept;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">substr：截取字符串</span><br><span class="line">substr(1,2) 1:字段名2:从那个字符开始</span><br><span class="line">SELECT substr(dname,3) FROM dept;---------从第三个字母后开始截取，直到结束</span><br><span class="line">substr(1,2,3) 1:字段名2：从那个字符开始 3：截取长度</span><br><span class="line">SELECT substr(dname,3,2) FROM dept;-------从第三个字母后开始截取，截取两个字母</span><br><span class="line"></span><br><span class="line">replace:替换字符</span><br><span class="line">replace(1,2,3):替换字符 1：字段名  把2替换成3</span><br><span class="line"></span><br><span class="line">SELECT dname,REPLACE(dname,&#x27;a&#x27;,&#x27;666&#x27;) FROM dept;</span><br><span class="line"></span><br><span class="line">ifnull：判断是否为空</span><br><span class="line">ifnull(1,2)----判断1是否为null，为null，替换为2.不为null，不管</span><br><span class="line"></span><br><span class="line">SELECT comm,IFNULL(comm,200) FROM emp;</span><br><span class="line"></span><br><span class="line">round：四舍五入</span><br><span class="line">SELECT comm,ROUND(comm)FROM emp;</span><br><span class="line"></span><br><span class="line">ceil 向上取整</span><br><span class="line">SELECT comm,CEIL(comm) FROM emp;</span><br><span class="line"></span><br><span class="line">floor 向下取整</span><br><span class="line">SELECT comm,FLOOR(comm) FROM emp;</span><br><span class="line"></span><br><span class="line">时间函数：</span><br><span class="line">now()----------------获取当前时间(年月日时分秒)</span><br><span class="line"></span><br><span class="line">year(now())--------获取当前时间的年份</span><br><span class="line"></span><br><span class="line">month(now())------获取当前时间的月份</span><br><span class="line"></span><br><span class="line">day(now())---------获取当前时间的日份</span><br><span class="line"></span><br><span class="line">hour(now())--------获取当前时间的时份</span><br><span class="line"></span><br><span class="line">minute(now())-----获取当前时间的分份</span><br><span class="line"></span><br><span class="line">second(now())-----获取当前时间的秒份</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">distinct</span>:去重</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> 字段名 <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span>条件：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名<span class="number">1</span> <span class="operator">=</span> 条件<span class="number">1</span> <span class="keyword">and</span> 字段名<span class="number">2</span> <span class="operator">=</span> 条件<span class="number">2</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名<span class="number">1</span> <span class="operator">=</span> 条件<span class="number">1</span> <span class="keyword">or</span> 字段名<span class="number">2</span> <span class="operator">=</span> 条件<span class="number">2</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">in</span> (条件<span class="number">1</span>,条件<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">模糊查询：<span class="keyword">like</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">LIKE</span> <span class="string">&#x27;%o%&#x27;</span>;#低效</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">LIKE</span> <span class="string">&#x27;o%&#x27;</span>;#最高效</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">LIKE</span> <span class="string">&#x27;%o&#x27;</span>;#高效</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">LIKE</span><span class="string">&#x27;l__&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span>操作空数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">IS</span> <span class="keyword">not</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">区间范围:between...and...是包含的关系</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 字段名 <span class="keyword">BETWEEN</span> <span class="number">3000</span> <span class="keyword">AND</span> <span class="number">10000</span>;#等效包含<span class="number">3000</span>、<span class="number">10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分页:limit</span><br><span class="line">#查询表中前两条信息</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename limit <span class="number">2</span>;</span><br><span class="line">#从第二行,展示两条信息</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename LIMIT <span class="number">1</span>,<span class="number">2</span>;  #从n<span class="operator">+</span><span class="number">1</span>行开始展示,要展示的行数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">排序:<span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">ORDER</span> <span class="keyword">BY</span>  字段名;#默认升序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tablename <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名 <span class="keyword">DESC</span>;#降序</span><br><span class="line"></span><br><span class="line">#查询的是数字<span class="comment">---按照数字排序</span></span><br><span class="line">#查询的是字母<span class="comment">---按照字母的顺序</span></span><br><span class="line">#查询的是生日<span class="comment">---按照数值排序</span></span><br><span class="line">#查询的是汉字<span class="comment">---按照汉字对应在utf8编码表中数字进行排序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查最大值：max</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(字段名)  <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">查最小值：min</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(字段名)  <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">查平均值：avg</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(字段名) 平均工资 <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">求和：sum</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(字段名) 求和 <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">统计个数count</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line">分组： <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">查询时，出现了混合列(聚合列跟非聚合列)的现象是不行的，必须分组</span><br><span class="line"></span><br><span class="line">#查询每个部门的最高薪<span class="comment">---部门编号deptno---薪水sal</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno, <span class="built_in">MAX</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line">#非聚合列,聚合列</span><br><span class="line"></span><br><span class="line"><span class="keyword">having</span>:完成分组后过滤</span><br><span class="line">#查询每个部门的人数，人数<span class="operator">&gt;</span><span class="number">1</span>的部门</span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="operator">&gt;</span><span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">开始事务</span><br><span class="line"><span class="keyword">start</span> transaction</span><br><span class="line"></span><br><span class="line">结束事务之提交事务</span><br><span class="line"><span class="keyword">commit</span></span><br><span class="line"></span><br><span class="line">结束事务之回滚事务</span><br><span class="line"><span class="keyword">rollback</span></span><br><span class="line"></span><br><span class="line">索引</span><br><span class="line">查看索引</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line">创建单值索引</span><br><span class="line"><span class="keyword">create</span> index indexname <span class="keyword">on</span> 表名(字段名);</span><br><span class="line"></span><br><span class="line">创建唯一索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index indexname <span class="keyword">on</span> tablename(字段名);</span><br><span class="line"></span><br><span class="line">创建复合索引</span><br><span class="line"><span class="keyword">create</span> index indexname <span class="keyword">on</span> tablename(字段名<span class="number">1</span>, 字段名<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">删除索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">drop</span> index indexname; </span><br><span class="line"></span><br><span class="line">使用普通索引，唯一索引</span><br><span class="line">explain<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename <span class="keyword">where</span> 字段名 <span class="operator">=</span> 字段值;</span><br><span class="line"></span><br><span class="line">使用复合索引</span><br><span class="line">explain<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename <span class="keyword">where</span> 字段名<span class="number">1</span> <span class="operator">=</span> 字段值  <span class="keyword">and</span> 字段名<span class="number">2</span> <span class="operator">=</span> 字段值;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多表联查"><a href="#多表联查" class="headerlink" title="多表联查"></a>多表联查</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tablename1,tablename2 </span><br><span class="line">where tablename1.字段名 = tablename2.字段名#表关系</span><br><span class="line">                and tablename1.字段名2 = 字段值;#业务关系</span><br><span class="line"></span><br><span class="line">连接查询</span><br><span class="line">内连接-----inner join: 取两个表的交集</span><br><span class="line"></span><br><span class="line">SELECT * FROM tablename1 INNER JOIN tablename2 </span><br><span class="line">ON  tablename1.`deptno` = tablename2.`deptno`#表关系</span><br><span class="line">where tablename1.字段名2 = 字段值;#业务关系</span><br><span class="line"></span><br><span class="line">外左连接-----left join :左表的所有和右表满足条件的，不满足是null</span><br><span class="line">SELECT * FROM tablename1 left JOIN tablename2 </span><br><span class="line">ON  tablename1.`deptno` = tablename2.`deptno`#表关系</span><br><span class="line">where tablename1.字段名1 = 字段值;#业务关系</span><br><span class="line"></span><br><span class="line">外右连接-----right join :右表的所有和左表满足条件的，不满足是null</span><br><span class="line">SELECT * FROM tablename1 right JOIN tablename2 </span><br><span class="line">ON  tablename1.`deptno` = tablename2.`deptno`#表关系</span><br><span class="line">where tablename1.字段名2 = 字段值;#业务关系</span><br><span class="line"></span><br><span class="line">子查询</span><br><span class="line">SELECT * FROM tablename1 WHERE 字段名1 IN (SELECT 字段名1 FROM tablename2 WHERE 字段名2 = &#x27;字段值&#x27;);</span><br><span class="line"></span><br><span class="line">视图</span><br><span class="line"></span><br><span class="line">创建视图</span><br><span class="line">create view view_name as SQL查询语句</span><br><span class="line">使用视图</span><br><span class="line">select * from view_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据库分页"><a href="#数据库分页" class="headerlink" title="数据库分页"></a>数据库分页</h2><p>在MySQL中，SELECT语句默认返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句，以实现分页查询。LIMIT子句的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 在所有的查询结果中，返回前5行记录。 </span><br><span class="line">SELECT prod_name FROM products LIMIT 5;</span><br><span class="line"></span><br><span class="line">-- 在所有的查询结果中，从第5行开始，返回5行记录。 </span><br><span class="line">SELECT prod_name FROM products LIMIT 5,5;</span><br><span class="line"></span><br><span class="line">总之，带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。</span><br></pre></td></tr></table></figure><p>在偏移量非常大的时候，例如 LIMIT 10000,20 这样的查询，这时MySQL需要查询10020条记录然后只返回最后20条，前面的10000条记录都将被抛弃，这样的代价是非常高的。如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。</p><p>优化此类分页查询的一个最简单的办法就是尽可能地使用<strong>索引覆盖扫描</strong>，*<em>而不是查询所有的列</em>***，然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候，这样做的效率会提升非常大。考虑下面的查询：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT film_id,description FROM sakila.film ORDER BY title LIMIT 50,5;</span><br></pre></td></tr></table></figure><p>如果这个表非常大，那么这个查询最好改写成下面的样子：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id,film.description  <span class="keyword">FROM</span> sakila.film <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (  <span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> sakila.film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">50</span>,<span class="number">5</span> ) <span class="keyword">AS</span> lim <span class="keyword">USING</span>(film_id);</span><br></pre></td></tr></table></figure><p><strong>这里的“延迟关联”将大大提升查询效率，它让MySQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用于优化关联查询中的LIMIT子句。</strong></p><p>有时候也可以将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得对应的结果。例如，如果在一个位置列上有索引，并且预先计算出了边界值，上面的查询就可以改写为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT film_id,description FROM skila.film WHERE position BETWEEN 50 AND 54 ORDER BY position;</span><br></pre></td></tr></table></figure><p>对数据进行排名的问题也与此类似，但往往还会同时和GROUP BY混合使用，在这种情况下通常都需要预先计算并存储排名信息。</p><p>LIMIT和OFFSET的问题，其实是OFFSET的问题，它<strong>会导致MySQL扫描大量不需要的行然后再抛弃掉。如果可以使用书签记录上次取数的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET</strong>。例如，若需要按照租赁记录做翻页，那么可以根据最新一条租赁记录向后追溯，这种做法可行是因为租赁记录的主键是单调增长的。首先使用下面的查询获得第一组结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM sakila.rental ORDER BY rental_id DESC LIMIT 20;</span><br></pre></td></tr></table></figure><p>假设上面的查询返回的是主键16049到16030的租赁记录，那么下一页查询就可以从16030这个点开始：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM sakila.rental  WHERE rental_id &lt; 16030 ORDER BY rental_id DESC LIMIT 20;</span><br></pre></td></tr></table></figure><p>该技术的好处是无论翻页到多么后面，其性能都会很好。</p><h2 id="介绍一下SQL中的聚合函数"><a href="#介绍一下SQL中的聚合函数" class="headerlink" title="介绍一下SQL中的聚合函数"></a>介绍一下SQL中的聚合函数</h2><p><strong>参考答案</strong></p><p>常用的聚合函数有COUNT()、AVG()、SUM()、MAX()、MIN()，下面以MySQL为例，说明这些函数的作用。</p><p>COUNT()函数：</p><p>COUNT()函数统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数，它有两种用法：</p><ul><li>COUNT(*)计算表中总的行数，不管某列是否有数值或者为空值。</li><li>COUNT(字段名)计算指定列下总的行数，计算时将忽略空值的行。</li></ul><p>COUNT()函数可以与GROUP BY一起使用来计算每个分组的总和。</p><p>AVG()函数()：</p><p>AVG()函数通过计算返回的行数和每一行数据的和，求得指定列数据的平均值。</p><p>AVG()函数可以与GROUP BY一起使用，来计算每个分组的平均值。</p><p>SUM()函数：</p><p>SUM()是一个求总和的函数，返回指定列值的总和。</p><p>SUM()可以与GROUP BY一起使用，来计算每个分组的总和。</p><p>MAX()函数：</p><p>MAX()返回指定列中的最大值。</p><p>MAX()也可以和GROUP BY关键字一起使用，求每个分组中的最大值。</p><p><strong>MAX()函数不仅适用于查找数值类型，也可应用于字符类型。</strong></p><p>MIN()函数：</p><p>MIN()返回查询列中的最小值。</p><p>MIN()也可以和GROUP BY关键字一起使用，求出每个分组中的最小值。</p><p>MIN()函数与MAX()函数类似，不仅适用于查找数值类型，也可应用于字符类型。</p><h2 id="表跟表是怎么关联的？"><a href="#表跟表是怎么关联的？" class="headerlink" title="表跟表是怎么关联的？"></a>表跟表是怎么关联的？</h2><p><strong>参考答案</strong></p><p>表与表之间常用的关联方式有两种：内连接、外连接，下面以MySQL为例来说明这两种连接方式。</p><p>内连接：</p><p>内连接通过INNER JOIN来实现，<strong>它将返回两张表中满足连接条件的数据，不满足条件的数据不会查询出来。</strong></p><p>外连接：</p><p>外连接通过OUTER JOIN来实现，<strong>它会返回两张表中满足连接条件的数据，同时返回不满足连接条件的数据</strong>。<strong>外连接有两种形式：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）</strong>。</p><ul><li>左外连接：可以简称为左连接（LEFT JOIN），<strong>它会返回左表中的所有记录和右表中满足连接条件的记录。</strong></li><li>右外连接：可以简称为右连接（RIGHT JOIN）<strong>，它会返回右表中的所有记录和左表中满足连接条件的记录。</strong></li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SELECT &lt;字段名&gt; </span><br><span class="line">FROM &lt;表a&gt; </span><br><span class="line">JOIN &lt;表b&gt; </span><br><span class="line">ON a.&lt;字段名&gt; = b.&lt;字段名&gt; ;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Students AS s</span><br><span class="line">JOIN Teachers AS t</span><br><span class="line">ON s.Tid = t.Tid</span><br><span class="line"></span><br><span class="line">使用USING</span><br><span class="line">SELECT film.film_id, film.description</span><br><span class="line">FROM sakila.film</span><br><span class="line">INNER JOIN (</span><br><span class="line">    -- 子查询，获取前50部电影的 film_id</span><br><span class="line">    SELECT film_id</span><br><span class="line">    FROM sakila.film</span><br><span class="line">    ORDER BY title</span><br><span class="line">    LIMIT 50, 5</span><br><span class="line">) AS lim</span><br><span class="line">USING (film_id);</span><br><span class="line"></span><br><span class="line">使用on</span><br><span class="line">SELECT film.film_id, film.description</span><br><span class="line">FROM sakila.film</span><br><span class="line">INNER JOIN (</span><br><span class="line">    -- 子查询，获取前50部电影的 film_id</span><br><span class="line">    SELECT film_id</span><br><span class="line">    FROM sakila.film</span><br><span class="line">    ORDER BY title</span><br><span class="line">    LIMIT 50, 5</span><br><span class="line">) AS lim</span><br><span class="line">ON film.film_id = lim.film_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除此之外，还有一种常见的连接方式：<strong>等值连接</strong>。这种连接是通过<strong>WHERE子句中的条件</strong>，将两张表连接在一起，<strong>它的实际效果等同于内连接</strong>。出于语义清晰的考虑，一般更建议使用内连接，而不是等值连接。</p><p>以上是从语法上来说明表与表之间关联的实现方式，而从表的关系上来说，比较常见的关联关系有：一对多关联、多对多关联、自关联。</p><ul><li><strong>一对多关联：这种关联形式最为常见，一般是两张表具有主从关系</strong>，并且以主表的主键关联从表的外键来实现这种关联关系。另外，以从表的角度来看，它们是具有多对一关系的，所以不再赘述多对一关联了。</li><li><strong>多对多关联：这种关联关系比较复杂，如果两张表具有多对多的关系，那么它们之间需要有一张中间表来作为衔接，以实现这种关联关系</strong>。这个中间表要设计两列，分别存储那两张表的主键。因此，这两张表中的任何一方，都与中间表形成了一对多关系，从而在这个中间表上建立起了多对多关系。</li><li><strong>自关联：自关联就是一张表自己与自己相关联，为了避免表名的冲突，需要在关联时通过别名将它们当做两张表来看待</strong>。一般在表中数据具有层级（树状）时，可以采用自关联一次性查询出多层级的数据。</li></ul><h2 id="SQL中怎么将行转成列？"><a href="#SQL中怎么将行转成列？" class="headerlink" title="SQL中怎么将行转成列？"></a>SQL中怎么将行转成列？</h2><p>在 SQL 中，将行转换为列的操作称为数据透视（Pivot）</p><p><strong>1. 使用 CASE 表达式：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> category <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">THEN</span> <span class="keyword">value</span> <span class="keyword">END</span>) <span class="keyword">AS</span> value_A,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> category <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span> <span class="keyword">THEN</span> <span class="keyword">value</span> <span class="keyword">END</span>) <span class="keyword">AS</span> value_B,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> category <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span> <span class="keyword">THEN</span> <span class="keyword">value</span> <span class="keyword">END</span>) <span class="keyword">AS</span> value_C</span><br><span class="line"><span class="keyword">FROM</span> your_table;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>category</code> 是一个列，<code>value</code> 是另一个列。我们使用 <code>CASE</code> 表达式将不同的 <code>category</code> 对应的 <code>value</code> 放在不同的列中，然后使用聚合函数（这里用的是 <code>MAX</code>）来获取每个列的值</p><p> 2.<strong>使用 PIVOT：</strong></p><p>某些数据库系统（如 SQL Server 和 Oracle）提供了 <code>PIVOT</code> 关键字，用于更方便地执行数据透视操作。示例如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> your_table</span><br><span class="line">PIVOT (</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">value</span>) <span class="keyword">FOR</span> category <span class="keyword">IN</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">) <span class="keyword">AS</span> pivot_table;</span><br></pre></td></tr></table></figure><p>这里，<code>category</code> 列的值 (‘A’, ‘B’, ‘C’) 将会成为新表的列名，对应的 <code>value</code> 列的值将填充到相应的列中。</p><p>首先，假设我们有一张分数表（tb_score），表中的数据如下图：</p><p><img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789565340/54AFB38EE7925F020B8244A971AD0197" alt="img"></p><p>然后，我们再来看一下转换之后需要得到的结果，如下图：</p><p><img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789578254/4D7E0B1F85854406C0011E8D87BD5BBB" alt="img"></p><ol><li><p>使用 CASE…WHEN…THEN 语句实现行转列，参考如下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT userid, </span><br><span class="line">SUM(CASE `subject` WHEN &#x27;语文&#x27; THEN score ELSE 0 END) as &#x27;语文&#x27;, </span><br><span class="line">SUM(CASE `subject` WHEN &#x27;数学&#x27; THEN score ELSE 0 END) as &#x27;数学&#x27;, </span><br><span class="line">SUM(CASE `subject` WHEN &#x27;英语&#x27; THEN score ELSE 0 END) as &#x27;英语&#x27;, </span><br><span class="line">SUM(CASE `subject` WHEN &#x27;政治&#x27; THEN score ELSE 0 END) as &#x27;政治&#x27;  </span><br><span class="line">FROM tb_score  </span><br><span class="line">GROUP BY userid</span><br></pre></td></tr></table></figure><p>注意，SUM() 是为了能够使用GROUP BY根据userid进行分组，因为每一个userid对应的subject&#x3D;”语文”的记录只有一条，所以SUM() 的值就等于对应那一条记录的score的值。假如userid &#x3D;’001’ and subject&#x3D;’语文’ 的记录有两条，<strong>则此时SUM() 的值将会是这两条记录的和</strong>，同理，<strong>使用Max()的值将会是这两条记录里面值最大的一个</strong>。但是正常情况下，一个user对应一个subject只有一个分数，<strong>因此可以使用SUM()、MAX()、MIN()、AVG()等聚合函数都可以达到行转列的效果</strong>。</p></li><li><p>使用 IF() 函数实现行转列，参考如下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT userid, SUM(IF(`subject`=&#x27;语文&#x27;,score,0)) as &#x27;语文&#x27;, SUM(IF(`subject`=&#x27;数学&#x27;,score,0)) as &#x27;数学&#x27;, SUM(IF(`subject`=&#x27;英语&#x27;,score,0)) as &#x27;英语&#x27;, SUM(IF(`subject`=&#x27;政治&#x27;,score,0)) as &#x27;政治&#x27;  FROM tb_score  GROUP BY userid</span><br></pre></td></tr></table></figure><p>注意，IF(subject&#x3D;’语文’,score,0) 作为条件，即对所有subject&#x3D;’语文’的记录的score字段进行SUM()、MAX()、MIN()、AVG()操作，如果score没有值则默认为0。</p></li></ol><h2 id="谈谈你对SQL注入的理解"><a href="#谈谈你对SQL注入的理解" class="headerlink" title="谈谈你对SQL注入的理解"></a>谈谈你对SQL注入的理解</h2><p><strong>SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，在一些对SERVER端发起的请求参数中植入一些SQL代码，SERVER端在执行SQL操作时，会拼接对应参数，同时也将一些SQL注入攻击的“SQL”拼接起来，导致会执行一些预期之外的操作。</strong></p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE username = &#x27;ls&#x27; AND password = &#x27;123456&#x27;</span><br></pre></td></tr></table></figure><p><strong>SQL中会将#及–以后的字符串当做注释处理</strong>，如果我们使用 ‘ or 1&#x3D;1 # 作为用户名参数，那么服务端构建的SQL语句就如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where username=&#x27;&#x27; or 1=1 #&#x27; and password=&#x27;123456&#x27;</span><br></pre></td></tr></table></figure><p><strong>而#会忽略后面的语句，而1&#x3D;1属于常等型条件</strong>，因此这个SQL将查询出所有的登录用户。其实上面的SQL注入只是在参数层面做了些手脚，如果是引入了一些功能性的SQL那就更危险了，比如上面的登录功能，如果用户名使用这个 ‘ or 1&#x3D;1;delete * from users; #，那么在”;”之后相当于是另外一条新的SQL，这个SQL是删除全表，是非常危险的操作，因此SQL注入这种还是需要特别注意的。</p><p>如何解决SQL注入</p><ol><li><p>SQL预编译</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span></span><br><span class="line"><span class="keyword">with</span> sqlite3.connect(<span class="string">&quot;mydb.db&quot;</span>) <span class="keyword">as</span> connection:</span><br><span class="line">    cursor = connection.cursor()</span><br><span class="line">    cursor.execute(sql, (enteredUsername, enteredPassword))</span><br><span class="line">    results = cursor.fetchall()</span><br></pre></td></tr></table></figure><p><strong>将查询与参数分开，确保输入的参数值不会被解释为 SQL 代码的一部分，不仅提升性能，而且防止SQL注入</strong>。</p></li><li><p><strong>使用参数化查询</strong>：使用数据库驱动或框架提供的参数化查询机制，将用户输入作为参数传递给查询，而不是将其拼接到查询字符串中。</p></li><li><p><strong>数据验证和过滤</strong>：对用户输入进行严格的验证和过滤，确保只接受预期的数据类型和格式。</p></li><li><p><strong>转义字符</strong>：对输入进行适当的字符转义，以防止特殊字符被误解为 SQL 代码。</p></li><li><p><strong>最小权限原则</strong>：在数据库配置中，为应用程序使用的数据库账户分配最小必要的权限，避免攻击者通过注入攻击访问不应该访问的数据。</p></li><li><p><strong>定期更新和维护</strong>：保持数据库引擎和应用程序库的更新，以获取最新的安全性修复。</p></li><li><p><strong>安全开发实践</strong>：开发人员需要了解并遵循安全的编程实践，以最大程度地减少安全漏洞。</p></li></ol><h2 id="将一张表的部分数据更新到另一张表，该如何操作呢？"><a href="#将一张表的部分数据更新到另一张表，该如何操作呢？" class="headerlink" title="将一张表的部分数据更新到另一张表，该如何操作呢？"></a>将一张表的部分数据更新到另一张表，该如何操作呢？</h2><p><strong>参考答案</strong></p><p>可以采用关联更新的方式，将一张表的部分数据，更新到另一张表内。参考如下代码：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> target_table <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">JOIN</span> source_table <span class="keyword">AS</span> s <span class="keyword">ON</span> t.id <span class="operator">=</span> s.id</span><br><span class="line"><span class="keyword">SET</span> t.name <span class="operator">=</span> s.name, t.age <span class="operator">=</span> s.age</span><br><span class="line"><span class="keyword">WHERE</span> t.id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> 语句来将 source_table 中 id 为 <span class="number">2</span> 的行的数据更新到 target_table 中。我们使用 <span class="keyword">JOIN</span> 子句来关联两个表，然后使用 <span class="keyword">SET</span> 子句指定要更新的列和更新值。最后，使用 <span class="keyword">WHERE</span> 子句来指定更新的条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> b <span class="keyword">set</span> b.col<span class="operator">=</span>a.col <span class="keyword">from</span> a,b <span class="keyword">where</span> a.id<span class="operator">=</span>b.id;</span><br><span class="line"><span class="keyword">update</span> b <span class="keyword">set</span> col<span class="operator">=</span>a.col <span class="keyword">from</span> b <span class="keyword">inner</span> <span class="keyword">join</span> a <span class="keyword">on</span> a.id<span class="operator">=</span>b.id;</span><br><span class="line"><span class="keyword">update</span> b <span class="keyword">set</span> b.col<span class="operator">=</span>a.col <span class="keyword">from</span> b <span class="keyword">left</span> <span class="keyword">Join</span> a <span class="keyword">on</span> b.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><h2 id="WHERE和HAVING有什么区别？"><a href="#WHERE和HAVING有什么区别？" class="headerlink" title="WHERE和HAVING有什么区别？"></a>WHERE和HAVING有什么区别？</h2><p><strong>参考答案</strong></p><p>WHERE是一个<strong>约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数。</strong></p><p>HAVING是一个<strong>过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在HAVING中可以使用聚合函数</strong>。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。</p><p>从性能的角度来说，<strong>HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。</strong> <code>HAVING</code> 子句只能在 <code>SELECT</code> 查询中使用。</p><h2 id="说一说你对MySQL索引的理解"><a href="#说一说你对MySQL索引的理解" class="headerlink" title="说一说你对MySQL索引的理解"></a>说一说你对MySQL索引的理解</h2><p><strong>索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针</strong>。使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，<strong>对相关列使用索引是提高查询操作速度的最佳途径。</strong></p><p>索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY&#x2F;HEAP存储引擎可以支持HASH和BTREE索引。</p><p>索引的优点主要有以下几条：</p><ol><li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li><li>可<strong>以大大加快数据的查询速度，这也是创建索引的主要原因。</strong></li><li><strong>在实现数据的参考完整性方面，可以加速表和表之间的连接。</strong></li><li><strong>在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。</strong></li></ol><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p><ol><li><strong>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。</strong></li><li><strong>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。</strong></li><li><strong>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</strong></li></ol><h2 id="索引有哪几种？"><a href="#索引有哪几种？" class="headerlink" title="索引有哪几种？"></a>索引有哪几种？</h2><p><strong>参考答案</strong></p><p>MySQL的索引可以分为以下几类：</p><ol><li><p><strong>普通索引和唯一索引</strong></p><p><strong>普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。</strong></p><p><strong>唯一索引要求索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</strong></p><p>主键索引是一种特殊的唯一索引，不允许有空值。</p></li><li><p>单列索引和组合索引</p><p>单列索引即一个索引只包含单个列，一个表可以有多个单列索引。</p><p>组合索引是指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。<strong>使用组合索引时遵循最左前缀集合。</strong></p></li><li><p>全文索引</p><p>全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。</p></li><li><p>空间索引</p><p>空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MyISAM的表中创建。</p></li></ol><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong></li></ul><h3 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h3><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p><p>这两个区别在前面也提到了：</p><ul><li>主<strong>键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</strong></li><li><strong>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</strong></li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就<strong>不需要回表，这个过程就是覆盖索引</strong>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p><h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，<strong>一张表最多只有一个主键索引，索引列的值不允许有空值</strong>。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一索引建立在 <strong>UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</strong></p><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><h3 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h3><p>从字段个数的角度来看，索引分为<strong>单列索引、联合索引</strong>（复合索引）。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引；</li><li>建立在多列上的索引称为联合索引；</li></ul><h2 id="如何判断数据库的索引有没有生效？"><a href="#如何判断数据库的索引有没有生效？" class="headerlink" title="如何判断数据库的索引有没有生效？"></a>如何判断数据库的索引有没有生效？</h2><p>可以使用EXPLAIN语句查看索引是否正在使用。</p><p>举例，假设已经创建了book表，并已经在其year_publication字段上建立了普通索引。执行如下语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM book WHERE year_publication=1990;</span><br><span class="line"></span><br><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure><p>EXPLAIN语句将为我们输出详细的SQL执行信息，其中：</p><ul><li><strong>possible_keys</strong>行给出了MySQL在搜索数据记录时可选用的各个索引。</li><li><strong>key行是MySQL实际选用的索引</strong>。</li></ul><p><strong>如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。</strong></p><h2 id="如何评估一个索引创建的是否合理？"><a href="#如何评估一个索引创建的是否合理？" class="headerlink" title="如何评估一个索引创建的是否合理？"></a>如何评估一个索引创建的是否合理？</h2><p>建议按照如下的原则来设计索引：</p><ol><li><p><strong>避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。应该经常用于查询的字段创建索引，但要避免添加不必要的字段。</strong></p></li><li><p><strong>数据量小的表最好不要使用索引</strong>，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p></li><li><p>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引，如果建立索引不但不会提高查询效率，反而会严重降低数据更新速度。</p></li><li><p>当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。</p></li><li><p>在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。</p></li><li><p>数据库事务 ：数据库中一组原子性的SQL操作，彼此状态一致。具有ACID特性。</p></li><li><p>事务 ACID 特性：</p><ul><li>原子性：数据库事务是一个整体，其中的SQL操作要么全部提交成功commit要么全部失败回滚rollback，不可分割；</li><li>一致性：与原子性有联系。事务总是从一个一致状态转换到另一个一致状态；</li><li>隔离性：事务之间彼此互不影响，一个事务在提交之前，对其他事务是不可见的。</li><li>持久性：一个事务一旦提交成功，他所做的修改就会永久性的存储在数据库中。</li></ul></li><li><p>MySQL 4 种隔离级别</p><ul><li>未提交读READ UNCOMMITTED：一个事务在提交之前，对其他事务是可见的，即事务可以读取未提交的数据。存在“脏读”（读到了脏数据）问题；</li><li>提交读READ COMMITTED：事务在提交之前，对其它事务是不可见的。存在“不可重复读”（两次查询的得到的结果可能不同，即可能在查询的间隙，有事务提交了修改）问题。解决了“脏读”问题。</li><li>可重复读REPEATABLE READ：在同一事务中多次读取的数据是一致的。解决了脏读和不可重复读问题，存在“幻读”（在事务两次查询间隙，有其他事务又插入或删除了新的记录）。— MySQL默认隔离级别。</li><li>可串行化SERIALIZABLE：强制事务串行化执行。即一个事物一个事物挨个来执行，可以解决上述所有问题。</li></ul></li><li><p>锁及粒度：</p><ul><li>共享锁&#x2F;读锁：互不阻塞，优先级低</li><li>排他锁&#x2F;写锁：阻塞其他锁，优先级高，即确保在一个事务写入时不受其他事务的影响。</li><li>锁粒度：锁定的数据量越少（粒度越小），并发程度越高，但相应的加锁、检测锁、释放锁用的系统开销也随之增大。</li><li>锁策略：锁开销与数据安全性之间的平衡<ul><li>表锁：锁住整张表，读锁互不阻塞，写锁阻塞其他所有读写锁（同一张表）。开销最小。</li><li>行级锁：对每一行数据（记录）加锁，开销大，并发程度高。</li></ul></li></ul></li><li><p>InnoDB对死锁的处理：此处死锁与OS死锁类似，多个事务互相持有对方所有要申请资源的锁不释放，造成环路死锁。MySQL InnoDB引擎检测到死锁循环依赖后，回滚持有最少行级锁的事务。</p></li><li><p>索引及其作用和实现方法：</p><ul><li>概念：对数据库表列进行增加恰当索引，可以快速的找到匹配的记录行数，相比于默认的全表扫描，可以大大加快查找的速度。</li><li>作用：加快查找速度；</li><li>实现方法：一般分为B+树索引和哈希索引。<ul><li>B+树索引：在B-tree上改进得到，其非叶子节点均为key值，叶子节点是key-data键值对。叶子节点前后相连且有序。</li><li>哈希索引：通过对key进行hash(crc&#x2F;MD5&#x2F;sha1&#x2F;sha256…)而将记录存储在不同的bucket种，可以做到常数时间的查找，但要注意哈希冲突的避免（链表法、线性探测、二次探测、公共溢出区的方法）。其中MD5 128位，和sha1&#x2F;256码都较长不太适合作为hash函数。默认无序。</li><li>为什么有了B+树索引还要hash索引？<ol><li>B+树默认有序，hash默认无序，所以哈希索引无法用于排序；</li><li>哈希索引O(1)在速度上毋庸置疑要快于B+树近似O(logn);</li><li>哈希索引只能进行等值查询（因为他要计算hash(key)再去匹配）而B+树索引可以进行等值、部分前缀、范围查询；</li><li>底层实现结构不同：B+树是非线性结构，hash桶是线性结构。</li><li>对于某些场景如热点页&#x2F;活跃查询页，需要借助哈希索引来实现快速查询。</li></ol></li></ul></li><li>索引越多越快？<br>此言差矣，索引并非是虚无缥缈的，是实实在在的一种数据结构（B+树&#x2F;hash桶）要占内存、维护它要系统开销，一般的插入删除都要进行结构的调整，这要消耗时间，所以索引太多反而拖慢查找时间。有时候，见数据量不多时，建立索引还不如全表查询。索引加快了检索的速度，但是插入删除修改都需要DBMS动态更新内部索引结构，要耗费开销。</li></ul></li><li><p>InnoDB MVCC</p></li><li><p>MVCC 的核心思想是在数据库中为<strong>每个事务创建一个独立的“版本”，这个版本包含了在该事务开始时数据库中的数据快照。每个事务都只能看到自己开始时的数据快照，而不受其他事务的影响。这种机制避免了读-写冲突以及脏读等并发问题。</strong></p></li><li><p><strong>多版本并发控制</strong>，是为了避免加锁而实现的。一般的实现方法是存储快照来实现的。InnoDB实现方式是在记录后添加两个隐藏列（表项），分别是事务创建时间、过期时间，存储的实际上是系统版本号（系统版本号随着事务的创建而递增）。<br>这样一来，INSERT 时加上开始版本号，UPDATE&#x2F;DELETE时加上过期版本号，这样一来在SELETE时，就只访问开始系统版本号小于当前的事务的版本号、过期时间要么未定义要么在当前版本号之后的记录，这样就可以保证：访问的记录是在本事务开始前就存在而且在本事务期间没有过期（被删除或被修改过的）。可以避免脏读、不可重复读、幻读的问题。（个人觉得）</p></li><li><p>MySQL存储引擎简介</p></li></ol><ul><li><p>InnoDB,最为通用&#x2F;推荐的一种引擎，支持事务、行级锁、甚至间隙锁（避免幻读）、支持热备份，MVCC，在并发上占优势，系统资源占用多。</p></li><li><p>MyISAM,默认的存储引擎，不支持事务和行级锁，只支持表锁，某些场景性能很好：占用存储上优，查询速度上完胜（大概是InnoDB的3倍）系统资源占用少。</p></li><li><p>InnoDB支持事务, MyISAM不支持；</p></li><li><p>InnoDB支持行级锁、表锁；MyISAM只支持表锁；</p></li><li><p>InnoDB支持MVCC，MyISAM不支持；</p></li><li><p>InnoDB不支持全文索引，MyISAM支持；</p></li><li><p>InnoDB支持外键，MyISAM不支持外键；</p></li><li><p>InnoDB和MyISAM都支持B+树索引，InnoDB还支持自适应哈希索引</p></li><li><p>MyISAM实现了前缀压缩技术，占用存储空间更小（但会影响查找），InnoDB是原始数据存储，占用存储更大。</p><p>PS：大部分情况下，InnoDB都是正确的选择。—《高性能MySQL》</p></li></ul><ol start="11"><li><p>SQL优化</p><ul><li>在经常性的检索列上，建立必要索引，以加快搜索速率，避免全表扫描（索引覆盖扫描）；</li><li>多次查询同样的数据，可以考虑缓存该组数据；</li><li>审视select * form tables, 你需要所有列数据吗？</li><li>切分查询（大查询切分成为小查询，避免一次性锁住大量数据）</li><li>分解关联查询（单表查询，结果在应用程序中进行关联，可以减少处理过程中的锁争用）</li><li>尽量先做单表查询；</li><li>…</li></ul></li><li><p>profile 的作用和用法<br>用于保存SQL语句执行状态，需要手动开启，才可以查看。</p><blockquote><p>set profiling &#x3D; 1; 开启<br>show profiles; 显示SQL查询的profiles概况<br>show profile all for query X; 查看第X条语句的所有执行情况。<br>show profile cpu, block io, memory for query X; 查看部分profile信息。<br><img src="https://uploadfiles.nowcoder.com/files/20190731/9084855_1564581954903_1027722-20190731141049676-1016503398.png" alt="img"></p></blockquote></li><li><p>MySQL查询的步骤</p><ul><li>客户端发送查询到服务器；</li><li>服务器检查查询缓存query ***（大小写敏感的哈希查找，常数时间）。如果命中，返回缓存中的结果，否则下一步；</li><li>解析语句，生成执行计划；（SQL解析，预处理，优化器生成执行计划）；</li><li>根据执行计划，根据存储引擎的不同调用API，执行查询（一棵指令树）；</li><li>结果返回客户端。</li></ul></li></ol><h2 id="为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？"><a href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？" class="headerlink" title="为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？"></a>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</h2><p><em><strong>B+Tree vs B Tree</strong></em></p><p><strong>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</strong></p><p><strong>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</strong></p><p><em><strong>2、B+Tree vs 二叉树</strong></em></p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作**只需要做 3</del>4 次的磁盘 I&#x2F;O 操作就能查询到目标数据**。</p><p>而<strong>二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多</strong>。</p><p><em><strong>3、B+Tree vs Hash</strong></em></p><p><strong>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</strong></p><p><strong>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因</strong></p><h3 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h3><p>用上了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的。</p><p>我之前写过索引失效的文章，想详细了解的可以去看这篇文章：<a href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">谁还没碰过索引失效呢?(opens new window)</a></p><p>这里简单说一下，发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对<strong>索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效</strong>；</li><li>联合索引要能正确使用需要<strong>遵循最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li><strong>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效</strong>。</li></ul><p>这次主要介绍了索引的原理、分类和使用。我把重点总结在了下面这个表格</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png" alt="img"></p><h2 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h2><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，所以就跟大家图解下InnoDB 是如何存储数据的。</p><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p>数据库的 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><p><strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</p><p>数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</p><p>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</p><p>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</p><p>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。</p><ul><li>MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。</li><li>页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。</li><li>在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</li><li>索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能</li></ul><h2 id="索引失效有哪些"><a href="#索引失效有哪些" class="headerlink" title="索引失效有哪些"></a>索引失效有哪些</h2><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p><p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。在查询条件中对索引进行表达式计算，也是无法走索引的。</p><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p><p>这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="built_in">CAST</span>(phone <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p><p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配</p><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>今天给大家介绍了 6 种会发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h2 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><h2 id><a href="#" class="headerlink" title></a></h2><p><strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/af711033aa3423330d3a4bc6baeb9532.png" alt="图片"></p><p>**count(<code>*</code>) 其实等于 count(<code>0</code>)**，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理</p><p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p><p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p><p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略为NULL的值。</li><li>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略为NULL的值。</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是指空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><h2 id="如何优化-count-？"><a href="#如何优化-count-？" class="headerlink" title="如何优化 count(*)？"></a>如何优化 count(*)？</h2><h3 id="近似值"><a href="#近似值" class="headerlink" title="近似值"></a>近似值</h3><p>我们就可以使用 show table status 或者 explain 命令来表进行估算。</p><h3 id="额外表保存计数值"><a href="#额外表保存计数值" class="headerlink" title="额外表保存计数值"></a>额外表保存计数值</h3><p>如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p><p>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表</p><h2 id="执行一条-select-语句，期间发生了什么？"><a href="#执行一条-select-语句，期间发生了什么？" class="headerlink" title="执行一条 select 语句，期间发生了什么？"></a>执行一条 select 语句，期间发生了什么？</h2><p>先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><p>好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的。</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p><p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。</p><p>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p><p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。</p><h3 id="解析-SQL"><a href="#解析-SQL" class="headerlink" title="解析 SQL"></a>解析 SQL</h3><p>在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成</p><h3 id="执行-SQL"><a href="#执行-SQL" class="headerlink" title="执行 SQL"></a>执行 SQL</h3><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是预处理阶段；</li><li>optimize 阶段，也就是优化阶段；</li><li>execute 阶段，也就是执行阶段；</li></ul><h2 id="MySQL-一行记录是怎么存储的"><a href="#MySQL-一行记录是怎么存储的" class="headerlink" title="MySQL 一行记录是怎么存储的"></a>MySQL 一行记录是怎么存储的</h2><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li></ul><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p><h4 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合，之前讲<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离 (opens new window)</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li></ul><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong></p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li></ul><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p><blockquote><p>MySQL 的 NULL 值是怎么存放的？</p></blockquote><p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p><p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p><blockquote><p>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</p></blockquote><p>MySQL 的 Compact 行格式中会用「<strong>变长字段长度列表</strong>」存储变长字段实际占用的数据大小。</p><ul><li>如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；</li><li>条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；</li><li>我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」</li></ul><blockquote><p>varchar(n) 中 n 最大取值为多少？</p></blockquote><p>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p><p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p><p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 &#x3D; 65535 - 2 - 1 &#x3D; 65532。</p><p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535。</p><ul><li>在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532&#x2F;3 &#x3D; 21844。</li></ul><blockquote><p>行溢出后，MySQL 是怎么处理的？</p></blockquote><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，<strong>只存储 20 个字节的指针来指向溢出页</strong>。而实际的数据都存储在溢出页中。</p><h2 id="MySQL-有哪些锁"><a href="#MySQL-有哪些锁" class="headerlink" title="MySQL 有哪些锁"></a>MySQL 有哪些锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>在 MySQL 里，根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。</p><blockquote><p>全局锁是怎么用的？</p></blockquote><p>要使用全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul><p>如果要释放全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>当然，当会话断开了，全局锁会被自动释放。</p><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><blockquote><p>MySQL 表级锁有哪些？具体怎么用的。</p></blockquote><p>MySQL 里面表级别的锁有这几种：</p><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line">//表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br><span class="line"></span><br><span class="line">unlock tables</span><br></pre></td></tr></table></figure><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit &#x3D; 0。</p><h2 id="update-没加索引会锁全表？"><a href="#update-没加索引会锁全表？" class="headerlink" title="update 没加索引会锁全表？"></a>update 没加索引会锁全表？</h2><p><strong>当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的</strong>。另外，这<strong>个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放</strong>。</p><p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，<strong>锁是加在索引上的而非行上</strong>。</p><p>比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。</p><p>这里举个例子，这里有一张数据库表，其中 id 为主键索引。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/3c3af16e7a948833ccb6409e8b51daf8.png" alt="img"></p><p>假设有两个事务的执行顺序如下：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d2326f98cbb34fc09ca4013703251501.png" alt="在这里插入图片描述"></p><p>可以看到，事务 A 的 update 语句中 where 是等值查询，并且 id 是唯一索引，所以只会对 id &#x3D; 1 这条记录加锁，因此，事务 B 的更新操作并不会阻塞。</p><p>但是，<strong>在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</strong></p><p>假设有两个事务的执行顺序如下：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/1aa886fe95e7bc791c296e2d342fa435.png" alt="img"></p><p>可以看到，这次事务 B 的 update 语句被阻塞了。</p><p>这是<strong>因为事务 A的 update 语句中 where 条件没有索引列，触发了全表扫描，在扫描过程中会对索引加锁，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/63e055617720853f5b64c99576227c09.png" alt="img"></p><p>因此，当在数据量非常大的数据库表执行 update 语句时，如果没有使用索引，就会给全表的加上 next-key 锁， 那么锁就会持续很长一段时间，直到事务结束，而这期间除了 <code>select ... from</code>语句，其他语句都会被锁住不能执行，业务会因此停滞，接下来等着你的，就是老板的挨骂。</p><p>那 update 语句的 where 带上索引就能避免全表记录加锁了吗？</p><p>并不是。</p><p><strong>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了</strong>。</p><p>TIP</p><p>网上很多资料说，update 没加锁索引会加表锁，这是不对的。</p><p>Innodb 源码里面在扫描记录的时候，都是针对索引项这个单位去加锁的， update 不带索引就是全表扫扫描，也就是表里的索引项都加锁，相当于锁了整张表，所以大家误以为加了表锁。</p><h2 id="如何避免这种事故的发生？"><a href="#如何避免这种事故的发生？" class="headerlink" title="如何避免这种事故的发生？"></a>如何避免这种事故的发生？</h2><p>我们可以将 MySQL 里的 <code>sql_safe_updates</code> 参数设置为 1，开启安全更新模式。</p><p>大致的意思是，当 sql_safe_updates 设置为 1 时。</p><p>update 语句必须满足如下条件之一才能执行成功：</p><ul><li>使用 where，并且 where 条件中必须有索引列；</li><li>使用 limit；</li><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul><p>delete 语句必须满足以下条件能执行成功：</p><ul><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul><p>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</p><p><strong>当我们要执行 update 语句的时候，确保 where 条件中带上了索引列，并且在测试机确认该语句是否走的是索引扫描，防止因为扫描全表，而对表中的所有记录加上锁。</strong></p><p><strong>我们可以打开 MySQL sql_safe_updates 参数，这样可以预防 update 操作时 where 条件没有带上索引列</strong>。</p><p>如果发现即使在 where 条件中带上了列索引列，优化器走的还是全标扫描，这时我们就要使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引。</p><h2 id="为什么要有-Buffer-Pool？"><a href="#为什么要有-Buffer-Pool？" class="headerlink" title="为什么要有 Buffer Pool？"></a>为什么要有 Buffer Pool？</h2><p>虽然说 MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。</p><p>要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p><p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能</p><p>有了缓冲池后：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li></ul><h3 id="Buffer-Pool-有多大？"><a href="#Buffer-Pool-有多大？" class="headerlink" title="Buffer Pool 有多大？"></a>Buffer Pool 有多大？</h3><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> 。</p><p>可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。</p><h2 id="MySQL-日志：undo-log、redo-log、binlog-有什么用？"><a href="#MySQL-日志：undo-log、redo-log、binlog-有什么用？" class="headerlink" title="MySQL 日志：undo log、redo log、binlog 有什么用？"></a>MySQL 日志：undo log、redo log、binlog 有什么用？</h2><ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="回滚事务"></p><p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p><ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li></ul><p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p><ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul><li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li><li>至此，一条记录更新完了。</li><li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul><li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li><li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li></ul></li><li>至此，一条更新语句执行完成。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/anxiangblog.github.io/2023/10/09/Redis/"/>
      <url>/anxiangblog.github.io/2023/10/09/Redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p><p>Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p><p>除此之外，Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>等等</p><h3 id="Redis-和-Memcached-有什么区别？"><a href="#Redis-和-Memcached-有什么区别？" class="headerlink" title="Redis 和 Memcached 有什么区别？"></a>Redis 和 Memcached 有什么区别？</h3><p>很多人都说用 Redis 作为缓存，但是 Memcached 也是基于内存的数据库，为什么不选择它作为缓存呢？要解答这个问题，我们就要弄清楚 Redis 和 Memcached 的区别。 Redis 与 Memcached <strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p>Redis 与 Memcached <strong>区别</strong>：</p><ul><li>Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li><li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li><li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li><li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持</li></ul><h3 id="Redis-是单线程吗？"><a href="#Redis-是单线程吗？" class="headerlink" title="Redis 是单线程吗？"></a>Redis 是单线程吗？</h3><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p><p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p><ul><li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li><li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key &#x2F; flushdb async &#x2F; flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</li></ul><p>之所以 Redis 为「<strong>关闭文件、AOF 刷盘、释放内存</strong>」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p><h3 id="Redis-如何实现数据不丢失？"><a href="#Redis-如何实现数据不丢失？" class="headerlink" title="Redis 如何实现数据不丢失？"></a>Redis 如何实现数据不丢失？</h3><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p><p>Redis 共有三种数据持久化的方式：</p><ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点</li></ul><p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><h1 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h1><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong></p><h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p><strong>key value  SDS 简单动态字符串</strong></p><p>优点：</p><p>1.<strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong></p><p>​因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据</p><p>2.**SDS 获取字符串长度的时间复杂度是 O(1)**。</p><p>​因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</p><p>3.<strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。</p><p>​因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</p><p>普通字符串的基本操作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET name lin</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 key 获得对应的 value</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET name</span></span><br><span class="line">&quot;lin&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断某个 key 是否存在</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EXISTS name</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回 key 所储存的字符串值的长度</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">STRLEN name</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某个 key 对应的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DEL name</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>批量设置 :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">MSET key1 value1 key2 value2</span> </span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量获取多个 key 对应的 value</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">MGET key1 key2</span> </span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure><p>计数器（字符串的内容为整数的时候可以使用）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET number 0</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 key 中储存的数字值增一</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">INCR number      increase</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将key中存储的数字值加 10</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">INCRBY number 10</span>      </span><br><span class="line">(integer) 11</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 key 中储存的数字值减一</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DECR number</span></span><br><span class="line">(integer) 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将key中存储的数字值键 10</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DECRBY number 10</span></span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>过期（默认为永不过期）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 key 在 60 秒后过期（该方法是针对已经存在的key设置过期时间）</span></span><br><span class="line">&gt; EXPIRE name  60 </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">&gt; TTL name </span><br><span class="line">(<span class="built_in">integer</span>) 51</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置 key-value 类型的值，并设置该key的过期时间为 60 秒</span></span><br><span class="line">&gt; SET key  value EX 60</span><br><span class="line">OK</span><br><span class="line">&gt; SETEX key  60 value</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>不存在就插入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不存在就插入（not exists）</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">SETNX key value</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h4><p>使用 String 来缓存对象有两种方式：</p><ul><li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;</code>。</li><li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</li></ul><h4 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h4><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><h4 id="共享-Session-信息"><a href="#共享-Session-信息" class="headerlink" title="共享 Session 信息"></a>共享 Session 信息</h4><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p><p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。</p><p>分布式系统单独存储 Session 流程图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Session1.png" alt="img"></p><p>因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p><p>分布式系统使用同一个 Redis 存储 Session 流程图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Session2.png" alt="img"></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 列表是简单的字符串列表，<strong>按照插入顺序排序</strong>，可以从头部或尾部向 List 列表添加元素</p><p>列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 <code>40 亿</code>个元素</p><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/list.png" alt="img"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span></span><br><span class="line">LPUSH key value [value ...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表尾(最右边)</span></span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的头元素</span></span><br><span class="line">LPOP key     </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的尾元素</span></span><br><span class="line">RPOP key </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span></span><br><span class="line">LRANGE key start stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表头弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表尾弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p><p>Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法，后面在介绍 Stream 数据类型时候，在详细说说 Stream。</p><p><em>1、如何满足消息保序需求？</em></p><p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p><p><strong>List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/list%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="img"></p><ul><li>生产者使用 <code>LPUSH key value[value...]</code> 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</li><li>消费者使用 <code>RPOP key</code> 依次读取队列的消息，先进先出。</li></ul><p>不过，在消费者读取数据时，有一个潜在的性能风险点。</p><p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。</p><p>所以，即使没有新消息写入List，<strong>消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</strong></p><p>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="img"></p><p><em>2、如何处理重复的消息？</em></p><p>消费者要实现重复消息的判断，需要 2 个方面的要求：</p><ul><li><strong>每个消息都有一个全局的 ID</strong>。</li><li><strong>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</strong></li></ul><p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID</strong>，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p><p>例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 99 的消息插入了消息队列：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LPUSH mq <span class="string">&quot;111000102:stock:99&quot;</span></span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><em>3、如何保证消息可靠性？</em></p><p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p><p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</p><p>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p><p>好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（<strong>消息保序、处理重复的消息和保证消息可靠性</strong>）。</p><ul><li>消息保序：使用 LPUSH + RPOP；</li><li>阻塞读取：使用 BRPOP；</li><li>重复消息处理：生产者自行实现全局唯一 ID；</li><li>消息的可靠性：使用 BRPOPLPUSH</li></ul><blockquote><p>List 作为消息队列有什么缺陷？</p></blockquote><p><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。</p><p>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。</p><p>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash 是一个键值对（key - value）集合，其中 value 的形式如： <code>value=[&#123;field1，value1&#125;，...&#123;fieldN，valueN&#125;]</code>。Hash 特别适合用于存储对象。</p><p>Hash 与 String 对象的区别如下图所示:</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/hash.png" alt="img"></p><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构</li></ul><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储一个哈希表key的键值</span></span><br><span class="line">HSET key field value   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表key对应的field键值</span></span><br><span class="line">HGET key field</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在一个哈希表key中存储多个键值对</span></span><br><span class="line">HMSET key field value [field value...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量获取哈希表key中多个field键值</span></span><br><span class="line">HMGET key field [field ...]       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除哈希表key中的field键值</span></span><br><span class="line">HDEL key field [field ...]    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中field的数量</span></span><br><span class="line">HLEN key       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中所有的键值</span></span><br><span class="line">HGETALL key </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为哈希表key中field键的值加上增量n</span></span><br><span class="line">HINCRBY key field n    </span><br></pre></td></tr></table></figure><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="缓存对象-1"><a href="#缓存对象-1" class="headerlink" title="缓存对象"></a>缓存对象</h4><p>Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</p><p>一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</strong></p><p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><p>Set 类型和 List 类型的区别如下：</p><ul><li>List 可以存储重复元素，Set 只能存储非重复元素；</li><li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。</li></ul><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><p>Set常用操作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往集合key中存入元素，元素存在则忽略，若key不存在则新建</span></span><br><span class="line">SADD key member [member ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中删除元素</span></span><br><span class="line">SREM key member [member ...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取集合key中所有元素</span></span><br><span class="line">SMEMBERS key</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取集合key中的元素个数</span></span><br><span class="line">SCARD key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断member元素是否存在于集合key中</span></span><br><span class="line">SISMEMBER key member</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素不从key中删除</span></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素从key中删除</span></span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure><p>Set运算操作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交集运算</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将交集结果存入新集合destination中</span></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并集运算</span></span><br><span class="line">SUNION key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将并集结果存入新集合destination中</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">差集运算</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将差集结果存入新集合destination中</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p><p>因此 Set 类型比较适合用来<strong>数据去重和保障数据的唯一性</strong>，还可以用来<strong>统计多个集合的交集、错集和并集</strong>等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p><p>但是要提醒你一下，这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p><p><strong>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</strong></p><h4 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h4><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p><p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:1 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:2 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:2</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:3 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:3</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><code>uid:1</code> 取消了对 article:1 文章点赞。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; SREM article:1 uid:1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>获取 article:1 文章所有点赞用户 :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SMEMBERS article:1</span></span><br><span class="line">1) &quot;uid:3&quot;</span><br><span class="line">2) &quot;uid:2&quot;</span><br></pre></td></tr></table></figure><p>获取 article:1 文章的点赞用户数量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SCARD article:1</span></span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER article:1 uid:1</span></span><br><span class="line">(integer) 0  # 返回0说明没点赞，返回1则说明点赞了</span><br></pre></td></tr></table></figure><h4 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h4><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p><p>key 可以是用户id，value 则是已关注的公众号的id。</p><p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p><h4 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h4><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p><p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/zset.png" alt="img"></p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p><p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。</p><h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p><h4 id="电话、姓名排序"><a href="#电话、姓名排序" class="headerlink" title="电话、姓名排序"></a>电话、姓名排序</h4><p>使用有序集合的 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 可以帮助我们实现电话号码或姓名的排序，我们以 <code>ZRANGEBYLEX</code> （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例</p><h1 id="AOF-持久化是怎么实现的"><a href="#AOF-持久化是怎么实现的" class="headerlink" title="AOF 持久化是怎么实现的"></a>AOF 持久化是怎么实现的</h1><p>试想一下，如果 Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，这不就相当于恢复了缓存数据了吗？</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7.png" alt="img"></p><p>这种保存写操作命令到日志的持久化方式，就是 Redis 里的 <strong>AOF(*Append Only File*)</strong> 持久化功能，<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong>，因为没意义。</p><p>在 Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 <code>redis.conf</code> 配置文件中的以下参数：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/0e2d081af084c41802c7b5de8aa41bd4.png" alt="img"></p><p>AOF 日志文件其实就是普通的文本，我们可以通过 <code>cat</code> 命令查看里面的内容，不过里面的内容如果不知道一定的规则的话，可能会看不懂</p><p><strong>Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的</strong>，这么做其实有两个好处。</p><p>第一个好处，<strong>避免额外的检查开销。</strong></p><p>因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</p><p>而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。</p><p>第二个好处，<strong>不会阻塞当前写操作命令的执行</strong>，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</p><p>当然，AOF 持久化功能也不是没有潜在风险。</p><p>第一个风险，执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有<strong>丢失的风险</strong>。</p><p>第二个风险，前面说道，由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是<strong>可能会给「下一个」命令带来阻塞风险</strong>。</p><h3 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h3><p>重写机制的妙处在于，尽管某个键值对被多条写命令反复修改，<strong>最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对</strong>，代替之前记录这个键值对的多条命令，这样就减少了 AOF 文件中的命令数量。最后在重写工作完成后，将新的 AOF 文件覆盖现有的 AOF 文件</p><p>Redis 的<strong>重写 AOF 过程是由后台子进程 *bgrewriteaof* 来完成的</strong></p><ul><li><strong>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程</strong>；</li><li><strong>子进程带有主进程的数据副本（<em>数据副本怎么产生的后面会说</em>），这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</strong></li></ul><p>Redis 提供了三种将 AOF 日志写回硬盘的策略，分别是 Always、Everysec 和 No，这三种策略在可靠性上是从高到低，而在性能上则是从低到高。</p><p>随着执行的命令越多，AOF 文件的体积自然也会越来越大，为了避免日志文件过大， Redis 提供了 AOF 重写机制，它会直接扫描数据中所有的键值对数据，然后为每一个键值对生成一条写操作命令，接着将该命令写入到新的 AOF 文件，重写完成后，就替换掉现有的 AOF 日志。重写的过程是由后台子进程完成的，这样可以使得主进程可以继续正常处理命令。</p><p>用 AOF 日志的方式来恢复数据其实是很慢的，因为 Redis 执行命令由单线程负责的，而 AOF 日志恢复数据的方式是顺序执行日志里的每一条命令，如果 AOF 日志很大，这个「重放」的过程就会很慢了。</p><h1 id="RDB-快照是怎么实现的？"><a href="#RDB-快照是怎么实现的？" class="headerlink" title="RDB 快照是怎么实现的？"></a>RDB 快照是怎么实现的？</h1><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li></ul><p>RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。</p><p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。</p><p>只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p><ul><li>900 秒之内，对数据库进行了至少 1 次修改；</li><li>300 秒之内，对数据库进行了至少 10 次修改；</li><li>60 秒之内，对数据库进行了至少 10000 次修改。</li></ul><p>这里提一点，Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p><p>所以可以认为，执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p><p><strong>通常可能设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。</strong></p><p><strong>这就是 RDB 快照的缺点，在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少</strong></p><h3 id="执行快照时，数据能被修改吗？"><a href="#执行快照时，数据能被修改吗？" class="headerlink" title="执行快照时，数据能被修改吗？"></a>执行快照时，数据能被修改吗？</h3><p>那问题来了，执行 bgsave 过程中，由于是交给子进程来构建 RDB 文件，主线程还是可以继续工作的，此时主线程可以修改数据吗？</p><p>如果不可以修改数据的话，那这样性能一下就降低了很多。如果可以修改数据，又是如何做到到呢？</p><p>直接说结论吧，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的。</p><p>那具体如何做到到呢？关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p><p>执行 bgsave 命令的时候，会通过 <code>fork()</code> 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。</p><p>如果主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 <code>A</code>）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 <code>A&#39;</code>）</strong>，然后<strong>主线程在这个数据副本（键值对 <code>A&#39;</code>）进行修改操作</strong>。与此同时，<strong>bgsave 子进程可以继续把原来的数据（键值对 <code>A</code>）写入到 RDB 文件</strong>。</p><p>就是这样，Redis 使用 bgsave 对当前内存中的所有数据做快照，这个操作是由 bgsave 子进程在后台完成的，执行时不会阻塞主线程，这就使得主线程同时可以修改数据。</p><p>细心的同学，肯定发现了，bgsave 快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。</p><p>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</p><h2 id="RDB-和-AOF-合体"><a href="#RDB-和-AOF-合体" class="headerlink" title="RDB 和 AOF 合体"></a>RDB 和 AOF 合体</h2><p>尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p><ul><li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li><li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li></ul><p>那有没有什么方法不仅有 RDB 恢复速度快的优点和，又有 AOF 丢失数据少的优点呢？</p><p>当然有，那就是将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化。</p><p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><h1 id="Redis-大-Key-对持久化有什么影响？"><a href="#Redis-大-Key-对持久化有什么影响？" class="headerlink" title="Redis 大 Key 对持久化有什么影响？"></a>Redis 大 Key 对持久化有什么影响？</h1><p>当 AOF 写回策略配置了 Always 策略，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。</p><p>AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 <code>fork()</code> 函数创建一个子进程来处理任务。会有两个阶段会导致阻塞父进程（主线程）：</p><ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。</li></ul><p>大 key 除了会影响持久化之外，还会有以下的影响。</p><ul><li>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li>内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li></ul><p>如何避免大 Key 呢？</p><p>最好在设计阶段，就把大 key 拆分成一个一个小 key。或者，定时检查 Redis 是否存在大 key ，如果该大 key 是可以删除的，不要使用 DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis 4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程。</p><h1 id="Redis-过期删除策略和内存淘汰策略有什么区别？"><a href="#Redis-过期删除策略和内存淘汰策略有什么区别？" class="headerlink" title="Redis 过期删除策略和内存淘汰策略有什么区别？"></a>Redis 过期删除策略和内存淘汰策略有什么区别？</h1><h3 id="过期删除策略有哪些？"><a href="#过期删除策略有哪些？" class="headerlink" title="过期删除策略有哪些？"></a>过期删除策略有哪些？</h3><p>在说 Redis 过期删除策略之前，先跟大家介绍下，常见的三种过期删除策略：</p><ul><li>定时删除；</li><li>惰性删除；</li><li>定期删除；</li></ul><p>定时删除策略的做法是，<strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</strong></p><p>定时删除策略的<strong>优点</strong>：</p><ul><li>可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。</li></ul><p>定时删除策略的<strong>缺点</strong>：</p><ul><li>在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</li></ul><p>惰性删除策略的做法是，<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p><p>惰性删除策略的<strong>优点</strong>：</p><ul><li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li></ul><p>惰性删除策略的<strong>缺点</strong>：</p><ul><li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li></ul><p>定期删除策略的做法是，<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p>定期删除策略的<strong>优点</strong>：</p><ul><li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li></ul><p>定期删除策略的<strong>缺点</strong>：</p><ul><li>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li><li>难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li></ul><p><strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>前面说的过期删除策略，是删除已过期的 key，而当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行</p><ul><li>在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。</li><li>在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。</li></ul><h4 id="Redis-内存淘汰策略有哪些？"><a href="#Redis-内存淘汰策略有哪些？" class="headerlink" title="Redis 内存淘汰策略有哪些？"></a>Redis 内存淘汰策略有哪些？</h4><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p><p><em>1、不进行数据淘汰的策略</em></p><p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：<strong>它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</strong></p><p><em>2、进行数据淘汰的策略</em></p><p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p><p>在设置了过期时间的数据中进行淘汰：</p><ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul><p>在所有数据范围内进行淘汰：</p><ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><h4 id="LRU-算法和-LFU-算法有什么区别？"><a href="#LRU-算法和-LFU-算法有什么区别？" class="headerlink" title="LRU 算法和 LFU 算法有什么区别？"></a>LRU 算法和 LFU 算法有什么区别？</h4><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p><p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p><p>LFU 全称是 Least Frequently Used 翻译为<strong>最近最不常用</strong>，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>所以， <strong>LFU 算法会记录每个数据的访问次数</strong>。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p><h2 id="主从复制是怎么实现的？"><a href="#主从复制是怎么实现的？" class="headerlink" title="主从复制是怎么实现的？"></a>主从复制是怎么实现的？</h2><p>由于数据都是存储在一台服务器上，如果出事就完犊子了，比如：</p><ul><li>如果服务器发生了宕机，由于数据恢复是需要点时间，那么这个期间是无法服务新的请求的；</li><li>如果这台服务器的硬盘出现了故障，可能数据就都丢失了。</li></ul><p>要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/22c7fe97ce5d3c382b08d83a4d8a5b96.png" alt="图片"></p><p>多台服务器要保存同一份数据，这里问题就来了。</p><p>这些服务器之间的数据如何保持一致性呢？数据的读写操作是否每台服务器都可以处理？</p><p>Redis 提供了<strong>主从复制模式</strong>，来避免上述的问题。</p><p>主从服务器间的第一次同步的过程可分为三个阶段：</p><ul><li>第一阶段是建立链接、协商同步；</li><li>第二阶段是主服务器同步数据给从服务器；</li><li>第三阶段是主服务器发送新写操作命令给从服务器</li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/ea4f7e86baf2435af3999e5cd38b6a26.png" alt="图片"></p><p><em>第一阶段：建立链接、协商同步</em></p><p>执行了 replicaof 命令后，从服务器就会给主服务器发送 <code>psync</code> 命令，表示要进行数据同步。</p><p>psync 命令包含两个参数，分别是<strong>主服务器的 runID</strong> 和<strong>复制进度 offset</strong>。</p><ul><li>runID，每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己。当从服务器和主服务器第一次同步时，因为不知道主服务器的 run ID，所以将其设置为 “?”。</li><li>offset，表示复制的进度，第一次同步时，其值为 -1。</li></ul><p>主服务器收到 psync 命令后，会用 <code>FULLRESYNC</code> 作为响应命令返回给对方。</p><p>并且这个响应命令会带上两个参数：主服务器的 runID 和主服务器目前的复制进度 offset。从服务器收到响应后，会记录这两个值。</p><p>FULLRESYNC 响应命令的意图是采用<strong>全量复制</strong>的方式，也就是主服务器会把所有的数据都同步给从服务器。</p><p>所以，第一阶段的工作时为了全量复制做准备。</p><p>那具体怎么全量同步呀呢？我们可以往下看第二阶段。</p><p><em>第二阶段：主服务器同步数据给从服务器</em></p><p>接着，主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器。</p><p>从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件。</p><p>这里有一点要注意，主服务器生成 RDB 这个过程是不会阻塞主线程的，因为 bgsave 命令是产生了一个子进程来做生成 RDB 文件的工作，是异步工作的，这样 Redis 依然可以正常处理命令。</p><p>但是，这期间的写操作命令并没有记录到刚刚生成的 RDB 文件中，这时主从服务器间的数据就不一致了。</p><p>那么为了保证主从服务器的数据一致性，<strong>主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里</strong>：</p><ul><li>主服务器生成 RDB 文件期间；</li><li>主服务器发送 RDB 文件给从服务器期间；</li><li>「从服务器」加载 RDB 文件期间；</li></ul><p><em>第三阶段：主服务器发送新写操作命令给从服务器</em></p><p>在主服务器生成的 RDB 文件发送完，从服务器收到 RDB 文件后，丢弃所有旧数据，将 RDB 数据载入到内存。完成 RDB 的载入后，会回复一个确认消息给主服务器。</p><p>接着，主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器 replication buffer 缓冲区里发来的命令，这时主从服务器的数据就一致了。</p><p>至此，主从服务器的第一次同步的工作就完成了</p><h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/03eacec67cc58ff8d5819d0872ddd41e.png" alt="图片"></p><p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p><p>而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。</p><p>上面的这个过程被称为<strong>基于长连接的命令传播</strong>，通过这种方式来保证第一次同步后的主从服务器的数据一致性</p><p>所以，从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用<strong>增量复制</strong>的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p><p>主从复制共有三种模式：<strong>全量复制、基于长连接的命令传播、增量复制</strong>。</p><p>主从服务器第一次同步的时候，就是采用全量复制，此时主服务器会两个耗时的地方，分别是生成 RDB 文件和传输 RDB 文件。为了避免过多的从服务器和主服务器进行全量复制，可以把一部分从服务器升级为「经理角色」，让它也有自己的从服务器，通过这样可以分摊主服务器的压力。</p><p>第一次同步完成后，主从服务器都会维护着一个长连接，主服务器在接收到写操作命令后，就会通过这个连接将写命令传播给从服务器，来保证主从服务器的数据一致性。</p><p>如果遇到网络断开，增量复制就可以上场了，不过这个还跟 repl_backlog_size 这个大小有关系。</p><p>如果它配置的过小，主从服务器网络恢复时，可能发生「从服务器」想读的数据已经被覆盖了，那么这时就会导致主服务器采用全量复制的方式。所以为了避免这种情况的频繁发生，要调大这个参数的值，以降低主从服务器断开后全量同步的概率。</p><h3 id="Redis主从节点时长连接还是短连接？"><a href="#Redis主从节点时长连接还是短连接？" class="headerlink" title="Redis主从节点时长连接还是短连接？"></a>Redis主从节点时长连接还是短连接？</h3><p>长连接</p><h3 id="怎么判断-Redis-某个节点是否正常工作？"><a href="#怎么判断-Redis-某个节点是否正常工作？" class="headerlink" title="#怎么判断 Redis 某个节点是否正常工作？"></a><a href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD-redis-%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C">#</a>怎么判断 Redis 某个节点是否正常工作？</h3><p>Redis 判断节点是否正常工作，基本都是通过互相的 ping-pong 心态检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接。</p><h3 id="主从复制架构中，过期key如何处理？"><a href="#主从复制架构中，过期key如何处理？" class="headerlink" title="主从复制架构中，过期key如何处理？"></a>主从复制架构中，过期key如何处理？</h3><p>主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。</p><h3 id="Redis-是同步复制还是异步复制？"><a href="#Redis-是同步复制还是异步复制？" class="headerlink" title="#Redis 是同步复制还是异步复制？"></a><a href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html#redis-%E6%98%AF%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6">#</a>Redis 是同步复制还是异步复制？</h3><p>Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点。</p><h1 id="什么要有哨兵机制？"><a href="#什么要有哨兵机制？" class="headerlink" title="什么要有哨兵机制？"></a>什么要有哨兵机制？</h1><p>在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。</p><p>Redis 在 2.8 版本以后提供的<strong>哨兵（*Sentinel*）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p><h2 id="如何判断主节点真的故障了？"><a href="#如何判断主节点真的故障了？" class="headerlink" title="如何判断主节点真的故障了？"></a>如何判断主节点真的故障了？</h2><p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/26f88373d8454682b9e0c1d4fd1611b4-20230309233114856.png" alt="哨兵监控主从节点"></p><blockquote><p>为什么哨兵节点至少要有 3 个？</p></blockquote><p>如果哨兵集群中只有 2 个哨兵节点，此时如果一个哨兵想要成功成为 Leader，必须获得 2 票，而不是 1 票。</p><p><strong>quorum 的值建议设置为哨兵个数的二分之一加1</strong>，例如 3 个哨兵就设置 2，5 个哨兵设置为 3，而且<strong>哨兵节点的数量应该是奇数</strong></p><p>Redis 在 2.8 版本以后提供的<strong>哨兵（*Sentinel*）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p><p>哨兵一般是以集群的方式部署，至少需要 3 个哨兵节点，哨兵集群主要负责三件事情：<strong>监控、选主、通知</strong>。</p><p>哨兵节点通过 Redis 的发布者&#x2F;订阅者机制，哨兵之间可以相互感知，相互连接，然后组成哨兵集群，同时哨兵又通过 INFO 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。</p><p><em>1、第一轮投票：判断主节点下线</em></p><p>当哨兵集群中的某个哨兵判定主节点下线（主观下线）后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p><p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p><p><em>2、第二轮投票：选出哨兵leader</em></p><p>某个哨兵判定主节点客观下线后，该哨兵就会发起投票，告诉其他哨兵，它想成为 leader，想成为 leader 的哨兵节点，要满足两个条件：</p><ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li></ul><p><em>3、由哨兵 leader 进行主从故障转移</em></p><p>选举出了哨兵 leader 后，就可以进行主从故障转移的过程了。该操作包含以下四个步骤：</p><ul><li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：<ul><li>过滤掉已经离线的从节点；</li><li>过滤掉历史网络连接状态不好的从节点；</li><li>将剩下的从节点，进行三轮考察：优先级、复制进度、ID 号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点。</li></ul></li><li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li><li>第三步：将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端；</li><li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li></ul><h2 id="什么是缓存雪崩、击穿、穿透？"><a href="#什么是缓存雪崩、击穿、穿透？" class="headerlink" title="什么是缓存雪崩、击穿、穿透？"></a>什么是缓存雪崩、击穿、穿透？</h2><p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p><p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。</p><p>因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/37e4378d2edcb5e217b00e5f12973efd-20230309232858764.png" alt="图片"></p><p>引入了缓存层，就会有缓存异常的三个问题，分别是<strong>缓存雪崩、缓存击穿、缓存穿透</strong>。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/e2b8d2eb5536aa71664772457792ec40-20230309232851699.png" alt="图片"></p><p>那么，当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/717343a0da7a1b05edab1d1cdf8f28e5.png" alt="图片"></p><p>可以看到，发生缓存雪崩有两个原因：</p><ul><li><strong>大量数据同时过期</strong>；</li><li><strong>Redis 故障宕机；</strong></li></ul><p>不同的诱因，应对的策略也会不同。</p><h4 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="#大量数据同时过期"></a><a href="https://xiaolincoding.com/redis/cluster/cache_problem.html#%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%8C%E6%97%B6%E8%BF%87%E6%9C%9F">#</a>大量数据同时过期</h4><p>针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li><strong>均匀设置过期时间</strong>；</li><li><strong>互斥锁</strong>；</li><li>双 key 策略；</li><li>后台更新缓存；</li></ul><p><em>1. 均匀设置过期时间</em></p><p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p><p><em>2. 互斥锁</em></p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p><p><em>3. 后台更新缓存</em></p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>解决上面的问题的方式有两种。</p><p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p><p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p><p>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p><h4 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="#Redis 故障宕机"></a><a href="https://xiaolincoding.com/redis/cluster/cache_problem.html#redis-%E6%95%85%E9%9A%9C%E5%AE%95%E6%9C%BA">#</a>Redis 故障宕机</h4><p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li><strong>服务熔断或请求限流机制</strong>；</li><li><strong>构建 Redis 缓存高可靠集群；</strong></li></ul><p><em>1. 服务熔断或请求限流机制</em></p><p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p><p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p><p><em>2. 构建 Redis 缓存高可靠集群</em></p><p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/acb5f4e7ef24a524a53c39eb016f63d4-20230309232840753.png" alt="图片"></p><p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p><p>应对缓存击穿可以采取前面说到两种方案：</p><ul><li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/b7031182f770a7a5b3c82eaf749f53b0-20230309232834574.png" alt="图片"></p><p>缓存穿透的发生一般有这两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li>第一种方案，<strong>非法请求的限制</strong>；</li><li>第二种方案，<strong>缓存空值或者默认值</strong>；</li><li>第三种方案，<strong>使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</strong></li></ul><p>第一种方案，非法请求的限制</p><p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p><p>第二种方案，缓存空值或者默认值</p><p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p><p><em>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。</em></p><p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p><p>那问题来了，<strong>布隆过滤器</strong>是如何工作的呢？接下来，我介绍下。</p><p><strong>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中</strong>。</p><p>布隆过滤器会通过 3 个操作完成标记：</p><ul><li><strong>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</strong></li><li><strong>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</strong></li><li><strong>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</strong></li></ul><p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/86b0046c2622b2c4bda697f9bc0f5b28.png" alt="图片"></p><p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://xiaolincoding.com/redis/cluster/cache_problem.html#%E6%80%BB%E7%BB%93">#</a>总结</h3><p>缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。</p><p>其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。</p><p>而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。</p><p>我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片"></p><ul><li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li><li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li><li>Redis 采用了 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果</li></ul><p><strong>Redis 中并没有提供回滚机制</strong></p><p><strong>管道技术可以解决多个命令执行时的网络等待</strong></p><h3 id="Redis-持久化时，对过期键会如何处理的？"><a href="#Redis-持久化时，对过期键会如何处理的？" class="headerlink" title="Redis 持久化时，对过期键会如何处理的？"></a>Redis 持久化时，对过期键会如何处理的？</h3><p>Redis 持久化文件有两种格式：RDB（Redis Database）和 AOF（Append Only File），下面我们分别来看过期键在这两种格式中的呈现状态。</p><p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p><ul><li><p><strong>RDB 文件生成阶段</strong>：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键「不会」被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</p></li><li><p>RDB 加载阶段</p><p>：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：</p><ul><li><strong>如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li><li><strong>如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul></li></ul><p>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。</p><ul><li><strong>AOF 文件写入阶段</strong>：当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</li><li><strong>AOF 重写阶段</strong>：执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li></ul><h3 id="Redis-主从模式中，对过期键会如何处理？"><a href="#Redis-主从模式中，对过期键会如何处理？" class="headerlink" title="#Redis 主从模式中，对过期键会如何处理？"></a><a href="https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E4%B8%AD-%E5%AF%B9%E8%BF%87%E6%9C%9F%E9%94%AE%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">#</a>Redis 主从模式中，对过期键会如何处理？</h3><p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p><p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key</p><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上，增加或者移除一个节点，只影响该节点在哈希环上顺时针相邻的后继节点，其它数据不会受到影响。</p><p>一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。</p><p>为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个映射节点。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到真实节点，所以这里有两层映射关系。</p><p>引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/anxiangblog.github.io/2023/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/anxiangblog.github.io/2023/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="请说一下socket网络编程中客户端和服务端用到哪些函数？"><a href="#请说一下socket网络编程中客户端和服务端用到哪些函数？" class="headerlink" title="请说一下socket网络编程中客户端和服务端用到哪些函数？"></a>请说一下socket网络编程中客户端和服务端用到哪些函数？</h3><p><strong>参考回答</strong></p><ol><li><p><strong>服务器端函数</strong>：</p><p>（1）socket创建一个套接字</p><p>（2）bind绑定ip和port</p><p>（3）listen使套接字变为可以被动链接</p><p>（4）accept等待客户端的链接</p><p>（5）write&#x2F;read接收发送数据</p><p>（6）close关闭连接</p></li><li><p><strong>客户端函数</strong>：</p><p>（1）创建一个socket，用函数socket()</p><p>（2）bind绑定ip和port</p><p>（3）连接服务器，用函数connect()</p><p>（4）收发数据，用函数send()和recv()，或read()和write()</p><p>（5）close关闭连接</p><p><img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789189940/1C7CCCBB618E2A4F2C7DAFF81A9E9884" alt="img"></p></li></ol><h3 id="TCP-半连接队列和全连接队列"><a href="#TCP-半连接队列和全连接队列" class="headerlink" title="TCP 半连接队列和全连接队列"></a>TCP 半连接队列和全连接队列</h3><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></p><h3 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p>答案：<strong>可以的</strong>。</p><p>accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p><h3 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h3><p>答案：<strong>可以的</strong>。</p><p>客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</strong></p><h3 id="如何优化-TCP"><a href="#如何优化-TCP" class="headerlink" title="如何优化 TCP?"></a>如何优化 TCP?</h3><ul><li><h4 id="TCP-三次握手的性能提升；"><a href="#TCP-三次握手的性能提升；" class="headerlink" title="TCP 三次握手的性能提升；"></a>TCP 三次握手的性能提升；</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/24.jpg" alt="三次握手优化策略"></p><blockquote><p>客户端的优化</p></blockquote><p>当客户端发起 SYN 包时，可以通过 <code>tcp_syn_retries</code> 控制其重传的次数。</p><blockquote><p>服务端的优化</p></blockquote><p>当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 <code>netstat -s</code> 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况比较严重，可以通过 <code>tcp_max_syn_backlog、somaxconn、backlog</code> 参数来调整 SYN 半连接队列的大小。</p><p>服务端回复 SYN+ACK 的重传次数由 <code>tcp_synack_retries</code> 参数控制。如果遭受 SYN 攻击，应把 <code>tcp_syncookies</code> 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。</p><p>服务端收到客户端返回的 ACK，会把连接移入 accpet 队列，等待进行调用 accpet() 函数取出连接。</p><p>可以通过 <code>ss -lnt</code> 查看服务端进程的 accept 队列长度，如果 accept 队列溢出，系统默认丢弃 ACK，如果可以把 <code>tcp_abort_on_overflow</code> 设置为 1 ，表示用 RST 通知客户端连接建立失败。</p><p>如果 accpet 队列溢出严重，可以通过 listen 函数的 <code>backlog</code> 参数和 <code>somaxconn</code> 系统参数提高队列大小，accept 队列长度取决于 min(backlog, somaxconn)。</p><blockquote><p>绕过三次握手</p></blockquote><p>TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，Linux 下可以通过 <code>tcp_fastopen</code> 开启该功能，同时必须保证服务端和客户端同时支持。</p></li><li><h4 id="TCP-四次挥手的性能提升；"><a href="#TCP-四次挥手的性能提升；" class="headerlink" title="TCP 四次挥手的性能提升；"></a>TCP 四次挥手的性能提升；</h4></li><li><p>针对 TCP 四次挥手的优化，我们需要根据主动方和被动方四次挥手状态变化来调整系统 TCP 内核参数。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/39.jpg" alt="四次挥手的优化策略"></p><blockquote><p>主动方的优化</p></blockquote><p>主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 <code>tcp_orphan_retries</code> 参数决定。</p><p>当主动方收到 ACK 报文后，连接就进入 FIN_WAIT2 状态，根据关闭的方式不同，优化的方式也不同：</p><ul><li>如果这是 close 函数关闭的连接，那么它就是孤儿连接。如果 <code>tcp_fin_timeout</code> 秒内没有收到对方的 FIN 报文，连接就直接关闭。同时，为了应对孤儿连接占用太多的资源，<code>tcp_max_orphans</code> 定义了最大孤儿连接的数量，超过时连接就会直接释放。</li><li>反之是 shutdown 函数关闭的连接，则不受此参数限制；</li></ul><p>当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，<code>tcp_max_tw_buckets</code> 定义了最大数量，超过时连接也会直接释放。</p><p>当 TIME_WAIT 状态过多时，还可以通过设置 <code>tcp_tw_reuse</code> 和 <code>tcp_timestamps</code> 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。</p><blockquote><p>被动方的优化</p></blockquote><p>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</p><p>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 <code>tcp_orphan_retries</code> 参数的控制下重发 FIN 报文</p></li><li><h4 id="TCP-数据传输的性能提升"><a href="#TCP-数据传输的性能提升" class="headerlink" title="TCP 数据传输的性能提升"></a>TCP 数据传输的性能提升</h4></li><li><p>本节针对 TCP 优化数据传输的方式，做了一些介绍。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/49.jpg" alt="数据传输的优化策略"></p><p>TCP 可靠性是通过 ACK 确认报文实现的，又依赖滑动窗口提升了发送速度也兼顾了接收方的处理能力。</p><p>可是，默认的滑动窗口最大值只有 64 KB，不满足当今的高速网络的要求，要想提升发送速度必须提升滑动窗口的上限，在 Linux 下是通过设置 <code>tcp_window_scaling</code> 为 1 做到的，此时最大值可高达 1GB。</p><p>滑动窗口定义了网络中飞行报文的最大字节数，当它超过带宽时延积时，网络过载，就会发生丢包。而当它小于带宽时延积时，就无法充分利用网络带宽。因此，滑动窗口的设置，必须参考带宽时延积。</p><p>内核缓冲区决定了滑动窗口的上限，缓冲区可分为：发送缓冲区 tcp_wmem 和接收缓冲区 tcp_rmem。</p><p>Linux 会对缓冲区动态调节，我们应该把缓冲区的上限设置为带宽时延积。发送缓冲区的调节功能是自动打开的，而接收缓冲区需要把 tcp_moderate_rcvbuf 设置为 1 来开启。其中，调节的依据是 TCP 内存范围 tcp_mem。</p><p>但需要注意的是，如果程序中的 socket 设置 SO_SNDBUF 和 SO_RCVBUF，则会关闭缓冲区的动态整功能，所以不建议在程序设置它俩，而是交给内核自动调整比较好。</p><p>有效配置这些参数后，既能够最大程度地保持并发性，也能让资源充裕时连接传输速度达到最大值</p></li></ul><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="如何基于-UDP-协议实现可靠传输？"><a href="#如何基于-UDP-协议实现可靠传输？" class="headerlink" title="如何基于 UDP 协议实现可靠传输？"></a>如何基于 UDP 协议实现可靠传输？</h3><ul><li>升级 TCP 的工作很困难；</li><li>TCP 建立连接的延迟；</li><li>TCP 存在队头阻塞问题；</li><li>网络迁移需要重新建立 TCP 连接；</li></ul><p><strong>QUIC 协议</strong>没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能</p><h3 id="2-61-简述网络七层参考模型，每一层的作用？"><a href="#2-61-简述网络七层参考模型，每一层的作用？" class="headerlink" title="2.61 简述网络七层参考模型，每一层的作用？"></a>2.61 简述网络七层参考模型，每一层的作用？</h3><p>TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="img"></p><p>再给大家贴一下每一层的封装格式：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><table><thead><tr><th>OSI七层模型</th><th>功能</th><th>对应的网络协议</th><th align="center">TCP&#x2F;IP四层概念模型</th></tr></thead><tbody><tr><td>应用层</td><td>文件传输，文件管理，电子邮件的信息处理</td><td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td><td align="center">应用层</td></tr><tr><td>表示层</td><td>确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密。</td><td>Telnet, Rlogin, SNMP, Gopher</td><td align="center">应用层</td></tr><tr><td>会话层</td><td>负责在网络中的两节点建立，维持和终止通信。</td><td>SMTP, DNS</td><td align="center">应用层</td></tr><tr><td>传输层</td><td>定义一些传输数据的协议和端口。</td><td>TCP, UDP</td><td align="center">传输层</td></tr><tr><td>网络层</td><td>控制子网的运行，如逻辑编址，分组传输，路由选择</td><td>IP, ICMP, ARP, RARP, AKP, UUCP</td><td align="center">网络层</td></tr><tr><td>数据链路层</td><td>主要是对物理层传输的比特流包装，检测保证数据传输的可靠性，将物理层接收的数据进行MAC（媒体访问控制）地址的封装和解封装</td><td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继</td><td align="center">数据链路层</td></tr><tr><td>物理层</td><td>定义物理设备的标准，主要对物理连接方式，电气特性，机械特性等制定统一标准。</td><td>IEEE 802.1A, IEEE 802.2到IEEE 802.</td><td align="center">数据链路层</td></tr></tbody></table><h3 id="简述静态路由和动态路由"><a href="#简述静态路由和动态路由" class="headerlink" title="简述静态路由和动态路由"></a>简述静态路由和动态路由</h3><p><strong>参考回答</strong></p><ol><li>静态路由是由系统管理员设计与构建的路由表规定的路由。适用于网关数量有限的场合，且网络拓朴结构不经常变化的网络。其缺点是不能动态地适用网络状况的变化，当网络状况变化后必须由网络管理员修改路由表。</li><li>动态路由是由路由选择协议而动态构建的，路由协议之间通过交换各自所拥有的路由信息实时更新路由表的内容。动态路由可以自动学习网络的拓朴结构，并更新路由表。其缺点是路由广播更新信息将占据大量的网络带宽。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">跟团游（静态路由）：导游提供的路线为北京-南京-深圳-三亚。</span><br><span class="line">自由行（动态路由）：出发于北京，终点在三亚，途径哪里我们具体情况具体分析。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">静态路由是由网络管理员手动创建的路由，路由器的路由表条目由网络管理员手动填充。而且静态路由是固定的，不会随着网络的改变而变化。</span><br><span class="line">静态路由的优点是路由器之间不必交换动态路由信息，占用设备的资源很少。就像我们作为游客跟团游的时候不必提前安排下一站的食宿，非常省心</span><br><span class="line"></span><br><span class="line">因此静态路由更适用于小型、简单的网络，不适用于路由器较多、网络变化可能性高、较为复杂的网络</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">动态路由是与静态路由相对的一个概念，指路由器能够根据路由器之间交换的特定路由信息自动建立自己的路由表，并且能够根据链路和节点的变化适时地进行自动调整。</span><br><span class="line"></span><br><span class="line">当网络节点或节点间的链路发生故障，或者存在其它可用路由时候，动态路由可以自行选择“最佳”的可用路由。</span><br><span class="line">相似的，动态路由可以自动根据网络拓扑结构变化进行调整，同时也会占用路由器的CPU、内存和链路带宽。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>距离向量法（Distance Vector Routing）和链路状态算法（Link-State Routing）。</strong></p><p><strong>RIP</strong>（Routing Information Protocol，路由信息协议）</p><p><strong>OSPF</strong>（Open Shortest Path First，开放最短路径优先）</p><p><strong>IS-IS</strong>（Intermediate System-to-Intermediate System，中间系统到中间系统）</p><p><strong>BGP</strong>（Border Gateway Protocol，边界网关协议）</p><h3 id="说说有哪些路由协议，都是如何更新的"><a href="#说说有哪些路由协议，都是如何更新的" class="headerlink" title="说说有哪些路由协议，都是如何更新的"></a>说说有哪些路由协议，都是如何更新的</h3><p><strong>参考回答</strong></p><ol><li><p>路由可分为静态&amp;动态路由。静态路由由管理员手动维护；动态路由由路由协议自动维护。</p><p>路由选择算法的必要步骤：</p><p>1）向其它路由器传递路由信息；</p><p>2）接收其它路由器的路由信息；</p><p>3）根据收到的路由信息计算出到每个目的网络的最优路径，并由此生成路由选择表；</p><p>4）根据网络拓扑的变化及时的做出反应，调整路由生成新的路由选择表，同时把拓扑变化以路由 信息的形式向其它路由器宣告。</p><p>两种主要算法：<strong>距离向量法（Distance Vector Routing）和链路状态算法（Link-State Routing）。</strong></p><p>由此可分为距离矢量（如：RIP、IGRP、EIGRP）&amp;链路状态路由协议（如：OSPF、IS-IS）。 路由协议是路由器之间实现路由信息共享的一种机制，它允许路由器之间相互交换和维护各 自的路由表。当一台路由器的路由表由于某种原因发生变化时，它需要及时地将这一变化通 知与之相连接的其他路由器，以保证数据的正确传递。路由协议不承担网络上终端用户之间 的数据传输任务。</p></li><li><p>1）RIP 路由协议(Routing Information Protocol)：RIP 协议最初是为 Xerox 网络系统的 Xerox parc 通用协议而设计的，是 Internet 中常用的 路由协议。RIP 采用距离向量算法，即路由器根据距离选择路由，所以也称为距离向量协议。 路由器收集所有可到达目的地的不同路径，并且保存有关到达每个目的地的最少站点数的路 径信息，除到达目的地的最佳路径外，任何其它信息均予以丢弃。同时路由器也把所收集的 路由信息用 RIP 协议通知相邻的其它路由器。这样，正确的路由信息逐渐扩散到了全网。RIP 使用非常广泛，它简单、可靠，便于配置。但是 <strong>RIP 只适用于小型的同构网络，因 为它允许的最大站点数为 15，任何超过 15 个站点的目的地均被标记为不可达。而且 RIP 每 隔 30s 一次的路由信息广播也是造成网络的广播风暴的重要原因之一</strong>。</p><p>2）OSPF 路由协议(Open Shortest Path First)：0SPF 是一种基于链路状态的路由协议，需要每个路由器向其同一管理域的所有其它路 由器发送链路状态广播信息。在 OSPF 的链路状态广播中包括所有接口信息、所有的量度和 其它一些变量。利用 0SPF 的路由器首先必须收集有关的链路状态信息，并根据一定的算法计算出到每个节点的最短路径。而<strong>基于距离向量的路由协议仅向其邻接路由器发送有关路由更新信息。与 RIP 不同，OSPF 将一个自治域再划分为区</strong>，相应地即有两种类型的路由选择方式： <strong>当源和目的地在同一区时，采用区内路由选择；当源和目的地在不同区时，则采用区间路由选择</strong>。这就大大减少了网络开销，并增加了网络的稳定性。当一个区内的路由器出了故障时 并不影响自治域内其它区路由器的正常工作，这也给网络的管理、维护带来方便。</p><p>3）BGP 和 BGP4 路由协议(Border Gateway Protocol)：<strong>BGP 是为 TCP／IP 互联网设计的外部网关协议，用于多个自治域之间。</strong>它既不是基于纯 粹的链路状态算法，也不是基于纯粹的距离向量算法。<strong>它的主要功能是与其它自治域的 BGP 交换网络可达信息。各个自治域可以运行不同的内部网关协议</strong>。BGP 更新信息包括网络号／ 自治域路径的成对信息。自治域路径包括到达某个特定网络须经过的自治域串，这些更新信 息通过 TCP 传送出去，以保证传输的可靠性。为了满足 Internet 日益扩大的需要，BGP 还在不断地发展。在最新的 BGP4 中，还可以 将相似路由合并为一条路由。</p><p>4）IGRP 和 EIGRP 协议：EIGRP 和早期的 IGRP 协议都是由 Cisco 发明，是基于距离向量算法的动态路由协议。 EIGRP(Enhanced Interior Gateway Routing Protocol)是增强版的 IGRP 协议。它属于动态内部网 关路由协议，仍然使用矢量－距离算法。但它的实现比 IGRP 已经有很大改进，其收敛特性 和操作效率比 IGRP 有显著的提高。它的收敛特性是基于 DUAL ( Distributed Update Algorithm ) 算法的。DUAL 算法使得路径 在路由计算中根本不可能形成环路。它的收敛时间可以与已存在的其他任何路由协议相匹敌</p></li></ol><p>​<strong>IS-IS</strong>（Intermediate System-to-Intermediate System，中间系统到中间系统） 是一种链路状态协议，类似于 OSPF，但其路由选择算法略有不同，通常用于大规模网络</p><h3 id="简述域名解析过程，本机如何干预域名解析"><a href="#简述域名解析过程，本机如何干预域名解析" class="headerlink" title="简述域名解析过程，本机如何干预域名解析"></a>简述域名解析过程，本机如何干预域名解析</h3><p><strong>参考回答</strong></p><ol><li><p>（1）在浏览器中输入<a href="http://www.qq.com/">www.qq.com</a>域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p><p>（2）如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p><p>（3）如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP&#x2F;IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p><p>（4）如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p><p>（5）如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com/">www.qq.com</a>主机。</p><p>（6）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p><p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p></li><li><p>通过修改本机host来干预域名解析，例如： 在&#x2F;etc&#x2F;hosts文件中添加一句话</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.188.1 www.baidu.com</span><br></pre></td></tr></table></figure><p>保存文件后再ping一下<a href="http://www.baidu.com就会连接到192.168.188.1了/">www.baidu.com就会连接到192.168.188.1了</a></p><p>每一行为一条记录，分成两部分，第一部分是IP，第二部分是域名。</p><ul><li>一个IP后面可以跟多个域名，可以是几十个甚至上百个</li><li>每一行只能有一个IP，也就是说一个域名不能对应多个IP</li><li>如果有多行中出现相同的域名（对应的ip不一样），会按最前面的记录来解析</li></ul></li></ol><p>DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，<strong>导致对该域名的访问由原IP地址转入到修改后的指定IP</strong>，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</p><h3 id="简述网关的作用是什么，同一网段的主机如何通信"><a href="#简述网关的作用是什么，同一网段的主机如何通信" class="headerlink" title="简述网关的作用是什么，同一网段的主机如何通信"></a>简述网关的作用是什么，同一网段的主机如何通信</h3><p><strong>参考回答</strong></p><ol><li><p>网关即网络中的关卡，我们的互联网是一个一个的局域网、城域网、等连接起来的，在连接点上就是一个一个网络的关卡，即我们的网关，他是保证网络互连的，翻译和转换，使得不同的网络体系能够进行。</p></li><li><p><strong>网内通信，即通信双方都位处同一网段中，数据传输无需经过路由器(或三层交换机)，即可由本网段自主完成。</strong></p><p>假设发送主机的ARP表中并无目的主机对应的表项，则发送主机会以目的主机IP地址为内容，广播ARP请求以期获知目的主机MAC地址，并通过交换机(除到达端口之外的所有端口发送，即洪泛(Flooding))向全网段主机转发，而只有目的主机接收到此ARP请求后会将自己的MAC地址和IP地址装入ARP应答后将其回复给发送主机，发送主机接收到此ARP应答后，从中提取目的主机的MAC地址，并在其ARP表中建立目的主机的对应表项(IP地址到MAC地址的映射)，之后即可向目的主机发送数据，将待发送数据封装成帧，并通过二层设备(如交换机)转发至本网段内的目的主机，自此完成通信。</p></li></ol><h3 id="简述CSRF攻击的思想以及解决方法"><a href="#简述CSRF攻击的思想以及解决方法" class="headerlink" title="简述CSRF攻击的思想以及解决方法"></a>简述CSRF攻击的思想以及解决方法</h3><p><strong>参考回答</strong></p><ol><li><p>CSRF全称叫做，跨站请求伪造。就是黑客可以伪造用户的身份去做一些操作，进而满足自身目的。</p><p>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>1）登录受信任网站A，并在本地生成Cookie。</p><p>2）在不登出A的情况下，访问危险网站B。</p><p>此时，黑客就可以获取你的cookie达成不可告人的目的了。</p></li><li><p>CSRF 攻击是一种请求伪造的攻击方式，它利用的是服务器不能识别用户的类型从而盗取用户的信息来攻击。因此要防御该种攻击，因为从服务器端着手，增强服务器的识别能力，设计良好的防御机制。主要有以下几种方式：</p><p>1）请求头中的Referer验证（不推荐）</p><p>HTTP的头部有一个Referer信息的字段，它记录着该次HTTP请求的来源地址（即它从哪里来的）,既然CSRF攻击是伪造请求是从服务器发送过来的，那么我们就禁止跨域访问，在服务器端增加验证，过滤掉那些不是从本服务器发出的请求，这样可以在一定程度上避免CSRF攻击。 但是这也有缺点，比如如果是从搜索引擎所搜结果调整过来，请求也会被认为是跨域请求。</p><p>2）请求令牌验证（token验证）</p><p>token验证是一种比较广泛使用的防止CSRF攻击的手段，当用户通过正常渠道访问服务器时，服务器会生成一个随机的字符串保存在session中，并作为令牌（token）返回给客户端，以隐藏的形式保存在客户端中，客户端每次请求都会带着这个token，服务器根据该token判断该请求是否合法</p></li></ol><h3 id="说说-MAC地址和IP地址分别有什么作用"><a href="#说说-MAC地址和IP地址分别有什么作用" class="headerlink" title="说说 MAC地址和IP地址分别有什么作用"></a>说说 MAC地址和IP地址分别有什么作用</h3><p><strong>参考回答</strong></p><ol><li>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的<strong>每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异</strong>。而<strong>MAC地址，指的是物理地址，用来定义网络设备的位置</strong>。</li><li>IP地址的分配是<strong>根据网络的拓扑结构</strong>，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓朴位置基础上，这种方案是不可行的。</li><li>当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。</li><li>无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由<strong>ARP</strong>（Address Resolution Protocol：地址解析协议）负责<strong>将IP地址映射到MAC地址上来完成的</strong>。</li></ol><p>​<strong>MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。MAC地址共48位（6个字节）</strong>。前24位由IEEE（电气和电子工程师协会）决定如何分配，后24位由实际生产该网络设备的厂商自行制定。例广播地址：FF:FF:FF:FF:FF:FF</p><h3 id="TCP-三次握手和四次挥手的过程"><a href="#TCP-三次握手和四次挥手的过程" class="headerlink" title="TCP 三次握手和四次挥手的过程"></a>TCP 三次握手和四次挥手的过程</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789276099/AB3FC1B1325FA341A39644BA061FA439" alt="img"></p><p>1）第一次握手：建立连接时，客户端向服务器发送SYN包（seq&#x3D;x），请求建立连接，等待确认</p><p>2）第二次握手：服务端收到客户端的SYN包，回一个ACK包（ACK&#x3D;x+1）确认收到，同时发送一个SYN包（seq&#x3D;y）给客户端</p><p>3）第三次握手：客户端收到SYN+ACK包，再回一个ACK包（ACK&#x3D;y+1）告诉服务端已经收到</p><p>4）三次握手完成，成功建立连接，开始传输数据</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789288423/2F42938B52A4B6494AA9CD8FCE658EBD" alt="img"></p><p>1）客户端发送FIN包（FIN&#x3D;1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时<strong>客户端不发送数据，但还能接收数据</strong></p><p>2）服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了，此时还没有断开socket连接，而是等待剩下的数据传输完毕</p><p>3）服务端等待数据传输完毕后，向客户端发送FIN包，表明可以断开连接</p><p>4）客户端收到后，回一个ACK包表明确认收到，等待一段时间，确保服务端不再有数据发过来，然后彻底断开连接</p><h3 id="说说-TCP-2次握手行不行？为什么要3次"><a href="#说说-TCP-2次握手行不行？为什么要3次" class="headerlink" title="说说 TCP 2次握手行不行？为什么要3次"></a>说说 TCP 2次握手行不行？为什么要3次</h3><p><strong>参考回答</strong></p><ol><li>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 <strong>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</strong></li><li>如果只是两次握手， <strong>至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</strong></li></ol><p>​<strong>tcp三次握手只要是为了确认线路的连通，第一次客户端发送到服务端，那么服务端就可以知道客户端的发送没有问题，但客户端不知道服务器的情况，第二次服务器发送ACK给客户端，客户端收到了证明服务端的收发都没有问题的，但服务端不知道客户端的接收情况，所以第三次是客户端再回给服务器一个ACK，服务器收到后就可以确保客户端的收发没有问题</strong></p><h3 id="简述-TCP-和-UDP-的区别，它们的头部结构是什么样的"><a href="#简述-TCP-和-UDP-的区别，它们的头部结构是什么样的" class="headerlink" title="简述 TCP 和 UDP 的区别，它们的头部结构是什么样的"></a>简述 TCP 和 UDP 的区别，它们的头部结构是什么样的</h3><p><strong>参考回答</strong></p><ol><li><p>T<strong>CP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的</strong></p><p><strong>TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。</strong></p><p><strong>TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。</strong></p><p><strong>TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率</strong></p><p><strong>TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。</strong></p><p><strong>TCP面向的是字节流的服务，UDP面向的是报文的服务。</strong></p></li></ol><p>HTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。</p><blockquote><p>TCP 包头格式</p></blockquote><p>我们先看看 TCP 报文头部的格式：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg" alt="TCP 包头格式"></p><p>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p><p>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</p><p>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</p><p>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><p>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*TCP头定义，共20个字节*/ typedef struct _TCP_HEADER &#123;  </span><br><span class="line">short m_sSourPort;       // 源端口号16bit  </span><br><span class="line">short m_sDestPort;       // 目的端口号16bit  </span><br><span class="line">unsigned int m_uiSequNum;       // 序列号32bit  </span><br><span class="line">unsigned int m_uiAcknowledgeNum;  // 确认号32bit  </span><br><span class="line">short m_sHeaderLenAndFlag;     // 前4位：TCP头长度；中6位：保留；后6位：标志位 </span><br><span class="line">short m_sWindowSize;       // 窗口大小16bit  </span><br><span class="line">short m_sCheckSum;       // 检验和16bit </span><br><span class="line">short m_surgentPointer;     // 紧急数据偏移量16bit </span><br><span class="line">&#125;__attribute__((packed))TCP_HEADER, *PTCP_HEADER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而UDP报头只包含长度，源端口号，目的端口，和校验和。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">基于TCP协议的：Telnet，FTP以及SMTP协议。</span><br><span class="line"></span><br><span class="line">基于UDP协议的：DHCP、DNS、SNMP、TFTP、BOOTP。</span><br></pre></td></tr></table></figure><p>netstat -napt</p><p>在 IP 协议里面需要有<strong>源地址 IP</strong> 和 <strong>目标地址 IP</strong>：</p><ul><li>源地址IP，即是客户端输出的 IP 地址；</li><li>目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。</li></ul><p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<strong>协议号</strong>，要填写为 <code>06</code>（十六进制），表示协议为 TCP。</p><p>至此，网络包的报文如下图。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg" alt="IP 层报文"></p><blockquote><p>此时，加上了 IP 头部的数据包表示 ：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”</p></blockquote><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p><blockquote><p>MAC 包头格式</p></blockquote><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg" alt="MAC 包头格式"></p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ： IP 协议</li><li><code>0806</code> ： ARP 协议</li></ul><p>此时就需要 <code>ARP</code> 协议帮我们找到路由器的 MAC 地址。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg" alt="ARP 广播"></p><p>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。</p><p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p><p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p><blockquote><p>好像每次都要广播获取，这不是很麻烦吗？</p></blockquote><p>放心，在后续操作系统会把本次查询结果放到一块叫做 <strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。</p><p>也就是说，在发包时：</p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</li></ul><blockquote><p>查看 ARP 缓存内容</p></blockquote><p>在 Linux 系统中，我们可以使用 <code>arp -a</code> 命令来查看 ARP 缓存的内容。</p><p>至此，网络包的报文如下图。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg" alt="MAC 层报文"></p><blockquote><p>此时，加上了 MAC 头部的数据包万分感谢，说道 ：“感谢 MAC 大佬，我知道我下一步要去哪了！我现在有很多头部兄弟，相信我可以到达最终的目的地！”。 带着众多头部兄弟的数据包，终于准备要出门了。</p></blockquote><h3 id="TCP-如何保证有序"><a href="#TCP-如何保证有序" class="headerlink" title="TCP 如何保证有序"></a>TCP 如何保证有序</h3><p><strong>参考回答</strong></p><ul><li><p>主机每次发送数据时，<strong>TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包</strong>。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。</p></li><li><p>具体步骤如下：</p><p>（1）<strong>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</strong></p><p>（2）<strong>并为每个已发送的数据包启动一个超时定时器；</strong></p><p>（3）<strong>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</strong></p><p>（4）<strong>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</strong></p><p>（5）<strong>接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</strong></p></li></ul><ol><li><p>TCP Tahoe&#x2F;Reno</p><p>最初的实现，包括慢启动、拥塞避免两个部分。基于重传超时（retransmission timeout&#x2F;RTO）和重复确认为条件判断是否发生了丢包。两者的区别在于：Tahoe算法下如果收到三次重复确认，就进入快重传立即重发丢失的数据包，同时将慢启动阈值设置为当前拥塞窗口的一半，将拥塞窗口设置为1MSS，进入慢启动状态；而Reno算法如果收到三次重复确认，就进入快重传，但不进入慢启动状态，而是直接将拥塞窗口减半，进入拥塞控制阶段，这称为“快恢复”。</p><p>而Tahoe和Reno算法在出现RTO时的措施一致，都是将拥塞窗口降为1个MSS，然后进入慢启动阶段。</p></li><li><p>TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）</p><p>BBR是由Google设计，于2016年发布的拥塞算法。<strong>以往大部分拥塞算法是基于丢包来作为降低传输速率的信号</strong>，而<strong>BBR则基于模型主动探测</strong>。该<strong>算法使用网络最近出站数据分组当时的最大带宽和往返时间来建立网络的显式模型</strong>。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，例如CUBIC。</p></li></ol><p>​<strong>控制时机提前，不再等到丢包时再进行暴力限制，而是控制稳定的发包速度，尽量榨干带宽，却又不让报文在中间设备的缓存队列上累积。</strong></p><p>​为了得到稳定的发包速度，BBR 使用 TCP Pacing 进行发包控制，因此 BBR 的实现也需要底层支持 TCP Pacing; 为了榨干带宽，BBR 会周期性地去探测是否链路条件变好了，如果是，则加大发送速率; 为了不让报文在中间设备的缓存队列上累积，     BBR 会周期性地探测链路的最小 RTT，并使用该最小 RTT 计算发包速率。</p><h3 id="简述-TCP-超时重传"><a href="#简述-TCP-超时重传" class="headerlink" title="简述 TCP 超时重传"></a>简述 TCP 超时重传</h3><p><strong>参考回答</strong></p><p><strong>TCP可靠性</strong>中最重要的一个机制是处理数据超时和重传。TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。</p><h3 id="说说-TCP-可靠性保证"><a href="#说说-TCP-可靠性保证" class="headerlink" title="说说 TCP 可靠性保证"></a>说说 TCP 可靠性保证</h3><p><strong>参考回答</strong></p><p>TCP主要提供了<strong>检验和、序列号&#x2F;确认应答、超时重传、最大消息长度、滑动窗口控制</strong>等方法实现了可靠性传输。</p><ul><li>慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加至拥塞窗口；线性增长达到网络拥塞时立即把拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。</li></ul><h3 id="滑动窗口过小怎么办"><a href="#滑动窗口过小怎么办" class="headerlink" title="滑动窗口过小怎么办"></a>滑动窗口过小怎么办</h3><ol><li>我们可以假设窗口的大小是1，也是就每次只能发送一个数据，并且发送方只有接受方对这个数据进行确认了以后才能发送下一个数据。如果说窗口过小，那么当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟</li></ol><h3 id="述-TCP-的-TIME-WAIT，为什么需要有这个状态"><a href="#述-TCP-的-TIME-WAIT，为什么需要有这个状态" class="headerlink" title="述 TCP 的 TIME_WAIT，为什么需要有这个状态"></a>述 TCP 的 TIME_WAIT，为什么需要有这个状态</h3><p><strong>参考回答</strong></p><ol><li><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p></li><li><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态</p><p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p><p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p></li><li><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p></li><li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</p></li><li><p>保证「被动关闭连接」的一方，能被正确的关闭；</p></li><li><p>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p></li></ol><h3 id="简述什么是-MSL，为什么客户端连接要等待2MSL的时间才能完全关闭"><a href="#简述什么是-MSL，为什么客户端连接要等待2MSL的时间才能完全关闭" class="headerlink" title="简述什么是 MSL，为什么客户端连接要等待2MSL的时间才能完全关闭"></a>简述什么是 MSL，为什么客户端连接要等待2MSL的时间才能完全关闭</h3><p><strong>参考回答</strong></p><ol><li>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</li><li>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</li><li><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong></li></ol><ul><li><p>两个理由：</p><ul><li><p>保证客户端发送的最后一个ACK报文段能够到达服务端。</p><p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p></li><li><p>防止“已失效的连接请求报文段”出现在本连接中。</p><p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p></li></ul></li></ul><h3 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h3><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li><p>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</p></li><li><p>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p><p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</p></li></ul><h3 id="说说什么是-SYN-flood，如何防止这类攻击？"><a href="#说说什么是-SYN-flood，如何防止这类攻击？" class="headerlink" title="说说什么是 SYN flood，如何防止这类攻击？"></a>说说什么是 SYN flood，如何防止这类攻击？</h3><p><strong>参考回答</strong></p><p>广播是向同一子网内所有的端口（包括自己的那个端口）发送消息; 泛洪只是在所有的端口中不包括发送消息的（自己的）那个端口发送消息.  </p><p>关于泛洪，这也是一种交换机常用的转发方式，当交换机要给一个目的主机发送数据帧，而 数据帧中的目的MAC地址不在交换机MAC地址表中，则向<strong>除了接收端口以外</strong>的所有其他端口转发。这个动作就是泛洪</p><ol><li><p>SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS(分布式拒绝服务攻击)的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，使被攻击方资源耗尽（CPU满负荷或内存不足)的攻击方式.</p></li><li><p>有以下三种方法预防或响应网络上的DDoS攻击：</p><p>(1)从互联网服务提供商(ISP)购买服务。</p><p>许多互联网服务提供商(ISP)提供DDoS缓解服务，但是当企业网络受到攻击时，企业需要向互联网服务提供商(ISP)报告事件以开始缓解。这种策略称为“清洁管道”，在互联网服务提供商(ISP)收取服务费用时很受欢迎，但在缓解措施开始之前，通常会导致30到60分钟的网络延迟。</p><p>(2)保留在内部并自己解决。</p><p>企业可以使用入侵防御系统&#x2F;防火墙技术和专用于防御DDoS攻击的专用硬件来实现内部预防和响应DDoS攻击。不幸的是，受影响的流量已经在网络上消耗了宝贵的带宽。这使得该方法最适合在托管设施中配备设备的企业，在这些企业中，流量是通过交叉连接到达互联网服务提供商(ISP)，从而保护流向企业其他部门的下游带宽。</p><p>(3)使用内容分发网络(CDN)。</p><p>由于IT团队可以将基础设施置于内容分发网络(CDN)后面，因此这种方法可以最大程度地减少对企业网络基础设施的攻击。这些网络庞大而多样，如果组织订阅DNS和DDoS缓解措施，则它们可以保护电子商务站点以及企业本身。</p></li></ol><h3 id="说说什么是-TCP-粘包和拆包？"><a href="#说说什么是-TCP-粘包和拆包？" class="headerlink" title="说说什么是 TCP 粘包和拆包？"></a>说说什么是 TCP 粘包和拆包？</h3><p><strong>参考回答</strong></p><ol><li>TCP是个“流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</li></ol><p><strong>答案解析</strong></p><p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。</p><p>（1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；</p><p>（2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；</p><p>（3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；</p><p>（4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。</p><p>如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。</p><h3 id="说一说-TCP-的-keepalive，以及和-HTTP-的-keepalive-的区别？"><a href="#说一说-TCP-的-keepalive，以及和-HTTP-的-keepalive-的区别？" class="headerlink" title="说一说 TCP 的 keepalive，以及和 HTTP 的 keepalive 的区别？"></a>说一说 TCP 的 keepalive，以及和 HTTP 的 keepalive 的区别？</h3><p><strong>参考回答</strong></p><ol><li><p><strong>HTTP Keep-Alive</strong></p><p>在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。</p></li><li><p><strong>TCP KEEPALIVE</strong></p><p>链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。</p></li><li><p>TCP的keepalive机制和HTTP的keep-alive机制是说的完全不同的两个东西，tcp的keepalive是在ESTABLISH状态的时候，双方如何检测连接的可用行。而http的keep-alive说的是如何避免进行重复的TCP三次握手和四次挥手的环节。</p></li></ol><h3 id="说说-TCP-如何加速一个大文件的传输"><a href="#说说-TCP-如何加速一个大文件的传输" class="headerlink" title="说说 TCP 如何加速一个大文件的传输"></a>说说 TCP 如何加速一个大文件的传输</h3><p><strong>参考回答</strong></p><ol><li>建连优化：TCP 在建立连接时，如果丢包，会进入重试，重试时间是 1s、2s、4s、8s 的指数递增间隔，缩短定时器可以让 TCP 在丢包环境建连时间更快，非常适用于高并发短连接的业务场景。</li><li>平滑发包：在 RTT 内均匀发包，规避微分时间内的流量突发，尽量避免瞬间拥塞</li><li>丢包预判：有些网络的丢包是有规律性的，例如每隔一段时间出现一次丢包，例如每次丢包都连续丢几个等，如果程序能自动发现这个规律（有些不明显），就可以针对性提前多发数据，减少重传时间、提高有效发包率。</li><li>RTO 探测：若始终收不到 ACK 报文，则需要触发 RTO 定时器。RTO 定时器一般都时间非常长，会浪费很多等待时间，而且一旦 RTO，CWND 就会骤降（标准 TCP），因此利用 Probe 提前与 RTO 去试探，可以规避由于 ACK 报文丢失而导致的速度下降问题。</li><li>带宽评估：通过单位时间内收到的 ACK 或 SACK 信息可以得知客户端有效接收速率，通过这个速率可以更合理的控制发包速度。</li><li>带宽争抢：有些场景（例如合租）是大家互相挤占带宽的，假如你和室友各 1Mbps 的速度看电影，会把 2Mbps 出口占满，而如果一共有 3 个人看，则每人只能分到 1&#x2F;3。若此时你的流量流量达到 2Mbps，而他俩还都是 1Mbps，则你至少仍可以分到 2&#x2F;(2+1+1) * 2Mbps &#x3D; 1Mbps 的 50% 的带宽，甚至更多，代价就是服务器侧的出口流量加大，增加成本。（TCP 优化的本质就是用带宽换用户体验感）</li></ol><h3 id="说说浏览器从输入-URL-到展现页面的全过程"><a href="#说说浏览器从输入-URL-到展现页面的全过程" class="headerlink" title="说说浏览器从输入 URL 到展现页面的全过程"></a>说说浏览器从输入 URL 到展现页面的全过程</h3><p><strong>参考回答</strong></p><ul><li>1、输入地址</li><li>2、浏览器查找域名的 IP 地址</li><li>3、浏览器向 web 服务器发送一个 HTTP 请求</li><li>4、服务器的永久重定向响应</li><li>6、服务器处理请求</li><li>7、服务器返回一个 HTTP 响应</li><li>8、浏览器显示 HTML</li><li>9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</li></ul><h3 id="简述-HTTP-和-HTTPS-的区别？"><a href="#简述-HTTP-和-HTTPS-的区别？" class="headerlink" title="简述 HTTP 和 HTTPS 的区别？"></a>简述 HTTP 和 HTTPS 的区别？</h3><p><strong>参考回答</strong></p><ol><li><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p></li><li><p>HTTP与HTTPS的区别</p></li></ol><ul><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li><li><strong>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</strong></li><li><strong>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</strong></li><li><strong>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</strong></li><li><strong>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</strong></li></ul><h3 id="说说-HTTP-中的-referer-头的作用"><a href="#说说-HTTP-中的-referer-头的作用" class="headerlink" title="说说 HTTP 中的 referer 头的作用"></a>说说 HTTP 中的 referer 头的作用</h3><p><strong>参考回答</strong></p><ol><li><p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p></li><li><p>防盗链。假如在<a href="https://www.nowcoder.com/issue/www.google.com">www.google.com</a>里有一个<code>[www.baidu.com](https://www.nowcoder.com/issue/www.baidu.com)</code>链接，那么点击进入这个<code>[www.baidu.com](https://www.nowcoder.com/issue/www.baidu.com)</code>，它的header信息里就有：Referer&#x3D; <a href="http://www.google.com/">http://www.google.com</a></p><p>只允许我本身的网站访问本身的图片服务器，假如域是<a href="http://www.google.com/">www.google.com</a>，那么图片服务器每次取到Referer来判断一下域名是不是<a href="http://www.google.com/">www.google.com</a>，如果是就继续访问，不是就拦截。</p><p>将这个http请求发给服务器后，如果服务器要求必须是某个地址或者某几个地址才能访问，而你发送的referer不符合他的要求，就会拦截或者跳转到他要求的地址，然后再通过这个地址进行访问。</p></li><li><p>防止恶意请求</p><p>比如静态请求是*.html结尾的，动态请求是*.shtml，那么由此可以这么用，所有的*.shtml请求，必须Referer为我自己的网站。</p></li><li><p>空Referer</p><p><strong>定义</strong>：Referer头部的内容为空，或者，一个HTTP请求中根本不包含Referer头部（一个请求并不是由链接触发产生的）</p><p>直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含Referer字段的，因为这是一个“凭空产生”的HTTP请求，并不是从一个地方链接过去的。</p><p>那么在防盗链设置中，允许空Referer和不允许空Referer有什么区别？</p><p>允许Referer为空，意味着你允许比如浏览器直接访问。</p></li><li><p>防御CSRF</p><p>比对HTTP 请求的来源地址，如果Referer中的地址是安全可信任的地址，那么就放行</p></li></ol><h3 id="3-35-说说-HTTP-的方法有哪些"><a href="#3-35-说说-HTTP-的方法有哪些" class="headerlink" title="3.35 说说 HTTP 的方法有哪些"></a>3.35 说说 HTTP 的方法有哪些</h3><p><strong>参考回答</strong></p><ul><li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li><li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li><li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li><li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li><li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li><li>OPTIONS：查询相应URI支持的HTTP方法。</li></ul><h3 id="3-36-简述-HTTP-1-0，1-1，2-0-，3-0-的主要区别"><a href="#3-36-简述-HTTP-1-0，1-1，2-0-，3-0-的主要区别" class="headerlink" title="3.36 简述 HTTP 1.0，1.1，2.0 ，3.0 的主要区别"></a>3.36 简述 HTTP 1.0，1.1，2.0 ，3.0 的主要区别</h3><p><strong>参考回答</strong></p><p>http&#x2F;1.0 :</p><ol><li>默认不支持长连接，需要设置keep-alive参数指定</li><li>强缓存expired、协商缓存last-modified\if-modified-since 有一定的缺陷</li></ol><p>http 1.1 :</p><ol><li>默认长连接(keep-alive)，http请求可以复用Tcp连接，但是同一时间只能对应一个http请求(http请求在一个Tcp中是串行的)</li><li>增加了强缓存cache-control、协商缓存etag\if-none-match 是对http&#x2F;1 缓存的优化</li></ol><p>http&#x2F;2.0 :</p><ol><li><p>多路复用，一个Tcp中多个http请求是并行的 (雪碧图、多域名散列等优化手段http&#x2F;2中将变得多余)</p></li><li><p>通过 Stream 这个设计，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，解决了 HTTP&#x2F;1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量</p></li><li><p>二进制格式编码传输</p></li><li><p>服务器主动推送资源</p></li><li><p>HTTP&#x2F;2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 <strong>HPACK</strong> 算法</p></li><li><p>总结</p><p>HTTP&#x2F;2 协议其实还有很多内容，比如流控制、流状态、依赖关系等等。</p><p>这次主要介绍了关于 HTTP&#x2F;2 是如何提升性能的几个方向，它相比 HTTP&#x2F;1 大大提高了传输效率、吞吐能力。</p><p>第一点，对于常见的 HTTP 头部通过<strong>静态表和 Huffman 编码</strong>的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立<strong>动态表</strong>，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。</p><p>不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP&#x2F;2 连接时长或者请求次数。</p><p>第二点，<strong>HTTP&#x2F;2 实现了 Stream 并发</strong>，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 可以并发，即使乱序发送帧也没问题，比如发送 A 请求帧 1 -&gt; B 请求帧 1 -&gt; A 请求帧 2 -&gt; B 请求帧2，但是同一个 Stream 里的帧必须严格有序。</p><p>另外，可以根据资源的渲染顺序来设置 Stream 的<strong>优先级</strong>，从而提高用户体验。</p><p>第三点，<strong>服务器支持主动推送资源</strong>，大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。</p><p>HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题，看似很完美了，但是 HTTP&#x2F;2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p><p><strong>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</strong></p><p>有没有什么解决方案呢？既然是 TCP 协议自身的问题，那干脆放弃 TCP 协议，转而使用 UDP 协议作为传输层协议，这个大胆的决定，HTTP&#x2F;3 协议做了！</p><h3 id="美中不足的-HTTP-x2F-2"><a href="#美中不足的-HTTP-x2F-2" class="headerlink" title="美中不足的 HTTP&#x2F;2"></a>美中不足的 HTTP&#x2F;2</h3></li></ol><ul><li>队头阻塞；</li><li>TCP 与 TLS 的握手时延迟；</li><li>网络迁移需要重新连接；</li></ul><p>HTTP&#x2F;3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在「应用层」实现了 <strong>QUIC 协议</strong>，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。</p><p>QUIC 协议的优点有很多，这里举例几个，比如：</p><ul><li>无队头阻塞；</li><li>更快的连接建立；</li><li>连接迁移</li></ul><p><em>Host</em> 字段</p><p>客户端发送请求时，用来指定服务器的域名</p><p><em>Content-Length 字段</em></p><p>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度，<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong></p><p><em>Connection 字段</em></p><p><code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code></p><p><em>Content-Type 字段</em></p><p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p><em>Content-Encoding 字段</em></p><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><h3 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h3><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong></p><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p><p>协商缓存：当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通<strong>过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</strong></p><p>****<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong> </p><p><strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong></p><p>下图是强制缓存和协商缓存的工作流程：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" alt="img"></p><p>当使用 ETag 字段实现的协商缓存的过程：</p><ul><li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p></li><li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p><ul><li>如果没有过期，则直接使用本地缓存；</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li></ul></li><li><p>服务器再次收到请求后，</p><p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</p><p>：</p><ul><li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li></ul></li><li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p></li></ul><h3 id="3-37-说说-HTTP-常见的响应状态码及其含义"><a href="#3-37-说说-HTTP-常见的响应状态码及其含义" class="headerlink" title="3.37 说说 HTTP 常见的响应状态码及其含义"></a>3.37 说说 HTTP 常见的响应状态码及其含义</h3><p><strong>参考回答</strong></p><ul><li><strong>200</strong> : 从状态码发出的请求被服务器正常处理。</li><li><strong>204</strong> : 服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分【即没有内容】。</li><li><strong>206</strong> : 部分的内容（如：客户端进行了范围请求，但是服务器成功执行了这部分的干请求）。</li><li><strong>301</strong> : 跳转，代表永久性重定向（请求的资源已被分配了新的URI，以后已使用资源，现在设置了URI）。</li><li><strong>302</strong> : 临时性重定向（请求的资源已经分配了新的URI，希望用户本次能够使用新的URI来进行访问）。</li><li><strong>303</strong> : 由于请求对应的资源存在的另一个URI（因使用get方法，定向获取请求的资源）。</li><li><strong>304</strong> : 客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回了 304。</li><li><strong>307</strong> : 临时重定向【该状态码与302有着相同的含义】。</li><li><strong>400</strong> : 请求报文中存在语法错误（当错误方式时，需修改请求的内容后，再次发送请求）。</li><li><strong>401</strong> : 发送的请求需要有通过HTTP认证的认证信息。</li><li><strong>403</strong> : 对请求资源的访问被服务器拒绝了。</li><li><strong>404</strong> : 服务器上无法找到请求的资源。</li><li><strong>500</strong> : 服务器端在执行请求时发生了错误。</li><li><strong>503</strong> : 服务器暂时处于超负载或者是正在进行停机维护，现在无法处理请求。</li></ul><p><strong>答案解析</strong></p><ul><li>1XX : 信息类状态码（表示接收请求状态处理）</li><li>2XX : 成功状态码（表示请求正常处理完毕）</li><li>3XX : 重定向（表示需要进行附加操作，已完成请求）</li><li>4XX : 客户端错误（表示服务器无法处理请求）</li><li>5XX : 服务器错误状态码（表示服务器处理请求的时候出错）</li></ul><h3 id="3-38-说说-GET请求和-POST-请求的区别"><a href="#3-38-说说-GET请求和-POST-请求的区别" class="headerlink" title="3.38 说说 GET请求和 POST 请求的区别"></a>3.38 说说 GET请求和 POST 请求的区别</h3><p><strong>参考回答</strong></p><ol><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li></ol><h3 id="3-39-说说-Cookie-和-Session-的关系和区别是什么"><a href="#3-39-说说-Cookie-和-Session-的关系和区别是什么" class="headerlink" title="3.39 说说 Cookie 和 Session 的关系和区别是什么"></a>3.39 说说 Cookie 和 Session 的关系和区别是什么</h3><ol><li>Cookie与Session都是会话的一种方式。它们的典型使用场景比如“购物车”，当你点击下单按钮时，服务端并不清楚具体用户的具体操作，为了标识并跟踪该用户，了解购物车中有几样物品，服务端通过为该用户创建Cookie&#x2F;Session来获取这些信息。</li><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗  考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能  考虑到减轻服务器性能方面，应当使用COOKIE。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li></ol><h3 id="3-40-简述-HTTPS-的加密与认证过程"><a href="#3-40-简述-HTTPS-的加密与认证过程" class="headerlink" title="3.40 简述 HTTPS 的加密与认证过程"></a>3.40 简述 HTTPS 的加密与认证过程</h3><p><strong>参考回答</strong></p><ol><li><p>客户端在浏览器中输入一个https网址，然后连接到server的443端口 采用https协议的server必须有一套数字证书（一套公钥和密钥） 首先server将证书（公钥）传送到客户端 客户端解析证书，验证成功，则生成一个随机数（私钥），并用证书将该随机数加密后传回server server用密钥解密后，获得这个随机值，然后将要传输的信息和私钥通过某种算法混合在一起（加密）传到客户端 客户端用之前的生成的随机数（私钥）解密服务器端传来的信息</p></li><li><p>首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。</p><p>用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。</p></li></ol><h3 id="HTTP-x2F-1-1-如何优化"><a href="#HTTP-x2F-1-1-如何优化" class="headerlink" title="HTTP&#x2F;1.1 如何优化"></a>HTTP&#x2F;1.1 如何优化</h3><ul><li><em>尽量避免发送 HTTP 请求</em>；</li><li><em>在需要发送 HTTP 请求时，考虑如何减少请求次数</em>；</li><li><em>减少服务器的 HTTP 响应的数据大小</em></li></ul><h4 id="尽量避免发送-HTTP-请求；"><a href="#尽量避免发送-HTTP-请求；" class="headerlink" title="尽量避免发送 HTTP 请求；"></a><em>尽量避免发送 HTTP 请求</em>；</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98%E8%AE%BF%E9%97%AE.png" alt="img"></p><p>聪明的你可能想到了，万一缓存的响应不是最新的，而客户端并不知情，那么该怎么办呢？</p><p>放心，这个问题 HTTP 设计者早已考虑到。</p><p>所以，服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。</p><h4 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h4><p><strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong></p><h4 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h4><p><strong>一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接</strong>，那么如果合并了请求，也就会<strong>减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间</strong>。</p><p>有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用 <code>CSS Image Sprites</code> 技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片，<code>webpack</code> 等打包工具将 js、css 等资源合并打包成大文件，也是能达到类似的效果</p><h4 id="延迟发送请求"><a href="#延迟发送请求" class="headerlink" title="延迟发送请求"></a>延迟发送请求</h4><p>不要一口气吃成大胖子，一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「<strong>按需获取</strong>」的方式，来减少第一时间的 HTTP 请求次数</p><h4 id="减少HTTP-响应的数据"><a href="#减少HTTP-响应的数据" class="headerlink" title="减少HTTP 响应的数据"></a>减少HTTP 响应的数据</h4><p>压缩的方式一般分为 2 种，分别是：</p><ul><li><em>无损压缩</em>；</li><li><em>有损压缩</em>；</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。</p><p>第二个思路是，减少 HTTP 请求的次数，有以下的方法：</p><ol><li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；</li><li>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；</li><li>按需访问资源，只访问当前用户看得到&#x2F;用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。</li></ol><p>第三思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。</p><h3 id="HTTPS-RSA-握手解析"><a href="#HTTPS-RSA-握手解析" class="headerlink" title="HTTPS RSA 握手解析"></a>HTTPS RSA 握手解析</h3><p><a href="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/https_rsa.png">https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/https_rsa.png</a></p><h3 id="HTTPS-如何优化"><a href="#HTTPS-如何优化" class="headerlink" title="HTTPS 如何优化"></a>HTTPS 如何优化</h3><p>硬件优化</p><p>​HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型</p><p>软件优化</p><ul><li>将 Linux 内核从 2.x 升级到 4.x；</li><li>将 OpenSSL 从 1.0.1 升级到 1.1.1；</li></ul><p>协议优化</p><p> <strong>RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高</strong>。</p><p>因此如果可以，尽量<strong>选用 ECDHE 密钥交换</strong>算法替换 RSA 算法，因为该算法由于支持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，发送加密的应用数据，以此将 <strong>TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高，具备前向安全性</strong>。</p><p>TLS 升级</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>对于硬件优化的方向，因为 HTTPS 是属于计算密集型，应该选择计算力更强的 CPU，而且最好选择<strong>支持 AES-NI 特性的 CPU</strong>，这个特性可以在硬件级别优化 AES 对称加密算法，加快应用数据的加解密。</p><p>对于软件优化的方向，如果可以，把软件升级成较新的版本，比如将 Linux 内核 2.X 升级成 4.X，将 openssl 1.0.1 升级到 1.1.1，因为新版本的软件不仅会提供新的特性，而且还会修复老版本的问题。</p><p>对于协议优化的方向：</p><ul><li>密钥交换算法应该选择 <strong>ECDHE 算法</strong>，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。</li><li>将 TLS1.2 升级 <strong>TLS1.3</strong>，因为 TLS1.3 的握手过程只需要 1 RTT，而且安全性更强。</li></ul><p>对于证书优化的方向：</p><ul><li>服务器应该选用 <strong>ECDSA 证书</strong>，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多，这样可以提高证书传输的效率；</li><li>服务器应该开启 <strong>OCSP Stapling</strong> 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；</li></ul><p>对于重连 HTTPS 时，我们可以使用一些技术让客户端和服务端使用上一次 HTTPS 连接使用的会话密钥，直接恢复会话，而不用再重新走完整的 TLS 握手过程。</p><p>常见的<strong>会话重用</strong>技术有 Session ID 和 Session Ticket，用了会话重用技术，当再次重连 HTTPS 时，只需要 1 RTT 就可以恢复会话。对于 TLS1.3 使用 Pre-shared Key 会话重用技术，只需要 0 RTT 就可以恢复会话。</p><p>这些会话重用技术虽然好用，但是存在一定的安全风险，它们不仅不具备前向安全，而且有重放攻击的风险，所以应当对会话密钥设定一个合理的过期时间。</p><h3 id="既然有-HTTP-协议，为什么还要有-RPC"><a href="#既然有-HTTP-协议，为什么还要有-RPC" class="headerlink" title="既然有 HTTP 协议，为什么还要有 RPC"></a>既然有 HTTP 协议，为什么还要有 RPC</h3><p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。</p><p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p><ul><li>纯裸 TCP 是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li><li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。<strong>目的是希望程序员能像调用本地方法那样去调用远端的服务方法</strong>。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li><li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合</strong>。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li><li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP&#x2F;1.1 <strong>性能</strong>要更好，所以大部分公司内部都还在使用 RPC。</li><li><strong>HTTP&#x2F;2.0</strong> 在 <strong>HTTP&#x2F;1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li><li></li></ul><h3 id="既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="既然有 HTTP 协议，为什么还要有 WebSocket？"></a>既然有 HTTP 协议，为什么还要有 WebSocket？</h3><p><strong>WebSocket</strong> : <strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件</p><h4 id="使用-HTTP-不断轮询"><a href="#使用-HTTP-不断轮询" class="headerlink" title="使用 HTTP 不断轮询"></a>使用 HTTP 不断轮询</h4><p>其实问题的痛点在于，<strong>怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。</strong></p><p>最常见的解决方案是，<strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong></p><p>这其实时一种「<strong>伪</strong>」服务器推的形式。</p><p>它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已</p><h4 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h4><p>我们知道，HTTP 请求发出后，一般会给服务器留一定的时间做响应，比如 3 秒，规定时间内没返回，就认为是超时。</p><p>如果我们的 HTTP 请求<strong>将超时设置的很大</strong>，比如 30 秒，<strong>在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong></p><p>这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的</p><p>我们知道 TCP 连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>。</p><p>而现在使用最广泛的<code>HTTP/1.1</code>，也是基于TCP协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这就是所谓的<strong>半双工</strong>。</p><p>也就是说，好好的全双工 TCP，被 HTTP&#x2F;1.1 用成了半双工。</p><p>为什么？</p><p>这是由于 HTTP 协议设计之初，考虑的是看看网页文本的场景，能做到<strong>客户端发起请求再由服务器响应</strong>，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。</p><p>所以，为了更好的支持这样的场景，我们需要另外一个<strong>基于TCP的新协议</strong>。</p><p>于是新的应用层协议<strong>WebSocket</strong>就被设计出来了。</p><p>大家别被这个名字给带偏了。虽然名字带了个socket，但其实 <strong>socket 和 WebSocket 之间，就跟雷峰和雷峰塔一样，二者接近毫无关系</strong>。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>WebSocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>T2a6wZlAwhgQNqruZ2YUyg==\r\n</span><br></pre></td></tr></table></figure><p>这些 header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP&#x2F;1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。</li><li>在 HTTP&#x2F;1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li><li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。</li><li>WebSocket 和 socket 几乎没有任何关系，只是叫法相似。</li><li>正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址还分为私网地址和公网地址，其中私网地址只能在局域网内部使用，不能访问Internet。</p><p>私有IP地址：</p><p>①　A类：<strong>10.0.0.0-10.255.255.255</strong></p><p>②　B类：<strong>172.16.0.0-172.31.255.255</strong></p><p>③　C类：<strong>192.168.0.0-192.168.255.255</strong></p><p>  A 类地址 8bit 网络号 + 24bit 主机号 </p><p>  B 类地址 16bit 网络号 + 16bit 主机号 </p><p>  C 类地址 24bit 网络号 + 8bit 主机号 </p><p>  D 类地址 多播地址        </p><p>  E 类地址 保留</p><p>特殊地址：</p><p>本地环回地址：127.0.0.1（测试本机的网络配置，能ping通127.0.0.1说明本机的网卡和IP协议安装都没有问题）</p><p>本地广播地址：255.255.255.255            广播地址主机号全1</p><p>IP地址 &amp; 子网掩码 &#x3D; 网络地址  </p><p>网络地址 || （~子网掩码）&#x3D;广播地址</p><p>邮件</p><p>  用户*** –http–&gt; 邮件服务器 —–smtp —&gt; 邮件服务器 —http —&gt; 用户*** </p><p>IEEE 802系列标准是IEEE 802 LAN&#x2F;MAN 标准***会制定的局域网、城域网技术标准。其中最广泛使用的有以太网、令牌环、无线局域网等</p><p>我国要求局用程控交换机的系统中断时间为平均每年不超过3分钟</p><p>  IEEE <a href="https://baike.baidu.com/item/802.1">802.1</a> ：局域网体系结构、寻址、<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94/10501073">网络互联</a>和网络。 </p><p>  IEEE 802.1A：概述和系统结构。 </p><p>  IEEE 802.1B：网络管理和网络互连。 </p><p>  IEEE 802.2 ：<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6/3530198">逻辑链路控制</a>子层（<a href="https://baike.baidu.com/item/LLC/10072443">LLC</a>）的定义。 </p><p>  IEEE <a href="https://baike.baidu.com/item/802.3/960717">802.3</a> ：<a href="https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a><a href="https://baike.baidu.com/item/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/10081534">介质访问控制</a>协议 （<a href="https://baike.baidu.com/item/CSMA%2FCD">CSMA&#x2F;CD</a>）及<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%B1%82/4329158">物理层</a>技术规范。 </p><p>  IEEE <a href="https://baike.baidu.com/item/802.4/7998449">802.4</a> ：<a href="https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%80%BB%E7%BA%BF%E7%BD%91/1627852">令牌总线网</a>（Token-Bus）的介质访问控制协议及物理层技术规范。 </p><p>  IEEE <a href="https://baike.baidu.com/item/802.5/7998550">802.5</a> ：<a href="https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E7%8E%AF">令牌环</a>网（Token-Ring)的介质访问控制协议及物理层技术规范。 </p><p>  IEEE 802.6 ：城域网介质访问控制协议DQDB （Distributed Queue Dual Bus <a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97%E5%8F%8C%E6%80%BB%E7%BA%BF/3023478">分布式队列双总线</a>）及物理层技术规范。 </p><p>  IEEE 802.7 ：宽带技术咨询组，提供有关宽带联网的技术咨询。 </p><p>  IEEE 802.8 ：光纤技术咨询组，提供有关光纤联网的技术咨询。 </p><p>  IEEE 802.9 ：综合声音数据的局域网（IVD LAN）<a href="https://baike.baidu.com/item/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/10081534">介质访问控制</a>协议及<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%B1%82/4329158">物理层</a>技术规范。 </p><p>  IEEE <a href="https://baike.baidu.com/item/802.1">802.1</a>0：网络安全技术咨询组，定义了网络<a href="https://baike.baidu.com/item/%E4%BA%92%E6%93%8D%E4%BD%9C/9878042">互操作</a>的认证和加密方法。 </p><p>  IEEE <a href="https://baike.baidu.com/item/802.11">802.11</a>：<a href="https://baike.baidu.com/item/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91">无线局域网</a>（WLAN）的介质访问控制协议及物理层技术规范</p><p> 名字转换             DNS             UDP                   文件传送             TFTP             UDP                   路由选择协议             RIP             UDP                   IP地址配置             DHCP             UDP                   网络管理             SNMP             UDP                   远程文件服务器             NFS             UDP                   IP电话             专用协议             UDP                   流式多媒体通信             专用协议             UDP                   多播             IGMP             UDP                   电子邮件             SMTP             TCP                   远程终端接入             TELNET             TCP                   万维网             HTTP             TCP                   文件传送             FTP             TCP  </p><p>互联网计算机在相互通信时必须遵循统一的规则称为网络协议 </p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go vs C++ vs python 泛型</title>
      <link href="/anxiangblog.github.io/2023/04/27/%E6%B3%9B%E5%9E%8B/"/>
      <url>/anxiangblog.github.io/2023/04/27/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><p>泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。ーー换句话说，在编写某些代码或数据结构时先不提供值的类型，而是之后再提供。</p><p>这个函数只能接收<code>[]int</code>类型的参数，如果我们想支持<code>[]float64</code>类型的参数，我们就需要再定义一个<code>reverseFloat64Slice</code>函数。</p><p>一遍一遍地编写相同的功能是低效的，实际上这个反转切片的函数并不需要知道切片中元素的类型，但为了适用不同的类型我们把一段代码重复了很多遍。</p><h3 id="泛型实现"><a href="#泛型实现" class="headerlink" title="泛型实现"></a>泛型实现</h3><p>泛型为Go语言添加了三个新的重要特性:</p><ol><li>函数和类型的类型参数。</li><li>将接口类型定义为类型集，包括没有方法的类型。</li><li>类型推断，它允许在调用函数时在许多情况下省略类型参数。</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float64</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m1 := min[<span class="type">int</span>](<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">m2 := min[<span class="type">float64</span>](<span class="number">-0.1</span>, <span class="number">-0.2</span>)  <span class="comment">// -0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向 min 函数提供类型参数(在本例中为int和float64)称为实例化（ instantiation ）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先，编译器在整个泛型函数或类型中将所有类型形参（type parameters）替换为它们各自的类型实参（type arguments）。</span></span><br><span class="line"><span class="comment">//其次，编译器验证每个类型参数是否满足相应的约束。</span></span><br><span class="line"></span><br><span class="line">fmin := min[<span class="type">float64</span>] <span class="comment">// 类型实例化，编译器生成T=float64的min函数</span></span><br><span class="line">m2 = fmin(<span class="number">1.2</span>, <span class="number">2.3</span>)  <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure><h3 id="类型参数的使用"><a href="#类型参数的使用" class="headerlink" title="类型参数的使用"></a>类型参数的使用</h3><h4 id="类型参数的使用-1"><a href="#类型参数的使用-1" class="headerlink" title="类型参数的使用"></a>类型参数的使用</h4><p>除了函数中支持使用类型参数列表外，类型也可以使用类型参数列表。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span> | <span class="type">string</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map[K <span class="type">int</span> | <span class="type">string</span>, V <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">map</span>[K]V</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tree[T <span class="keyword">interface</span>&#123;&#125;] <span class="keyword">struct</span> &#123;</span><br><span class="line">left, right *Tree[T]</span><br><span class="line">value       T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用泛型类型，必须进行实例化。<code>Tree[string]</code>是使用类型实参<code>string</code>实例化 <code>Tree</code> 的示例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringTree Tree[<span class="type">string</span>]</span><br></pre></td></tr></table></figure><h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>&#x2F;&#x2F;作为类型约束使用的接口类型可以事先定义并支持复用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型约束字面量，通常外层interface&#123;&#125;可省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">interface</span></span>&#123; <span class="type">int</span> | <span class="type">float64</span> &#125;](a, b T) T &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为类型约束使用的接口类型可以事先定义并支持复用。</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="type">int</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">Value</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型集"><a href="#类型集" class="headerlink" title="类型集"></a>类型集</h3><p><strong>Go1.18开始接口类型的定义也发生了改变，由过去的接口类型定义方法集（method set）变成了接口类型定义类型集（type set）。</strong>也就是说，接口类型现在可以用作值的类型，也可以用作类型约束。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> V <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="type">int</span> | <span class="type">string</span> | <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就定义了一个包含 <code>int</code>、 <code>string</code> 和 <code>bool</code> 类型的类型集。</p><p>在 Go 1.18中，接口既可以像以前一样包含方法和嵌入式接口，但也可以嵌入非接口类型、类型并集和基础类型的集合。</p><p>当用作类型约束时，由接口定义的类型集精确地指定允许作为相应类型参数的类型。</p><ul><li><p><code>|</code>符号</p><p><code>T1 | T2</code>表示类型约束为T1和T2这两个类型的并集，例如下面的<code>Integer</code>类型表示由<code>Signed</code>和<code>Unsigned</code>组成。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Signed | Unsigned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>~</code>符号</p><p><code>~T</code>表示所以底层类型是T的类型，例如<code>~string</code>表示所有底层类型是<code>string</code>的类型集合。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span>  <span class="comment">// MyString的底层类型是string</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>~</code>符号后面只能是基本类型。</p></li></ul><p>接口作为类型集是一种强大的新机制，是使类型约束能够生效的关键。目前，使用新语法表的接口只能用作类型约束。</p><h4 id="any"><a href="#any" class="headerlink" title="any"></a>any</h4><p>空接口在类型参数列表中很常见，在Go 1.18引入了一个新的预声明标识符，作为空接口类型的别名。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/builtin/builtin.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> any = <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>由此，我们可以使用如下代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>[<span class="title">S</span> ~[]<span class="title">E</span>, <span class="title">E</span> <span class="title">any</span>]<span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>最后一个新的主要语言特征是类型推断。从某些方面来说，这是语言中最复杂的变化，但它很重要，因为它能让人们在编写调用泛型函数的代码时更自然。</p><p>在许多情况下，编译器可以从普通参数推断 <code>T</code> 的类型实参。这使得代码更短，同时保持清晰。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, m <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">m = min(a, b) <span class="comment">// 无需指定类型实参</span></span><br></pre></td></tr></table></figure><h4 id="约束类型推断"><a href="#约束类型推断" class="headerlink" title="约束类型推断"></a>约束类型推断</h4><p>Point 类型有方法 但是泛型后无法找到String()方法，需要声明一下<code>Point</code>类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Scale 返回切片中每个元素都乘c的副本切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span>[<span class="title">E</span> <span class="title">constraints</span>.<span class="title">Integer</span>]<span class="params">(s []E, c E)</span></span> []E &#123;</span><br><span class="line">    r := <span class="built_in">make</span>([]E, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        r[i] = v * c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point []<span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    b, _ := json.Marshal(p)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于一个<code>Point</code>其实就是一个整数切片，我们可以使用前面编写的<code>Scale</code>函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleAndPrint</span><span class="params">(p Point)</span></span> &#123;</span><br><span class="line">    r := Scale(p, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(r.String()) <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这代码会编译失败，输出<code>r.String undefined (type []int32 has no field or method String</code>的错误。</p><p>问题是<code>Scale</code>函数返回类型为<code>[]E</code>的值，其中<code>E</code>是参数切片的元素类型。当我们使用<code>Point</code>类型的值调用<code>Scale</code>（其基础类型为[]int32）时，我们返回的是<code>[]int32</code>类型的值，而不是<code>Point</code>类型。这源于泛型代码的编写方式，但这不是我们想要的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span>[<span class="title">S</span> ~[]<span class="title">E</span>, <span class="title">E</span> <span class="title">constraints</span>.<span class="title">Integer</span>]<span class="params">(s S, c E)</span></span> S &#123;</span><br><span class="line">    r := <span class="built_in">make</span>(S, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        r[i] = v * c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，如果你发现自己多次编写完全相同的代码，而这些代码之间的唯一区别就是使用的类型不同，这个时候你就应该考虑是否可以使用类型参数。</p><p>泛型和接口类型之间并不是替代关系，而是相辅相成的关系。泛型的引入是为了配合接口的使用，让我们能够编写更加类型安全的Go代码，并能有效地减少重复代码。</p><p><strong>这意味着使用类型参数通常不会比使用接口类型快。因此，不要为了速度而从接口类型更改为类型参数，因为它可能不会运行得更快</strong></p><h2 id="Go反射-泛型"><a href="#Go反射-泛型" class="headerlink" title="Go反射 泛型"></a>Go反射 泛型</h2><p>Go具有运行时反射。反射允许一种泛型编程，因为它允许你编写适用于任何类型的代码。</p><p>如果某些操作甚至必须支持没有方法的类型（不能使用接口类型），并且每个类型的操作都不同（不能使用类型参数），请使用反射。</p><p>encoding&#x2F;json包就是一个例子。我们不想要求我们编码的每个类型都有MarshalJSON方法，所以我们不能使用接口类型。但对接口类型的编码与对结构类型的编码不同，因此我们不应该使用类型参数。相反，该包使用反射。代码不简单，但它有效</p><p>最后，关于何时使用泛型的讨论可以简化为一个简单的指导原则。</p><p>如果您发现自己多次编写完全相同的代码，其中副本之间的唯一区别是代码使用不同的类型，请考虑是否可以使用类型参数。</p><p>另一种说法是，在注意到要多次编写完全相同的代码之前，应该避免使用类型参数。</p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>Python 是一种动态类型语言，它的变量类型是在运行时动态推断的。与其他静态类型语言不同，Python 并没有直接的泛型类型。但是，可以通过使用类型变量来实现类似泛型的效果.</p><p><strong>在 Python 中，我们可以使用类型提示（Type Hints）和 TypeVar 两个模块来模拟泛型。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, TypeVar</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_list</span>(<span class="params">lst: <span class="type">List</span>[T]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">        <span class="built_in">print</span>(item)   </span><br><span class="line">        </span><br><span class="line">int_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print_list[<span class="built_in">int</span>](int_list)</span><br><span class="line"></span><br><span class="line">str_list = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>]</span><br><span class="line">print_list[<span class="built_in">str</span>](str_list)</span><br><span class="line">       </span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>挺简单的223333333</p><p>除了类型提示和类型变量之外，Python 还提供了一些其他的泛型工具和库，例如 <code>typing</code> 模块中的 <code>Union</code> 和 <code>Optional</code> 类型，以及第三方库如 <code>Generics</code> 和 <code>dataclasses</code> 等。这些工具可以帮助开发人员更好地进行类型检查和处理，提高代码的可读性和可维护性。</p><p>另外，Python 的泛型机制虽然比其他语言灵活，但也存在一些限制和缺陷。例如，Python 的类型提示只是一种静态检查，运行时仍然可以接受不同的类型，这可能导致类型错误和运行时异常。此外，在使用泛型时需要谨慎处理类型转换和类型推断等问题，避免出现意外行为和难以调试的问题。</p><h3 id="typing-模块"><a href="#typing-模块" class="headerlink" title="typing 模块"></a><code>typing</code> 模块</h3><p><code>typing</code> 模块是 Python 3.5 引入的，它为类型提示提供了很多有用的工具和注释。</p><p>该模块提供了许多类型提示，例如：</p><ul><li><code>List[T]</code>：代表一个由类型 T 组成的列表。</li><li><code>Tuple[T1, T2, ..., Tn]</code>：代表一个由类型 T1、T2、…、Tn 组成的元组。</li><li><code>Dict[Tkey, Tvalue]</code>：代表一个由键值对组成的字典，其中键的类型为 Tkey，值的类型为 Tvalue。</li><li><code>Set[T]</code>：代表一个由类型 T 组成的集合。</li><li><code>Union[T1, T2, ..., Tn]</code>：代表类型 T1、T2、…、Tn 中的任何一个类型。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">numbers: <span class="type">List</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(numbers) / <span class="built_in">len</span>(numbers)</span><br><span class="line"></span><br><span class="line">当然，这只是类型提示的一部分，实际上 Python 解释器并不会检查这些类型。不过，这些类型提示对于代码维护和可读性来说是很有帮助的。</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="模板（Template）"><a href="#模板（Template）" class="headerlink" title="模板（Template）"></a>模板（Template）</h3><p><strong>C++ 的泛型是通过模板（Template）实现的。模板是一种代码生成机制，可以在编译时根据参数类型自动生成代码。C++ 模板支持函数模板和类模板两种</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">函数模板</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">类模板</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以使用泛型来实现一个通用的排序算法，可以接受任何类型的数组，并按照一定的规则进行排序。比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void printArray(std::vector&lt;T&gt; arr) &#123;</span><br><span class="line">    for (auto x : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void bubbleSort(std::vector&lt;T&gt;&amp; arr) &#123;</span><br><span class="line">    int n = arr.size();</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n - i - 1; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                std::swap(arr[j], arr[j + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; arr1 = &#123;3, 2, 1, 5, 4&#125;;</span><br><span class="line">    std::vector&lt;double&gt; arr2 = &#123;3.14, 2.71, 1.41, 4.0, 1.73&#125;;</span><br><span class="line">    std::vector&lt;std::string&gt; arr3 = &#123;&quot;hello&quot;, &quot;world&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    bubbleSort(arr1);</span><br><span class="line">    bubbleSort(arr2);</span><br><span class="line">    bubbleSort(arr3);</span><br><span class="line"></span><br><span class="line">    printArray(arr1);</span><br><span class="line">    printArray(arr2);</span><br><span class="line">    printArray(arr3);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数模板-高级用法"><a href="#函数模板-高级用法" class="headerlink" title="函数模板 高级用法"></a>函数模板 高级用法</h3><ol><li>模板特化（Template Specialization）：对于某些特定的类型，需要使用不同于模板定义的实现，这时候可以使用模板特化来实现。</li></ol><p>例如，以下代码定义了一个函数模板 <code>print</code>，用于输出传入的参数，当模板参数为 <code>int</code> 类型时，需要使用特殊的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The int value is: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.可变参数模板（Variadic Templates）：函数模板可以接受任意数量的参数，这个数量在编译期是不确定的。可变参数模板就是指能够接受可变数量参数的函数模板。</p><p>例如，以下代码定义了一个可变参数模板 <code>print</code>，可以输出任意数量的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cppCopy codetemplate &lt;typename T&gt;</span><br><span class="line">void print(T arg) &#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename... Args&gt;</span><br><span class="line">void print(T arg, Args... args) &#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; &quot;, &quot;;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3.<strong>SFINAE</strong>（Substitution Failure Is Not An Error）：这是一种编译期技术，用于在编译期对模板参数进行过滤，使得只有符合条件的模板参数才能够使用模板函数。</p><p>例如，以下代码定义了一个函数模板 <code>foo</code>，使用了 SFINAE 技术，<strong>只有当模板参数是一个整型类型时才会编译通过</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cppCopy codetemplate &lt;typename T&gt;</span><br><span class="line">typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type</span><br><span class="line">foo(T t) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Integral type&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::type</span><br><span class="line">foo(T t) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Not integral type&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板-高级用法"><a href="#类模板-高级用法" class="headerlink" title="类模板 高级用法"></a>类模板 高级用法</h3><ol><li>模板特化（Template specialization）：有时候，针对某些特定的类型，可以为类模板提供专门的实现，这被称为模板特化。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c++Copy codetemplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;generic implementation&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;specialized implementation for int&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myclass&lt;<span class="type">double</span>&gt; obj1;</span><br><span class="line">    obj1.<span class="built_in">foo</span>(); <span class="comment">// generic implementation</span></span><br><span class="line"></span><br><span class="line">    myclass&lt;<span class="type">int</span>&gt; obj2;</span><br><span class="line">    obj2.<span class="built_in">foo</span>(); <span class="comment">// specialized implementation for int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>模板嵌套（Template nesting）：在类模板中定义另一个类模板或函数模板。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c++Copy codetemplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">nested_class</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;template nesting&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myclass&lt;<span class="type">int</span>&gt;::nested_class&lt;<span class="type">double</span>&gt; obj;</span><br><span class="line">    obj.<span class="built_in">foo</span>(); <span class="comment">// template nesting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>模板模板参数（Template template parameter）：允许将模板作为模板参数传递。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c++Copy codetemplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;generic implementation&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Container&lt;<span class="type">int</span>&gt; obj;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>&lt;myclass&gt;(); <span class="comment">// generic implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go python C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go vs C++ vs python</title>
      <link href="/anxiangblog.github.io/2023/04/27/Go%20vs%20C++%20vs%20python%20%20%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AF%B9%E6%AF%94/"/>
      <url>/anxiangblog.github.io/2023/04/27/Go%20vs%20C++%20vs%20python%20%20%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="Go-vs-C-vs-python-基础知识对比"><a href="#Go-vs-C-vs-python-基础知识对比" class="headerlink" title="Go vs C++ vs python   基础知识对比"></a>Go vs C++ vs python   基础知识对比</h1><p>回顾一下这几个软件的基础知识吧，也算对过去一年的总结。ps.都是最基本的东西，同时对比也看一下各语言的差别。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Python</strong>是一种高级编程语言，它非常适合于快速开发和原型设计。它也被称为<strong>解释型</strong>语言，因为它的代码在运行时被解释成机器代码。</p><p><strong>Go</strong>是由Google开发的一种<strong>静态类型</strong>的编程语言。它在系统编程、网络编程和并发编程方面表现出色。</p><p><strong>C++<strong>是一种高效的系统级</strong>静态类型</strong>编程语言，广泛用于开发操作系统、游戏和高性能应用程序。</p><h2 id="一、变量和常量"><a href="#一、变量和常量" class="headerlink" title="一、变量和常量"></a>一、变量和常量</h2><p>变量和常量是编程中必不可少的部分，也是很好理解的一部分。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a><strong>标识符</strong></h3><p><strong>标识符</strong>就是我们在程序中需要用到的变量、常量、函数、属性、类、模块等需要我们来自己定义的名字</p><p>Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code></p><p>标识符都是一样的。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><h4 id="Go语言中有25个关键字："><a href="#Go语言中有25个关键字：" class="headerlink" title="Go语言中有25个关键字："></a>Go语言中有25个关键字：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line">    <span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line">    <span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line">    <span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line">    <span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br><span class="line"></span><br><span class="line">此外，Go语言中还有<span class="number">37</span>个保留字。</span><br><span class="line"></span><br><span class="line">    Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        Types:    <span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span>  </span><br><span class="line">                  <span class="type">uint</span>  <span class="type">uint8</span>  <span class="type">uint16</span>  <span class="type">uint32</span>  <span class="type">uint64</span>  <span class="type">uintptr</span></span><br><span class="line">                  <span class="type">float32</span>  <span class="type">float64</span>  <span class="type">complex128</span>  <span class="type">complex64</span></span><br><span class="line">                  <span class="type">bool</span>  <span class="type">byte</span>  <span class="type">rune</span>  <span class="type">string</span>  <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">                 <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">                 <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h4 id="python内置的关键字有33个"><a href="#python内置的关键字有33个" class="headerlink" title="python内置的关键字有33个"></a>python内置的关键字有33个</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(<span class="string">&quot;keywords&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3结果</span></span><br><span class="line"><span class="literal">False</span>               <span class="keyword">def</span>                 <span class="title function_">if</span>                  <span class="keyword">raise</span></span><br><span class="line"><span class="literal">None</span>                <span class="keyword">del</span>                 <span class="keyword">import</span>              <span class="keyword">return</span></span><br><span class="line"><span class="literal">True</span>                <span class="keyword">elif</span>                <span class="keyword">in</span>                  <span class="keyword">try</span></span><br><span class="line"><span class="keyword">and</span>                 <span class="keyword">else</span>                <span class="keyword">is</span>                  <span class="keyword">while</span></span><br><span class="line"><span class="keyword">as</span>                  <span class="keyword">except</span>              <span class="keyword">lambda</span>              <span class="keyword">with</span></span><br><span class="line"><span class="keyword">assert</span>              <span class="keyword">finally</span>             <span class="keyword">nonlocal</span>            <span class="keyword">yield</span></span><br><span class="line"><span class="keyword">break</span>               <span class="keyword">for</span>                 <span class="keyword">not</span></span><br><span class="line"><span class="keyword">class</span>               <span class="title class_">from</span>                <span class="keyword">or</span></span><br><span class="line"><span class="keyword">continue</span>            <span class="keyword">global</span>              <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="c-关键字ps-c-对多"><a href="#c-关键字ps-c-对多" class="headerlink" title="c++ 关键字ps c++对多"></a>c++ 关键字ps c++对多</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alignas</span>         <span class="keyword">alignof</span>         <span class="keyword">and</span>             <span class="keyword">and_eq</span>          <span class="keyword">asm</span></span><br><span class="line"><span class="keyword">auto</span>            <span class="keyword">bitand</span>          <span class="keyword">bitor</span>           <span class="type">bool</span>            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span>            <span class="keyword">catch</span>           <span class="type">char</span>            <span class="type">char16_t</span>        <span class="type">char32_t</span></span><br><span class="line"><span class="keyword">class</span>           <span class="title class_">compl</span>           <span class="type">const</span>           <span class="keyword">constexpr</span>       <span class="keyword">const_cast</span></span><br><span class="line"><span class="keyword">continue</span>        <span class="keyword">decltype</span>        <span class="keyword">default</span>         <span class="keyword">delete</span>          <span class="keyword">do</span></span><br><span class="line"><span class="type">double</span>          <span class="keyword">dynamic_cast</span>   <span class="keyword">else</span>            <span class="keyword">enum</span>            <span class="keyword">explicit</span></span><br><span class="line"><span class="keyword">export</span>          <span class="keyword">extern</span>          <span class="literal">false</span>           <span class="type">float</span>           <span class="keyword">for</span></span><br><span class="line"><span class="keyword">friend</span>          <span class="keyword">goto</span>            <span class="keyword">if</span>              <span class="keyword">inline</span>          <span class="type">int</span></span><br><span class="line"><span class="type">long</span>            <span class="keyword">mutable</span>         <span class="keyword">namespace</span>       <span class="keyword">new</span>             <span class="keyword">noexcept</span></span><br><span class="line"><span class="keyword">not</span>             <span class="keyword">not_eq</span>          <span class="literal">nullptr</span>         <span class="keyword">operator</span>        <span class="keyword">or</span></span><br><span class="line"><span class="keyword">or_eq</span>           <span class="keyword">private</span>         <span class="keyword">protected</span>       <span class="keyword">public</span>          <span class="keyword">register</span></span><br><span class="line"><span class="keyword">reinterpret_cast</span>    <span class="keyword">return</span>      <span class="type">short</span>           <span class="type">signed</span>          <span class="keyword">sizeof</span></span><br><span class="line"><span class="type">static</span>          <span class="keyword">static_assert</span>  <span class="keyword">static_cast</span>    <span class="keyword">struct</span>           <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">template</span>        <span class="keyword">this</span>            <span class="keyword">thread_local</span>   <span class="keyword">throw</span>           <span class="literal">true</span></span><br><span class="line"><span class="keyword">try</span>             <span class="keyword">typedef</span>        <span class="keyword">typeid</span>          <span class="keyword">typename</span>        <span class="keyword">union</span></span><br><span class="line"><span class="type">unsigned</span>        <span class="keyword">using</span>           <span class="keyword">virtual</span>         <span class="type">void</span>           <span class="keyword">volatile</span></span><br><span class="line"><span class="type">wchar_t</span>         <span class="keyword">while</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="Go语言的变量声明格式为："><a href="#Go语言的变量声明格式为：" class="headerlink" title="Go语言的变量声明格式为："></a>Go语言的变量声明格式为：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;zax&quot;</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="type">bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">string</span></span><br><span class="line">    b <span class="type">int</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">    d <span class="type">float32</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 切片、函数、指针变量的默认为nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此外go支持类型推导 </span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数内部，可以使用更简略的 := 方式声明并初始化变量. 注意是函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">10</span></span><br><span class="line">m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名变量</span></span><br><span class="line"><span class="comment">//在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示</span></span><br><span class="line">x, _ := foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明</span></span><br><span class="line"><span class="comment">// 函数外的每个语句都必须以关键字开始（var、const、func等）</span></span><br><span class="line"><span class="comment">// :=不能使用在函数外。</span></span><br><span class="line"><span class="comment">// _多用于占位，表示忽略值。</span></span><br></pre></td></tr></table></figure><h4 id="python语言的变量声明格式为"><a href="#python语言的变量声明格式为" class="headerlink" title="python语言的变量声明格式为:"></a>python语言的变量声明格式为:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_variable = <span class="number">42</span></span><br><span class="line">name = <span class="string">&quot;zax&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#批量声明</span></span><br><span class="line">x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line">//匿名变量</span><br><span class="line">_, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="c-语言的变量声明格式为"><a href="#c-语言的变量声明格式为" class="headerlink" title="c++语言的变量声明格式为:"></a>c++语言的变量声明格式为:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myVariable = <span class="number">42</span>;</span><br><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11 引入 auto 用来让编译器根据上下文自动推导变量类型的</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="comment">//这将声明一个变量 x，并将其类型自动推导为 int</span></span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值</strong>， <strong>常量的值必须在编译时确定</strong></p><h4 id="go："><a href="#go：" class="headerlink" title="go："></a>go：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量的声明和变量声明非常类似，只是把`var`换成了`const`，常量在定义的时候必须赋值</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">) </span><br><span class="line"><span class="comment">//上面示例中，常量n1、n2、n3的值都是100。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//iota是go语言的常量计数器，只能在常量的表达式中使用 --------定义枚举时很有用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">n3        <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h4 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python 没有内置的常量类型，通常使用全大写字母来表示常量，但实际上它们仍然是变量，只是惯例上不会在程序中改变它们的值</span></span><br><span class="line"></span><br><span class="line">MY_CONSTANT = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以通过 enum 或者 class 来模拟常量</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyConstants</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    MY_CONSTANT = <span class="number">3.14</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyConstants</span>:</span><br><span class="line">    MY_CONSTANT = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 #define 来定义常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_CONSTANT 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是，使用 #define 宏定义时，没有类型检查，容易引起错误，也不易于维护，不太推荐使用。在 C++11 引入了 constexpr 关键字，可以用来定义常量表达式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> MY_CONSTANT = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 const 来定义常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> MY_CONSTANT = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 C++ 中，可以使用 enum 来定义常量。</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyConstants</span> &#123;</span><br><span class="line">    MY_CONSTANT = <span class="number">3.14</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> 和 <span class="type">const</span> 都可以用来定义常量，但是有一些区别。</span><br><span class="line"></span><br><span class="line"><span class="comment">//const 定义的常量可以是编译时常量或运行时常量，而 constexpr 定义的常量必须是编译时常量</span></span><br><span class="line"><span class="comment">//constexpr 可以提高代码的性能和安全性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//constexpr 可以用于函数、类的成员函数以及构造函数，而 const 只能用于变量.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 在编译期间求值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * <span class="built_in">factorial</span>(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是一个使用编译时常量的例子，定义了一个 constexpr 常量 k，在编译期间就能计算出其值：</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="number">10</span>; <span class="comment">// 编译时常量</span></span><br><span class="line"><span class="type">int</span> arr[k]; <span class="comment">// 可以用 k 定义数组大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是一个使用运行时常量的例子，定义了一个 const 常量 n，需要在运行时分配内存：</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">100</span>; <span class="comment">// 运行时常量</span></span><br><span class="line"><span class="type">int</span> arr[n]; <span class="comment">// 需要在运行时分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于类的成员函数和构造函数，constexpr 表示函数可以在编译期间被计算，而 const 表示函数不会修改类的成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> : x_(x), y_(y) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x_; &#125; <span class="comment">// const 表示不会修改类的成员变量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> y_; &#125; <span class="comment">// const 表示不会修改类的成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="type">int</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 编译时计算 Point 对象的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> 变量模板</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> area = pi&lt;<span class="type">double</span>&gt; * r * r; <span class="comment">// 计算圆的面积</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p><strong>全局变量定义在函数外部</strong>，<strong>可以在程序的任何地方访问，而局部变量定义在函数内部，只能在函数内部访问。</strong></p><p>go:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量需要显式地使用 var 关键字来声明，而局部变量则可以使用简短声明（short variable declaration）的方式来声明</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalVar = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    localVar := <span class="number">20</span></span><br><span class="line">    fmt.Println(globalVar)</span><br><span class="line">    fmt.Println(localVar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">global_var = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>():</span><br><span class="line">    local_var = <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(global_var)</span><br><span class="line">    <span class="built_in">print</span>(local_var)</span><br><span class="line">    </span><br><span class="line">my_func()   <span class="comment"># 输出：10 20</span></span><br><span class="line"><span class="comment">#如果你需要在函数内部使用全局变量，你可以使用 global 关键字来显式地声明一个变量为全局变量</span></span><br></pre></td></tr></table></figure><p>c++</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++ 中有显式的全局变量和局部变量的概念，你可以在函数内部或外部使用 int、double 等关键字来声明一个变量。如果你在函数内部声明一个变量，它将被视为局部变量，而如果你在函数外部声明一个变量，它将被视为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; globalVar &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; localVar &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">my_func</span>();  <span class="comment">// 输出：10 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h2><h4 id="go"><a href="#go" class="headerlink" title="go"></a>go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、<span class="keyword">map</span>、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 整形</span><br><span class="line">分为以下两个大类： 按长度分为：<span class="type">int8</span>、<span class="type">int16</span>、<span class="type">int32</span>、<span class="type">int64</span> 对应的无符号整型：<span class="type">uint8</span>、<span class="type">uint16</span>、<span class="type">uint32</span>、<span class="type">uint64</span></span><br><span class="line">其中，<span class="type">uint8</span>就是我们熟知的<span class="type">byte</span>型，<span class="type">int16</span>对应C语言中的short型，<span class="type">int64</span>对应C语言中的long型</span><br><span class="line"></span><br><span class="line"><span class="type">uint</span><span class="number">32</span>位操作系统上就是<span class="type">uint32</span>，<span class="number">64</span>位操作系统上就是<span class="type">uint64</span></span><br><span class="line"><span class="type">int</span><span class="number">32</span>位操作系统上就是<span class="type">int32</span>，<span class="number">64</span>位操作系统上就是<span class="type">int64</span></span><br><span class="line"><span class="type">uintptr</span>无符号整型，用于存放一个指针</span><br><span class="line"></span><br><span class="line">而且还允许我们用 _ 来分隔数字，比如说： v := <span class="number">123</span>_456 表示 v 的值等于 <span class="number">123456</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 浮点型</span><br><span class="line"><span class="type">float32</span>和<span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 复数</span><br><span class="line"><span class="type">complex64</span>和<span class="type">complex128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 <span class="type">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line"><span class="type">complex64</span>的实部和虚部为<span class="number">32</span>位，<span class="type">complex128</span>的实部和虚部为<span class="number">64</span>位。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 布尔值 <span class="type">bool</span></span><br><span class="line">布尔类型变量的默认值为<span class="literal">false</span>。</span><br><span class="line">Go 语言中不允许将整型强制转换为布尔型.</span><br><span class="line">布尔型无法参与数值运算，也无法与其他类型进行转换。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> 字符串 </span><br><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br><span class="line">Go语言中要定义一个多行字符串时，就必须使用反引号字符：</span><br><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(str)求长度</span><br><span class="line">+或fmt.Sprintf拼接字符串</span><br><span class="line">strings.Split分割</span><br><span class="line">strings.contains判断是否包含</span><br><span class="line">strings.HasPrefix,strings.HasSuffix前缀/后缀判断</span><br><span class="line">strings.Index(),strings.LastIndex()子串出现的位置</span><br><span class="line">strings.Join(a[]<span class="type">string</span>, sep <span class="type">string</span>)join操作</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="type">byte</span>和<span class="type">rune</span>类型</span><br><span class="line">组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="type">rune</span>类型实际是一个<span class="type">int32</span></span><br><span class="line"></span><br><span class="line">修改字符串</span><br><span class="line">要修改字符串，需要先将其转换成[]<span class="type">rune</span>或[]<span class="type">byte</span>，完成后再转换为<span class="type">string</span>。无论哪种转换，都会重新分配内存，并复制字节数组。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line">byteS1 := []<span class="type">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">runeS2 := []<span class="type">rune</span>(s2)</span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(runeS2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T(表达式) v类型转换</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在Python中常见的数据类型有以下<span class="number">8</span>个类型，分别是：<span class="built_in">int</span>，整数类型（整形）、<span class="built_in">float</span>，浮点类型（浮点型）、<span class="built_in">bool</span>，布尔类型、<span class="built_in">str</span>，字符串类型、<span class="built_in">list</span>，列表类型、<span class="built_in">tuple</span>，元组类型、<span class="built_in">dict</span>，字典类型、<span class="built_in">set</span>，集合类型</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="built_in">int</span></span><br><span class="line">Python 中的整数没有长度限制，不像其他编程语言有 <span class="built_in">int</span>，smallint，short，long，longint，long 等</span><br><span class="line"></span><br><span class="line">十进制就不说了，正常的写法</span><br><span class="line">十六进制写法：加前缀 0x，出现 <span class="number">0</span>-<span class="number">9</span> 和 A-F 的数字和字母组合</span><br><span class="line">八进制写法：加前缀 0o，出现 <span class="number">0</span>-<span class="number">7</span> 数字组合</span><br><span class="line">二进制写法：加前缀 0b，只有 <span class="number">0</span> 和 <span class="number">1</span> 数字组合</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 浮点数 <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">a. 浮点数只能以十进制表示，不能加前缀，否则会报语法错误</span><br><span class="line">浮点数 有长度限制 边界值为：</span><br><span class="line"><span class="built_in">max</span>=<span class="number">1.7976931348623157e+308</span> <span class="built_in">min</span>=<span class="number">2.2250738585072014e-308</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 布尔值 <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">布尔值就是我们常说的逻辑，可以理解为对或错</span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> == <span class="number">100.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 复数 <span class="built_in">complex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 中的复数这样来表示： 1 + 1j  虚部为 1，仍不可省略</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">1</span> + <span class="number">2j</span>).real) <span class="comment"># 输出实部 float 类型</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">1</span> + <span class="number">2j</span>).imag) <span class="comment"># 输出虚部 float 类型</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> 字符串 <span class="built_in">str</span></span><br><span class="line">通俗来说，字符串就是字符组成的一串内容，Python 中用成对的单引号或双引号括起来，用三个单引号或双引号可以使字符串内容保持原样输出，可以包含回车等特殊字符，在 Python 中字符串是不可变对象</span><br><span class="line">Python 中用反斜杠 “\” 来转义字符</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> 列表 <span class="built_in">list</span></span><br><span class="line">ls = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ls:</span><br><span class="line">    <span class="built_in">print</span>(i) </span><br><span class="line"></span><br><span class="line">检查列表中是否存在某个元素</span><br><span class="line">使用 <span class="keyword">in</span> 关键字，返回值为布尔值   </span><br><span class="line"><span class="keyword">del</span> ls    </span><br></pre></td></tr></table></figure><h4 id="c-1"><a href="#c-1" class="headerlink" title="c++"></a>c++</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go python C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go vs C++ vs python 基本数据类型</title>
      <link href="/anxiangblog.github.io/2023/04/27/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/anxiangblog.github.io/2023/04/27/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h2 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h2><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</span><br><span class="line">其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型</span><br><span class="line"></span><br><span class="line">uint32位操作系统上就是uint32，64位操作系统上就是uint64</span><br><span class="line">int32位操作系统上就是int32，64位操作系统上就是int64</span><br><span class="line">uintptr无符号整型，用于存放一个指针</span><br><span class="line"></span><br><span class="line">而且还允许我们用 _ 来分隔数字，比如说： v := 123_456 表示 v 的值等于 123456。</span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float32和float64</span><br></pre></td></tr></table></figure><h3 id="布尔值-bool"><a href="#布尔值-bool" class="headerlink" title="布尔值 bool"></a>布尔值 bool</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">布尔类型变量的默认值为false。</span><br><span class="line">Go 语言中不允许将整型强制转换为布尔型.</span><br><span class="line">布尔型无法参与数值运算，也无法与其他类型进行转换。</span><br></pre></td></tr></table></figure><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">complex64和complex128</span><br><span class="line"></span><br><span class="line">var c1 complex64</span><br><span class="line">c1 = 1 + 2i</span><br><span class="line">var c2 complex128</span><br><span class="line">c2 = 2 + 3i</span><br><span class="line">complex64的实部和虚部为32位，complex128的实部和虚部为64位。</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 := &quot;hello&quot;</span><br><span class="line">s2 := &quot;你好&quot;</span><br><span class="line">Go语言中要定义一个多行字符串时，就必须使用反引号字符：</span><br><span class="line">s1 := `第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">`</span><br><span class="line">反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出</span><br><span class="line"></span><br><span class="line">len(str)求长度</span><br><span class="line">+或fmt.Sprintf拼接字符串</span><br><span class="line">strings.Split分割</span><br><span class="line">strings.contains判断是否包含</span><br><span class="line">strings.HasPrefix,strings.HasSuffix前缀/后缀判断</span><br><span class="line">strings.Index(),strings.LastIndex()子串出现的位置</span><br><span class="line">strings.Join(a[]string, sep string)join操作</span><br></pre></td></tr></table></figure><h3 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</span><br><span class="line">var a = &#x27;中&#x27;</span><br><span class="line">var b = &#x27;x&#x27;</span><br><span class="line">rune类型实际是一个int32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改字符串</span><br><span class="line">要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。</span><br><span class="line"></span><br><span class="line">func changeString() &#123;</span><br><span class="line">s1 := &quot;big&quot;</span><br><span class="line">// 强制类型转换</span><br><span class="line">byteS1 := []byte(s1)</span><br><span class="line">byteS1[0] = &#x27;p&#x27;</span><br><span class="line">fmt.Println(string(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := &quot;白萝卜&quot;</span><br><span class="line">runeS2 := []rune(s2)</span><br><span class="line">runeS2[0] = &#x27;红&#x27;</span><br><span class="line">fmt.Println(string(runeS2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指针类型（Pointer）"><a href="#指针类型（Pointer）" class="headerlink" title="指针类型（Pointer）"></a>指针类型（Pointer）</h3><p>在 Go 中，指针类型用于存储变量的内存地址。与 C 和 C++ 不同，Go 指针不能进行偏移和运算，因此它们更安全且更易于使用。指针类型以 <code>*</code> 开头，用于指定指针类型的底层类型。例如，<code>*int</code> 表示指向整数类型的指针。在 Go 中，通过 <code>&amp;</code> 运算符可以获取一个变量的内存地址，而通过 <code>*</code> 运算符可以获取指针所指向的变量的值，<strong>指针类型的零值为 <code>nil</code><strong>，表示指</strong>针不指向任何有效的内存地址</strong>。因此，在使用指针之前，应该先进行空指针检查</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x int = 42</span><br><span class="line">var ptr *int = &amp;x   // 获取 x 的地址，将其赋值给 ptr</span><br><span class="line">fmt.Println(*ptr)  // 输出指针所指向的变量的值，即 42</span><br></pre></td></tr></table></figure><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h3><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个长度为3元素类型为int的数组a   数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变</span><br><span class="line">var 数组变量名 [元素数量]T</span><br><span class="line">var a [3]int</span><br></pre></td></tr></table></figure><h4 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var testArray [3]int                        //数组会初始化为int类型的零值</span><br><span class="line">var numArray = [3]int&#123;1, 2&#125;                 //使用指定的初始值完成初始化</span><br><span class="line">var cityArray = [3]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125; //使用指定的初始值完成初始化</span><br><span class="line"></span><br><span class="line">一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度</span><br><span class="line">var testArray [3]int</span><br><span class="line">var numArray = [...]int&#123;1, 2&#125;</span><br><span class="line">var cityArray = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line"></span><br><span class="line">指定索引值的方式来初始化数组</span><br><span class="line">a := [...]int&#123;1: 1, 3: 5&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 方法1：for循环遍历</span><br><span class="line">for i := 0; i &lt; len(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法2：for range遍历</span><br><span class="line">for index, value := range a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二维数组</span><br><span class="line">a := [3][2]string&#123;</span><br><span class="line">&#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">&#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, v1 := range a &#123;</span><br><span class="line">for _, v2 := range v1 &#123;</span><br><span class="line">fmt.Printf(&quot;%s\t&quot;, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h4><p>数组是值类型，<strong>赋值和传参会复制整个数组</strong>。因此改变副本的值，不会改变本身的值。</p><ol><li>数组支持 “&#x3D;&#x3D;“、”!&#x3D;” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol><h3 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h3><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><h4 id="切片声明"><a href="#切片声明" class="headerlink" title="切片声明"></a>切片声明</h4><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><ol><li>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</li><li>切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）</li><li>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</li><li>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name []T</span><br><span class="line"></span><br><span class="line">简单切片表达式</span><br><span class="line">a := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">s := a[1:3]  // s := a[low:high]</span><br><span class="line">a[2:]  // 等同于 a[2:len(a)]</span><br><span class="line">a[:3]  // 等同于 a[0:3]</span><br><span class="line">a[:]   // 等同于 a[0:len(a)]</span><br><span class="line"></span><br><span class="line">完整切片表达式</span><br><span class="line">a[low : high : max]</span><br><span class="line">它会将得到的结果切片的容量cap设置为max-low</span><br></pre></td></tr></table></figure><h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make([]T, size, cap)</span><br></pre></td></tr></table></figure><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><h4 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">四维数组</span><br><span class="line">var Sites  [][][][]int</span><br><span class="line">for i := 0; i &lt; DataInfo.X; i++ &#123;</span><br><span class="line">var first [][][]int</span><br><span class="line">for j := 0; j &lt; DataInfo.Y; j++ &#123;</span><br><span class="line">var secend [][]int</span><br><span class="line">for k := 0; k &lt; DataInfo.Z; k++ &#123;</span><br><span class="line"></span><br><span class="line">third := make([]int, 2)</span><br><span class="line">secend = append(secend, third)</span><br><span class="line">&#125;</span><br><span class="line">first = append(first, secend)</span><br><span class="line">&#125;</span><br><span class="line">Sites = append(Sites, first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">切片遍历</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">append</span>()方法为切片添加元素</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">Go语言内建的<span class="built_in">copy</span>()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<span class="built_in">copy</span>()函数的使用格式如下：</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(destSlice, srcSlice []T) </span><br><span class="line"></span><br><span class="line">srcSlice: 数据来源切片</span><br><span class="line">destSlice: 目标切片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="map声明"><a href="#map声明" class="headerlink" title="map声明"></a>map声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br><span class="line"></span><br><span class="line">v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map操作"><a href="#map操作" class="headerlink" title="map操作"></a>map操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遍历</span><br><span class="line">for k, v := range scoreMap &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">遍历map时的元素顺序与添加键值对的顺序无关</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(map, key)</span><br><span class="line">delete(scoreMap, &quot;小明&quot;)//将小明:100从map中删除</span><br><span class="line"></span><br><span class="line">元素为map类型的切片</span><br><span class="line">var mapSlice = make([]map[string]string, 3)</span><br><span class="line">mapSlice[0][&quot;address&quot;] = &quot;沙河&quot;</span><br><span class="line"></span><br><span class="line">值为切片类型的map</span><br><span class="line">var sliceMap = make(map[string][]string, 3)</span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line">if !ok &#123;</span><br><span class="line">value = make([]string, 0, 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体Struct"><a href="#结构体Struct" class="headerlink" title="结构体Struct"></a>结构体Struct</h3><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p><p>Go语言中通过<code>struct</code>来实现面向对象。</p><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Go语言中并没有类的概念，而是使用结构体来实现类似的功能</span></span><br><span class="line"><span class="keyword">type</span> MyClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyClass)</span></span> setX(val <span class="type">int</span>) &#123;</span><br><span class="line">    m.x = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h4><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">city <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在定义一些临时数据结构等场景下还可以使用匿名结构体</span><br><span class="line"><span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="type">string</span>; Age <span class="type">int</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h4><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针,需要注意的是<strong>在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员</strong></p><h4 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h4><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;七米&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;七米&quot;, city:&quot;成都&quot;, age:30&#125;</span></span><br></pre></td></tr></table></figure><p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p><h4 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h4><p><strong>没有初始化的结构体，其成员变量都是对应其类型的零值。</strong><em><strong>结构体占用一块连续的内存.</strong></em>* <strong>空结构体是不占用空间的。</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用键值对初始化,,当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</span></span><br><span class="line">p5 := person&#123;</span><br><span class="line">name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用值的列表初始化</span></span><br><span class="line">p8 := &amp;person&#123;</span><br><span class="line"><span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line"><span class="string">&quot;北京&quot;</span>,</span><br><span class="line"><span class="number">28</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p9 := newPerson(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;沙河&quot;</span>, <span class="number">90</span>)</span><br></pre></td></tr></table></figure><h4 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h4><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><p>方法的定义格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">name: name,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="comment">//值类型的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针类型的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h5><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h4 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="type">string</span></span><br><span class="line">City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Gender  <span class="type">string</span></span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">City:     <span class="string">&quot;威海&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套匿名字段</span></span><br><span class="line">Address <span class="comment">//匿名字段</span></span><br><span class="line">user2.Address.Province = <span class="string">&quot;山东&quot;</span>    <span class="comment">// 匿名字段默认使用类型名作为字段名</span></span><br></pre></td></tr></table></figure><h4 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h4><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Feet    <span class="type">int8</span></span><br><span class="line">*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := &amp;Dog&#123;</span><br><span class="line">Feet: <span class="number">4</span>,</span><br><span class="line">Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h4><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）.</p><h4 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h4><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键&#x2F;值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//JSON序列化：结构体--&gt;JSON格式的字符串</span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line"></span><br><span class="line">//JSON反序列化：JSON格式的字符串--&gt;结构体</span><br><span class="line">err = json.Unmarshal([]byte(str), c1)</span><br></pre></td></tr></table></figure><h4 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h4><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`key1:<span class="string">&quot;value1&quot;</span> key2:<span class="string">&quot;value2&quot;</span>`</span><br></pre></td></tr></table></figure><p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">Gender <span class="type">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">name   <span class="type">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := Student&#123;</span><br><span class="line">ID:     <span class="number">1</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">name:   <span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体和方法补充知识点"><a href="#结构体和方法补充知识点" class="headerlink" title="结构体和方法补充知识点"></a>结构体和方法补充知识点</h4><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意.</p><p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p><h3 id="函数Func"><a href="#函数Func" class="headerlink" title="函数Func"></a>函数Func</h3><p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p><p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</strong></li><li><strong>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</strong></li><li><strong>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</strong></li><li><strong>函数体：实现指定功能的代码块。</strong></li><li><strong>函数的参数和返回值都是可选的</strong></li><li><strong>函数的参数中如果相邻变量的类型相同，则可以省略类型</strong></li></ul><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p><strong>可变参数是指函数的参数数量不固定</strong>。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p><p>注意：<strong>可变参数通常要作为函数的最后一个参数。</strong></p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p><p>返回值命名  函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p><p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 没必要返回[]int&#123;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h5><p>局部变量和全局变量重名，优先访问局部变量。</p><h5 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h5><p>定义函数类型</p><p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br><span class="line"></span><br><span class="line">fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br></pre></td></tr></table></figure><h5 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h5><p>函数可以作为参数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret2 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h5><p>函数也可以作为返回值：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err := errors.New(<span class="string">&quot;无法识别的操作符&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h5><p><strong>匿名函数多用于实现回调函数和闭包</strong>。</p><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自执行函数：匿名函数定义完加()直接执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>闭包指的是一个函数和与其相关的引用环境组合而成的实体</strong>。简单来说，<code>闭包=函数+引用环境</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = adder()</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br></pre></td></tr></table></figure><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</p><p>闭包进阶示例2：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffixFunc</span><span class="params">(suffix <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line"><span class="keyword">return</span> name + suffix</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jpgFunc := makeSuffixFunc(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">txtFunc := makeSuffixFunc(<span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">fmt.Println(jpgFunc(<span class="string">&quot;test&quot;</span>)) <span class="comment">//test.jpg</span></span><br><span class="line">fmt.Println(txtFunc(<span class="string">&quot;test&quot;</span>)) <span class="comment">//test.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例3：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base -= i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1, f2 := calc(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>)) <span class="comment">//11 9</span></span><br><span class="line">fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>)) <span class="comment">//12 8</span></span><br><span class="line">fmt.Println(f1(<span class="number">5</span>), f2(<span class="number">6</span>)) <span class="comment">//13 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p><h5 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h5><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">y := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">B <span class="number">10</span> <span class="number">2</span> <span class="number">12</span></span><br><span class="line">BB <span class="number">10</span> <span class="number">12</span> <span class="number">22</span></span><br><span class="line">AA <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="内置函数介绍"><a href="#内置函数介绍" class="headerlink" title="内置函数介绍"></a>内置函数介绍</h5><table><thead><tr><th align="center">内置函数</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">close</td><td align="center">主要用来关闭channel</td></tr><tr><td align="center">len</td><td align="center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td align="center">new</td><td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td align="center">make</td><td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td align="center">append</td><td align="center">用来追加元素到数组、slice中</td></tr><tr><td align="center">panic和recover</td><td align="center">用来做错误处理</td></tr></tbody></table><h3 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h3><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节</p><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于之前章节中讲到的那些具体类型（字符串、切片、结构体等）更注重“我是谁”，接口类型更注重“我能做什么”的问题。接口类型就像是一种约定——概括了一种类型应该具备哪些方法，在Go语言中提倡使用面向接口的编程方式实现解耦。</p><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口类型名：Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有关闭操作的接口叫<code>closer</code>等。接口名最好要能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><h4 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h4><p>接口就是规定了一个<strong>需要实现的方法列表</strong>，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口。</p><p>我们定义的<code>Singer</code>接口类型，它包含一个<code>Sing</code>方法。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singer 接口</span></span><br><span class="line"><span class="keyword">type</span> Singer <span class="keyword">interface</span> &#123;</span><br><span class="line">Sing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个<code>Bird</code>结构体类型如下。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为<code>Singer</code>接口只包含一个<code>Sing</code>方法，所以只需要给<code>Bird</code>结构体添加一个<code>Sing</code>方法就可以满足<code>Singer</code>接口的要求。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sing Bird类型的Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Sing() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就称为<code>Bird</code>实现了<code>Singer</code>接口。</p><p>只要实现了<code>Say()</code>方法都能当成<code>Sayer</code>类型的变量来处理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Sayer interface &#123;</span><br><span class="line">    Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MakeHungry 饿肚子了...</span><br><span class="line">func MakeHungry(s Sayer) &#123;</span><br><span class="line">s.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c cat</span><br><span class="line">MakeHungry(c)</span><br><span class="line">var d dog</span><br><span class="line">MakeHungry(d)</span><br></pre></td></tr></table></figure><p>Go语言中为了解决类似上面的问题引入了接口的概念，接口类型区别于我们之前章节中介绍的那些具体类型，让我们专注于该类型提供的方法，而不是类型本身。使用接口类型通常能够让我们写出更加通用和灵活的代码</p><h4 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h4><p>只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。</p><p>我们可以将具体的支付方式抽象为一个名为<code>Payer</code>的接口类型，即任何实现了<code>Pay</code>方法的都可以称为<code>Payer</code>类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Payer 包含支付方法的接口类型</span></span><br><span class="line"><span class="keyword">type</span> Payer <span class="keyword">interface</span> &#123;</span><br><span class="line">Pay(<span class="type">int64</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ZhiFuBao <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 支付宝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay 支付宝的支付方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *ZhiFuBao)</span></span> Pay(amount <span class="type">int64</span>) &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;使用支付宝付款：%.2f元。\n&quot;</span>, <span class="type">float64</span>(amount/<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WeChat <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 微信</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay 微信的支付方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WeChat)</span></span> Pay(amount <span class="type">int64</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;使用微信付款：%.2f元。\n&quot;</span>, <span class="type">float64</span>(amount/<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Checkout</span><span class="params">(obj *Payer)</span></span> &#123;</span><br><span class="line"><span class="comment">// 支付100元</span></span><br><span class="line">obj.Pay(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Checkout(&amp;ZhiFuBao&#123;&#125;) <span class="comment">// 之前调用支付宝支付</span></span><br><span class="line"></span><br><span class="line">Checkout(&amp;WeChat&#123;&#125;) <span class="comment">// 现在支持使用微信支付</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x Sayer // 声明一个Sayer类型的变量x</span><br><span class="line">a := Cat&#123;&#125;  // 声明一个Cat类型变量a</span><br><span class="line">b := Dog&#123;&#125;  // 声明一个Dog类型变量b</span><br><span class="line">x = a       // 可以把Cat类型变量直接赋值给x</span><br><span class="line">x.Say()     // 喵喵喵</span><br><span class="line">x = b       // 可以把Dog类型变量直接赋值给x</span><br><span class="line">x.Say()     // 汪汪汪</span><br></pre></td></tr></table></figure><h4 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Mover 定义一个接口类型</span><br><span class="line">type Mover interface &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Dog 狗结构体类型</span><br><span class="line">type Dog struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">//值接收者实现接口</span><br><span class="line">// Move 使用值接收者定义Move方法实现Mover接口</span><br><span class="line">func (d Dog) Move() &#123;</span><br><span class="line">fmt.Println(&quot;狗会动&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指针接收者实现接口</span><br><span class="line"></span><br><span class="line">// Cat 猫结构体类型</span><br><span class="line">type Cat struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Move 使用指针接收者定义Move方法实现Mover接口</span><br><span class="line">func (c *Cat) Move() &#123;</span><br><span class="line">fmt.Println(&quot;猫会动&quot;)</span><br><span class="line">&#125;</span><br><span class="line">ar c1 = &amp;Cat&#123;&#125; // c1是*Cat类型</span><br><span class="line">x = c1          // 可以将c1当成Mover类型</span><br><span class="line">x.Move()</span><br><span class="line"></span><br><span class="line">由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是我们并不总是能对一个值求址，所以对于指针接收者实现的接口要额外注意</span><br></pre></td></tr></table></figure><h4 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h4><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。我们完全可以分别定义<code>Sayer</code>接口和<code>Mover</code>接口，具体代码示例如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog既可以实现Sayer接口，也可以实现Mover接口。</span></span><br><span class="line"><span class="comment">//同一个类型实现不同的接口互相不影响使用。</span></span><br><span class="line"><span class="keyword">var</span> d = Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Sayer = d</span><br><span class="line"><span class="keyword">var</span> m Mover = d</span><br><span class="line"></span><br><span class="line">s.Say()  <span class="comment">// 对Sayer类型调用Say方法</span></span><br><span class="line">m.Move() <span class="comment">// 对Mover类型调用Move方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WashingMachine 洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">wash()</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干器</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> dry() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">dryer <span class="comment">//嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span></span> wash() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h4><p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库<code>io</code>源码中就有很多接口之间互相组合的示例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/io/io.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p><p>接口也可以作为结构体的一个字段，我们来看一段Go标准库<code>sort</code>源码中的示例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sort/sort.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface 定义通过索引对元素排序的接口类型</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse 结构体中嵌入了Interface接口</span></span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中还有一个需要注意的地方是<code>reverse</code>结构体本身是不可导出的（结构体类型名称首字母小写），<code>sort.go</code>中通过定义一个可导出的<code>Reverse</code>函数来让使用者创建<code>reverse</code>结构体实例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span></span> Interface &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的目的是保证得到的<code>reverse</code>结构体中的<code>Interface</code>属性一定不为<code>nil</code>，否者<code>r.Interface.Less(j, i)</code>就会出现空指针panic。</p><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 不包含任何方法的空接口类型</span></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 狗结构体</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Any</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;你好&quot;</span> <span class="comment">// 字符串型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="number">100</span> <span class="comment">// int型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = Dog&#123;&#125; <span class="comment">// 结构体类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们在使用空接口类型时不必使用<code>type</code>关键字声明，可以像下面的代码一样直接使用<code>interface&#123;&#125;</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 声明一个空接口类型变量x</span></span><br></pre></td></tr></table></figure><ol><li>空接口作为函数的参数   <code>func show(a interface&#123;&#125;)</code></li><li>空接口作为map的值 <code>var studentInfo = make(map[string]interface&#123;&#125;)</code></li></ol><h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<strong>值</strong>之外，还需要记录这个值属于的<strong>类型</strong>。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的<code>动态类型</code>和<code>动态值</code></p><table><thead><tr><th>类型type</th><th>nil</th></tr></thead><tbody><tr><td>值 value</td><td>nil</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;        <span class="keyword">type</span>  = *dog       value = 旺财</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *Car</span><br><span class="line">m = c                         <span class="keyword">type</span>  = *car      value = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</span></span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>我们可以借助标准库<code>fmt</code>包的格式化打印获取到接口值的动态类型 ,而<code>fmt</code>包内部其实是使用反射的机制在程序运行时获取到动态类型的名称</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m Mover</span><br><span class="line"></span><br><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, m) <span class="comment">// *main.Dog</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">new</span>(Car)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, m) <span class="comment">// *main.Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。</span></span><br><span class="line">x.(T)</span><br><span class="line"></span><br><span class="line">x：表示接口类型的变量</span><br><span class="line">T：表示断言x可能是的类型。</span><br><span class="line"></span><br><span class="line">v, ok := n.(*Dog)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v := x.(<span class="keyword">type</span>)</span><br></pre></td></tr></table></figure><h3 id="Error-接口"><a href="#Error-接口" class="headerlink" title="Error 接口"></a>Error 接口</h3><p>Go 语言中把错误当成一种特殊的值来处理，不支持其他语言中使用<code>try/catch</code>捕获异常的方式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>error 是一个接口类型，默认零值为<code>nil</code>。所以我们通常将调用函数返回的错误与<code>nil</code>进行比较，以此来判断函数是否返回错误.</p><h4 id="创建错误"><a href="#创建错误" class="headerlink" title="创建错误"></a>创建错误</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">errors.New(<span class="string">&quot;无效的id&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Errorf(<span class="string">&quot;查询数据库失败，err:%v&quot;</span>, err)</span><br></pre></td></tr></table></figure><h4 id="错误结构体类型"><a href="#错误结构体类型" class="headerlink" title="错误结构体类型"></a>错误结构体类型</h4><p>此外我们还可以自己定义结构体类型，实现&#96;&#96;error&#96;接口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpError 自定义结构体类型</span></span><br><span class="line"><span class="keyword">type</span> OpError <span class="keyword">struct</span> &#123;</span><br><span class="line">Op <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error OpError 类型实现error接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *OpError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;无权执行%s操作&quot;</span>, e.Op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h5 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h5><p>使用 <code>new</code> 和 <code>make</code> 可以创建新的对象或数据结构</p><p><code>new</code> 函数用于分配一块新的内存，并将其初始化为零值，返回一个指向这块内存的指针。可以用于任何数据类型，但是并没有给这块内存赋值，因此在使用前需要进行赋值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明一个指向 int 类型的指针</span><br><span class="line">var p *int</span><br><span class="line">p = new(int)  // 分配一块新的内存，并将其初始化为 0，p 指向这块内存</span><br><span class="line">*p = 123      // 给这块内存赋值</span><br></pre></td></tr></table></figure><p><code>make</code> 函数则用于分配并初始化一个引用类型的对象（如 <code>slice</code>、<code>map</code>、<code>channel</code>）。返回的是一个该类型的对象而非指针，因为这些对象本身就是引用类型，即指向某个底层数据结构的指针。<code>make</code> 函数会为这些对象分配内存，初始化其内部字段，最后返回该对象。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为 5 的 int 类型切片，初始值为 0</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个容量为 10 的 int 类型切片，长度为 2，初始值为 0</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 map，初始化为空</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 channel，容量为 10</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><ol><li>二者都是用来做内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>在Python中常见的数据类型有以下8个类型，分别是：int，整数类型（整形）、float，浮点类型（浮点型）、bool，布尔类型、str，字符串类型、list，列表类型、tuple，元组类型、dict，字典类型、set，集合类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  int</span><br><span class="line">Python 中的整数没有长度限制，不像其他编程语言有 int，smallint，short，long，longint，long 等</span><br><span class="line"></span><br><span class="line">十进制就不说了，正常的写法</span><br><span class="line">十六进制写法：加前缀 0x，出现 0-9 和 A-F 的数字和字母组合</span><br><span class="line">八进制写法：加前缀 0o，出现 0-7 数字组合</span><br><span class="line">二进制写法：加前缀 0b，只有 0 和 1 数字组合</span><br><span class="line"></span><br><span class="line">2 浮点数 float</span><br><span class="line"></span><br><span class="line">a. 浮点数只能以十进制表示，不能加前缀，否则会报语法错误</span><br><span class="line">浮点数 有长度限制 边界值为：</span><br><span class="line">max=1.7976931348623157e+308 min=2.2250738585072014e-308</span><br><span class="line"></span><br><span class="line">3 布尔值 bool</span><br><span class="line"></span><br><span class="line">布尔值就是我们常说的逻辑，可以理解为对或错</span><br><span class="line">print(100 == 100.0)</span><br><span class="line"></span><br><span class="line">4 复数 complex</span><br><span class="line"></span><br><span class="line"># Python 中的复数这样来表示： 1 + 1j  虚部为 1，仍不可省略</span><br><span class="line">print((1 + 2j).real) # 输出实部 float 类型</span><br><span class="line">print((1 + 2j).imag) # 输出虚部 float 类型</span><br><span class="line"></span><br><span class="line">5 字符串 str</span><br><span class="line">通俗来说，字符串就是字符组成的一串内容，Python 中用成对的单引号或双引号括起来，用三个单引号或双引号可以使字符串内容保持原样输出，可以包含回车等特殊字符，在 Python 中字符串是不可变对象</span><br><span class="line">Python 中用反斜杠 “\” 来转义字符</span><br><span class="line"></span><br><span class="line">6 列表 list</span><br><span class="line">ls = [1, 2, 3, 4, &#x27;a&#x27;, &#x27;b&#x27;, [8, 5, 7]]</span><br><span class="line">for i in ls:</span><br><span class="line">    print(i) </span><br><span class="line"></span><br><span class="line">检查列表中是否存在某个元素</span><br><span class="line">使用 in 关键字，返回值为布尔值   </span><br><span class="line">del ls    </span><br></pre></td></tr></table></figure><h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line">    x = 0</span><br><span class="line">    def setX(self, val):</span><br><span class="line">        self.x = val</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="c-类型"><a href="#c-类型" class="headerlink" title="c++ 类型"></a>c++ 类型</h2><h4 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef type newname; </span><br></pre></td></tr></table></figure><p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int feet;</span><br></pre></td></tr></table></figure><p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feet distance;</span><br></pre></td></tr></table></figure><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>: 整数类型，通常为 <span class="number">32</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">31</span> 到 <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span></span><br><span class="line"><span class="type">short</span>: 短整数类型，通常为 <span class="number">16</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">15</span> 到 <span class="number">2</span>^<span class="number">15</span><span class="number">-1</span></span><br><span class="line"><span class="type">long</span>: 长整数类型，通常为 <span class="number">32</span> 位或 <span class="number">64</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">31</span> 到 <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span> 或 <span class="number">-2</span>^<span class="number">63</span> 到 <span class="number">2</span>^<span class="number">63</span><span class="number">-1</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>: 长长整数类型，通常为 <span class="number">64</span> 位，可表示范围为 <span class="number">-2</span>^<span class="number">63</span> 到 <span class="number">2</span>^<span class="number">63</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>: 无符号整数类型，通常为 <span class="number">32</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">32</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>: 无符号短整数类型，通常为 <span class="number">16</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">16</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>: 无符号长整数类型，通常为 <span class="number">32</span> 位或 <span class="number">64</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">32</span><span class="number">-1</span> 或 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">64</span><span class="number">-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>: 无符号长长整数类型，通常为 <span class="number">64</span> 位，可表示范围为 <span class="number">0</span> 到 <span class="number">2</span>^<span class="number">64</span><span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="浮点型-1"><a href="#浮点型-1" class="headerlink" title="浮点型"></a>浮点型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float: 单精度浮点型，通常为 32 位，可表示范围为 1.17549e-38 到 3.40282e+38，精度为 6 位小数</span><br><span class="line">double: 双精度浮点型，通常为 64 位，可表示范围为 2.22507e-308 到 1.79769e+308，精度为 15 位小数</span><br><span class="line">long double: 长双精度浮点型，通常为 80 位或 128 位，可表示范围和精度比 double 更高</span><br></pre></td></tr></table></figure><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char: 字符类型，通常为 8 位，可表示 ASCII 码的字符，例如 &#x27;A&#x27;、&#x27;B&#x27;、&#x27;C&#x27; 等</span><br><span class="line">char16_t: Unicode 字符类型，通常为 16 位</span><br><span class="line">char32_t: Unicode 字符类型，通常为 32 位</span><br><span class="line">wchar_t: 宽字符类型，通常为 16 位或 32 位，用于支持多语言字符集</span><br></pre></td></tr></table></figure><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool: 布尔类型，通常为 1 位，可表示 true 或 false</span><br></pre></td></tr></table></figure><h4 id="复数-1"><a href="#复数-1" class="headerlink" title="复数"></a>复数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 C++ 标准库中，复数类型是通过 std::complex 实现的，它定义在 &lt;complex&gt; 头文件中。std::complex 是一个模板类，它接受一个模板参数表示元素类型，可以是 float、double、long double 等</span><br><span class="line"></span><br><span class="line">#include &lt;complex&gt;</span><br><span class="line">std::complex&lt;double&gt; z1(1.0, 2.0); // 定义并初始化一个复数</span><br><span class="line"> // 访问实部和虚部</span><br><span class="line">    std::cout &lt;&lt; &quot;real(z1) = &quot; &lt;&lt; z1.real() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;imag(z1) = &quot; &lt;&lt; z1.imag() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="枚举类型（enum）"><a href="#枚举类型（enum）" class="headerlink" title="枚举类型（enum）"></a>枚举类型（enum）</h4><p>枚举类型是一种用户自定义的类型，用于定义一些有限的命名值。例如，我们可以使用枚举类型定义一些颜色：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Color c = Green;</span><br></pre></td></tr></table></figure><h4 id="指针类型（pointer）"><a href="#指针类型（pointer）" class="headerlink" title="指针类型（pointer）"></a>指针类型（pointer）</h4><p>指针类型是一种保存了内存地址的变量类型。指针变量通常用于动态内存分配、函数调用等方面。例如，下面的代码中，我们定义了一个指针变量 <code>p</code>，并将它指向一个整型变量 <code>x</code> 的地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int* p = &amp;x;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="引用（reference）"><a href="#引用（reference）" class="headerlink" title="引用（reference）"></a>引用（reference）</h4><p>在 C++ 中，引用是一种轻量级的指针，它提供了访问变量的另一种方式，它是某个变量的别名。引用通常用于函数参数、返回值和赋值。引用的语法使用 &amp; 符号。引用和指针类似，它们都提供了对变量的间接访问。但是，引用比指针更加安全，因为它们<strong>不会出现空指针</strong>的情况。在<strong>定义引用时必须初始化它</strong>，否则会出现编译错误。另外，引用一旦初始化后，就不能再指向其他变量，因此，引用可以被视为常量指针。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int&amp; b = a; // 声明 b 为 a 的引用</span><br><span class="line"></span><br><span class="line">b = 10; // 修改 b 也会修改 a</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; // 输出 10</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数组类型（array）"><a href="#数组类型（array）" class="headerlink" title="数组类型（array）"></a>数组类型（array）</h4><p>数组类型用于保存一组相同类型的数据，可以用下标访问数组中的元素。例如，下面的代码中，我们定义了一个数组 <code>a</code>，包含了三个整型元素：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[3] = &#123;1, 2, 3&#125;;</span><br><span class="line"></span><br><span class="line">int x = a[0];  // x = 1</span><br></pre></td></tr></table></figure><h4 id="结构体类型（struct）"><a href="#结构体类型（struct）" class="headerlink" title="结构体类型（struct）"></a>结构体类型（struct）</h4><p>结构体类型可以用于组合多个不同类型的变量，形成一个新的类型。例如，下面的代码中，我们定义了一个结构体 <code>Person</code>，包含了两个成员变量 <code>name</code> 和 <code>age</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p = &#123;&quot;Tom&quot;, 18&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="共用体类型（union）"><a href="#共用体类型（union）" class="headerlink" title="共用体类型（union）"></a>共用体类型（union）</h4><p>共用体类型可以让多个不同的变量共用一段内存空间，用于节省内存。例如，下面的代码中，我们定义了一个共用体 <code>Number</code>，可以表示一个整型数、一个浮点数或一个字符：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union Number &#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">    char c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="类类型（class）"><a href="#类类型（class）" class="headerlink" title="类类型（class）"></a>类类型（class）</h4><p>在C++中，类是一种用户自定义的数据类型，可以包含数据成员、成员函数等元素。使用class关键字定义类</p><p>类是一种用户自定义的数据类型，它可以封装数据和方法。类定义了一组相关的数据和方法，它们通常是一些有意义的操作的集合。C++中的类可以看作是一种数据类型的定义方式，类的实例化（对象）是具体的这种数据类型的实现.</p><p>类是面向对象编程（OOP）的基础，其中面向对象的思想主要体现在封装、继承和多态性方面。类可以使用访问修饰符（public、protected、private）来限制成员变量和成员函数的访问权限。类还可以包含构造函数、析构函数、静态成员、常量成员函数等特殊成员函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  private:</span><br><span class="line">    int age;</span><br><span class="line">  public:</span><br><span class="line">    void setAge(int a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.setAge(25);</span><br><span class="line">int age = p.getAge(); // age = 25</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shape</span><br><span class="line">public 成员：任何地方都可以访问，包括类的外部和派生类。</span><br><span class="line">protected 成员：只能在类内部和派生类中访问，不能在类外部访问。</span><br><span class="line">private 成员：只能在类内部访问，不能在类外部和派生类中访问。</span><br><span class="line"></span><br><span class="line">class Rectangle: public Shape&#123;&#125;</span><br><span class="line"></span><br><span class="line">public：派生类可以访问基类中的公共成员，但不能访问基类的私有成员和受保护成员。</span><br><span class="line">protected：派生类可以访问基类中的公共成员和受保护成员，但不能访问基类的私有成员。</span><br><span class="line">private：派生类不能直接访问基类中的任何成员，包括公共成员、受保护成员和私有成员。</span><br></pre></td></tr></table></figure><h4 id="模板类型"><a href="#模板类型" class="headerlink" title="模板类型"></a>模板类型</h4><p>模板类型（template）是 C++ 中非常重要的一种数据类型，它可以用来定义通用的数据类型或函数。模板类型分为类模板和函数模板两种。</p><h5 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h5><p>类模板可以用来定义通用的类，例如标准库中的容器类模板 std::vector 和 std::map，它们可以用来存储任何类型的数据，<strong>类模板是用来定义类的蓝图</strong>，<strong>其中某些成员的类型不确定</strong>，而是用类型参数来表示。类型参数可以在使用类模板时指定，从而让编译器根据指定的类型生成对应的类代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Stack &#123;</span><br><span class="line">private:</span><br><span class="line">    T* data;</span><br><span class="line">    int top;</span><br><span class="line">    int capacity;</span><br><span class="line">public:</span><br><span class="line">    Stack(int capacity) : data(new T[capacity]), top(-1), capacity(capacity) &#123;&#125;</span><br><span class="line">    ~Stack() &#123; delete[] data; &#125;</span><br><span class="line">    void push(const T&amp; value) &#123; data[++top] = value; &#125;</span><br><span class="line">    T pop() &#123; return data[top--]; &#125;</span><br><span class="line">    bool empty() const &#123; return top == -1; &#125;</span><br><span class="line">    bool full() const &#123; return top == capacity - 1; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stack&lt;int&gt; intStack(10);</span><br><span class="line">intStack.push(1);</span><br><span class="line">intStack.push(2);</span><br><span class="line">intStack.push(3);</span><br><span class="line">std::cout &lt;&lt; intStack.pop() &lt;&lt; std::endl; // 输出 3</span><br><span class="line"></span><br><span class="line">在这里，我们实例化了一个 Stack 类，并将其元素类型指定为 int，然后调用了它的 push 和 pop 函数。</span><br></pre></td></tr></table></figure><h5 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h5><p>函数模板可以用来定义通用的函数，例如标准库中的算法函数 std::sort 和 std::find，它们可以用来操作任何类型的数据，函数模板则是用来定义函数的蓝图，其中某些参数或返回值的类型不确定，而是用类型参数来表示，如下所示</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(T* first, T* last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3.14</span></span><br><span class="line"></span><br><span class="line">这是因为编译器根据参数的类型生成了对应的函数代码</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换是将一个数据类型的值转换为另一种数据类型的值。</p><p>C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。</p><h5 id="静态转换（Static-Cast）"><a href="#静态转换（Static-Cast）" class="headerlink" title="静态转换（Static Cast）"></a>静态转换（Static Cast）</h5><p>静态转换是将一种数据类型的值强制转换为另一种数据类型的值。</p><p>静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。</p><p>静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">float f = static_cast&lt;float&gt;(i); // 静态将int类型转换为float类型</span><br></pre></td></tr></table></figure><h5 id="动态转换（Dynamic-Cast）"><a href="#动态转换（Dynamic-Cast）" class="headerlink" title="动态转换（Dynamic Cast）"></a>动态转换（Dynamic Cast）</h5><p>动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = new Derived;</span><br><span class="line">Derived* ptr_derived = dynamic_cast&lt;Derived*&gt;(ptr_base); // 将基类指针转换为派生类指针</span><br></pre></td></tr></table></figure><h5 id="常量转换（Const-Cast）"><a href="#常量转换（Const-Cast）" class="headerlink" title="常量转换（Const Cast）"></a>常量转换（Const Cast）</h5><p>常量转换用于将 const 类型的对象转换为非 const 类型的对象。</p><p>常量转换只能用于转换掉 const 属性，不能改变对象的类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int i = 10;</span><br><span class="line">int&amp; r = const_cast&lt;int&amp;&gt;(i); // 常量转换，将const int转换为int</span><br></pre></td></tr></table></figure><h5 id="重新解释转换（Reinterpret-Cast）"><a href="#重新解释转换（Reinterpret-Cast）" class="headerlink" title="重新解释转换（Reinterpret Cast）"></a>重新解释转换（Reinterpret Cast）</h5><p>重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。</p><p>重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">float f = reinterpret_cast&lt;float&amp;&gt;(i); // 重新解释将int类型转换为float类型</span><br></pre></td></tr></table></figure><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><ol><li>多态性：C++ 支持静态多态和动态多态，静态多态通过函数重载和运算符重载实现，动态多态通过虚函数实现。</li><li>抽象类：C++ 中可以定义纯虚函数，一个类如果包含纯虚函数，该类就是抽象类，抽象类不能实例化对象，只能被其他类继承。</li><li>友元函数：C++ 中的友元函数可以访问类的私有成员，但不是类的成员函数，友元函数可以定义在类内或类外。</li><li>内联函数：C++ 中的内联函数在函数调用处直接展开，减少函数调用的开销，可以在函数前加 inline 关键字将其声明为内联函数。</li><li>类模板：C++ 中可以定义类模板，用来创建具有不同数据类型的类，类模板可以具有成员函数和成员变量。</li><li>构造函数和析构函数：C++ 中的构造函数用来初始化类的对象，析构函数用来清理对象所占用的资源，构造函数和析构函数都是特殊的成员函数，一个类可以有多个构造函数，但只能有一个析构函数。</li><li>拷贝构造函数和移动构造函数：C++ 中的拷贝构造函数用来复制一个对象到另一个对象，移动构造函数用来移动一个对象到另一个对象，移动构造函数可以更高效地将对象转移，避免了不必要的复制操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go python C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 单元测试</title>
      <link href="/anxiangblog.github.io/2023/04/27/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/anxiangblog.github.io/2023/04/27/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="go-test工具"><a href="#go-test工具" class="headerlink" title="go test工具"></a>go test工具</h2><p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p><p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p><p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p><table><thead><tr><th align="center">类型</th><th align="center">格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">测试函数</td><td align="center">函数名前缀为Test</td><td align="center">测试程序的一些逻辑行为是否正确</td></tr><tr><td align="center">基准函数</td><td align="center">函数名前缀为Benchmark</td><td align="center">测试函数的性能</td></tr><tr><td align="center">示例函数</td><td align="center">函数名前缀为Example</td><td align="center">为文档提供示例文档</td></tr></tbody></table><p><code>go test</code>命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><p>每个测试函数必须导入<code>testing</code>包，测试函数的基本格式（签名）如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试函数的名字必须以<code>Test</code>开头，可选的后缀名必须以大写字母开头，举几个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSum</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLog</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>其中参数<code>t</code>用于报告测试失败和附加的日志信息。 <code>testing.T</code>的拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Error(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Errorf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Fail()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> FailNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Failed() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Fatal(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Fatalf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Log(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Logf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Parallel()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Run(name <span class="type">string</span>, f <span class="function"><span class="keyword">func</span><span class="params">(t *T)</span></span>) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Skip(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> SkipNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Skipf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span></span> Skipped() <span class="type">bool</span></span><br></pre></td></tr></table></figure><h2 id="测试函数示例"><a href="#测试函数示例" class="headerlink" title="测试函数示例"></a>测试函数示例</h2><p>就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。</p><p>接下来，我们定义一个<code>split</code>的包，包中定义了一个<code>Split</code>函数，具体实现如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split/split.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="type">string</span>)</span></span> (result []<span class="type">string</span>) &#123;</span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="number">1</span>:]</span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前目录下，我们创建一个<code>split_test.go</code>的测试文件，并定义一个测试函数如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split/split_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 测试函数名必须以Test开头，必须接收一个*testing.T类型参数</span></span><br><span class="line">got := Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>)         <span class="comment">// 程序输出的结果</span></span><br><span class="line">want := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;    <span class="comment">// 期望的结果</span></span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123; <span class="comment">// 因为slice不能比较直接，借助反射包中的方法比较</span></span><br><span class="line">t.Errorf(<span class="string">&quot;expected:%v, got:%v&quot;</span>, want, got) <span class="comment">// 测试失败输出错误提示</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>split</code>包路径下，执行<code>go test</code>命令，可以看到输出结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><h2 id="测试组"><a href="#测试组" class="headerlink" title="测试组"></a>测试组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 定义一个测试用例类型</span></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">input <span class="type">string</span></span><br><span class="line">sep   <span class="type">string</span></span><br><span class="line">want  []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个存储测试用例的切片</span></span><br><span class="line">tests := []test&#123;</span><br><span class="line">&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">&quot;沙河有沙又有河&quot;</span>, sep: <span class="string">&quot;沙&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历切片，逐一执行测试用例</span></span><br><span class="line"><span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;expected:%v, got:%v&quot;</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p><code>go test -cover</code>来查看测试覆盖率</p><h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h1><p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基准测试以<code>Benchmark</code>为前缀，需要一个<code>*testing.B</code>类型的参数b，基准测试必须要执行<code>b.N</code>次，这样的测试才有对照性，<code>b.N</code>的值是系统根据实际情况去调整的，从而保证测试的稳定性。 <code>testing.B</code>拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Error(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Errorf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fail()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> FailNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Failed() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fatal(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fatalf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Log(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Logf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> ReportAllocs()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> ResetTimer()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> Run(name <span class="type">string</span>, f <span class="function"><span class="keyword">func</span><span class="params">(b *B)</span></span>) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> RunParallel(body <span class="function"><span class="keyword">func</span><span class="params">(*PB)</span></span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> SetBytes(n <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> SetParallelism(p <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skip(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> SkipNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skipf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skipped() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> StartTimer()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> StopTimer()</span><br></pre></td></tr></table></figure><h2 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a>基准测试示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Split(<span class="string">&quot;沙河有沙又有河&quot;</span>, <span class="string">&quot;沙&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基准测试并不会默认执行，需要增加<code>-bench</code>参数，所以我们通过执行<code>go test -bench=Split</code>命令执行基准测试，输出结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=Split</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8        10000000               203 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.255s</span><br></pre></td></tr></table></figure><h2 id="性能比较函数"><a href="#性能比较函数" class="headerlink" title="性能比较函数"></a>性能比较函数</h2><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p><h2 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h2><p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p><p><code>RunParallel</code>会创建出多个<code>goroutine</code>，并将<code>b.N</code>分配给这些<code>goroutine</code>执行， 其中<code>goroutine</code>数量的默认值为<code>GOMAXPROCS</code>。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在<code>RunParallel</code>之前调用<code>SetParallelism</code> 。<code>RunParallel</code>通常会与<code>-cpu</code>标志一同使用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplitParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// b.SetParallelism(1) // 设置使用的CPU数</span></span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">Split(<span class="string">&quot;沙河有沙又有河&quot;</span>, <span class="string">&quot;沙&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下基准测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8                10000000               131 ns/op</span><br><span class="line">BenchmarkSplitParallel-8        50000000                36.1 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       3.308s</span><br></pre></td></tr></table></figure><p>还可以通过在测试命令后添加<code>-cpu</code>参数如<code>go test -bench=. -cpu 1</code>来指定使用的CPU数量。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go vs C++ vs python 反射</title>
      <link href="/anxiangblog.github.io/2023/04/27/%E5%8F%8D%E5%B0%84/"/>
      <url>/anxiangblog.github.io/2023/04/27/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="go"><a href="#go" class="headerlink" title="go"></a>go</h1><p>Go语言中的变量是分为两部分的:</p><ul><li>类型信息：预先定义好的元信息。</li><li>值信息：程序运行过程中可动态变化的。</li></ul><h3 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h3><p>反射是指在程序运行期间对程序本身进行访问和修改的能力。<strong>程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息</strong>。</p><p>支持反射的语言可以在程序编译期间将<strong>变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改它们。</strong></p><p>Go程序在运行期间使用reflect包访问程序的反射信息。</p><p>在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息</p><h3 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h3><p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p><h4 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%v\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">reflectType(a) <span class="comment">// type:float32</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">reflectType(b) <span class="comment">// type:int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="type-name和type-kind"><a href="#type-name和type-kind" class="headerlink" title="type name和type kind"></a>type name和type kind</h5><p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">float32</span> <span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">reflectType(a) <span class="comment">// type: kind:ptr</span></span><br><span class="line">reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span>&#123; title <span class="type">string</span> &#125;</span><br><span class="line"><span class="keyword">var</span> d = person&#123;</span><br><span class="line">name: <span class="string">&quot;沙河小王子&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e = book&#123;title: <span class="string">&quot;《跟小王子学Go语言》&quot;</span>&#125;</span><br><span class="line">reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">reflectType(e) <span class="comment">// type:book kind:struct</span></span><br></pre></td></tr></table></figure><p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回<code>空</code>。</p><p>在<code>reflect</code>包中定义的Kind类型如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span>  <span class="comment">// 非法类型</span></span><br><span class="line">    Bool                 <span class="comment">// 布尔型</span></span><br><span class="line">    Int                  <span class="comment">// 有符号整型</span></span><br><span class="line">    Int8                 <span class="comment">// 有符号8位整型</span></span><br><span class="line">    Int16                <span class="comment">// 有符号16位整型</span></span><br><span class="line">    Int32                <span class="comment">// 有符号32位整型</span></span><br><span class="line">    Int64                <span class="comment">// 有符号64位整型</span></span><br><span class="line">    Uint                 <span class="comment">// 无符号整型</span></span><br><span class="line">    Uint8                <span class="comment">// 无符号8位整型</span></span><br><span class="line">    Uint16               <span class="comment">// 无符号16位整型</span></span><br><span class="line">    Uint32               <span class="comment">// 无符号32位整型</span></span><br><span class="line">    Uint64               <span class="comment">// 无符号64位整型</span></span><br><span class="line">    Uintptr              <span class="comment">// 指针</span></span><br><span class="line">    Float32              <span class="comment">// 单精度浮点数</span></span><br><span class="line">    Float64              <span class="comment">// 双精度浮点数</span></span><br><span class="line">    Complex64            <span class="comment">// 64位复数类型</span></span><br><span class="line">    Complex128           <span class="comment">// 128位复数类型</span></span><br><span class="line">    Array                <span class="comment">// 数组</span></span><br><span class="line">    Chan                 <span class="comment">// 通道</span></span><br><span class="line">    Func                 <span class="comment">// 函数</span></span><br><span class="line">    Interface            <span class="comment">// 接口</span></span><br><span class="line">    Map                  <span class="comment">// 映射</span></span><br><span class="line">    Ptr                  <span class="comment">// 指针</span></span><br><span class="line">    Slice                <span class="comment">// 切片</span></span><br><span class="line">    String               <span class="comment">// 字符串</span></span><br><span class="line">    Struct               <span class="comment">// 结构体</span></span><br><span class="line">    UnsafePointer        <span class="comment">// 底层指针</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h4><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Interface() interface {}</td><td align="center">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td align="center">Int() int64</td><td align="center">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td align="center">Uint() uint64</td><td align="center">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td align="center">Float() float64</td><td align="center">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td align="center">Bool() bool</td><td align="center">将值以 bool 类型返回</td></tr><tr><td align="center">Bytes() []bytes</td><td align="center">将值以字节数组 []bytes 类型返回</td></tr><tr><td align="center">String() string</td><td align="center">将值以字符串类型返回</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure><h4 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h4><p>想要在函数中通过反射修改变量的值，<strong>需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值</strong>。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line"><span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">reflectSetValue2(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isNil-和isValid"><a href="#isNil-和isValid" class="headerlink" title="isNil()和isValid()"></a>isNil()和isValid()</h4><p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><p><strong><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">c := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">&quot;娜   扎&quot;</span>)).IsValid())</span><br></pre></td></tr></table></figure><h2 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h2><h3 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h3><table><thead><tr><th>ield(i int) StructField</th><th>根据索引，返回索引对应的结构体字段的信息。</th></tr></thead><tbody><tr><td>NumField() int</td><td>返回结构体成员字段数量。</td></tr><tr><td>FieldByName(name string) (StructField, bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td>FieldByIndex(index []int) StructField</td><td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td></tr><tr><td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td>根据传入的匹配函数匹配需要的字段。</td></tr><tr><td>NumMethod() int</td><td>返回该类型的方法集中方法的数目</td></tr><tr><td>Method(int) Method</td><td>返回该类型方法集中的第i个方法</td></tr><tr><td>MethodByName(string)(Method, bool)</td><td>根据方法名返回该类型方法集中的方法</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">field := t.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射是把双刃剑"><a href="#反射是把双刃剑" class="headerlink" title="反射是把双刃剑"></a>反射是把双刃剑</h2><p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p><ol><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li><li>大量使用反射的代码通常难以理解。</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li></ol><h1 id="python反射"><a href="#python反射" class="headerlink" title="python反射"></a>python反射</h1><p>在 Python 中，我们可以使用反射机制来查看和修改对象的属性和方法，包括动态获取对象的属性和方法列表、获取和修改对象的属性值、动态调用对象的方法等。Python 中的反射机制主要通过内置函数 <code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code>、<code>delattr()</code> 和 <code>vars()</code> 等实现。</p><ul><li><code>getattr()</code> 函数可以用于获取对象的属性或方法，如果属性或方法不存在，会抛出 <code>AttributeError</code> 异常。</li><li><code>setattr()</code> 函数可以用于设置对象的属性或方法，如果属性或方法不存在，会自动添加。</li><li><code>hasattr()</code> 函数可以用于判断对象是否有指定的属性或方法，返回布尔值。</li><li><code>delattr()</code> 函数可以用于删除对象的属性或方法。</li><li><code>vars()</code> 函数可以返回对象的 <code>__dict__</code> 属性，也就是对象的属性和值组成的字典。</li><li><code>type(object)</code>: 返回对象的类型。</li><li><code>isinstance(object, classinfo)</code>: 判断对象是否为指定类型或其子类的实例。</li><li><code>issubclass(class, classinfo)</code>: 判断一个类是否为另一个类的子类。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello, my name is <span class="subst">&#123;self.name&#125;</span>. I&#x27;m <span class="subst">&#123;self.age&#125;</span> years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态获取对象的属性列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(person))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态获取对象的属性值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(person, <span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(person, <span class="string">&quot;age&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(person, <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;Unknown&quot;</span>)) <span class="comment"># 第三个参数为默认值，避免属性不存在时抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态调用对象的方法</span></span><br><span class="line">method_name = <span class="string">&quot;say_hello&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(person, method_name):</span><br><span class="line">    method = <span class="built_in">getattr</span>(person, method_name)</span><br><span class="line">    method()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态设置对象的属性</span></span><br><span class="line"><span class="built_in">setattr</span>(person, <span class="string">&quot;age&quot;</span>, <span class="number">26</span>)</span><br><span class="line"><span class="built_in">print</span>(person.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态添加对象的属性</span></span><br><span class="line"><span class="built_in">setattr</span>(person, <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;Female&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(person.gender)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除对象的属性</span></span><br><span class="line"><span class="built_in">delattr</span>(person, <span class="string">&quot;gender&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(person, <span class="string">&quot;gender&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="c-反射"><a href="#c-反射" class="headerlink" title="c++ 反射"></a>c++ 反射</h1><p>C++ 是一门静态语言，其并没有直接支持反射。C++ 可以通过元编程技术实现类似于反射的功能，比如使用模板元编程（TMP，Template Meta-Programming）技术。TMP 可以让程序在编译期间进行一些计算，从而达到运行期间反射的效果。</p><p>另外，C++11 开始支持了一种叫做 <code>type_traits</code> 的库，它提供了一些模板类型特性（Traits），可以在编译期间查询和操作类型的信息。通过这些模板类型特性，可以实现一些类似于反射的功能，比如查询类型是否具有某个成员函数、成员变量等信息。</p><p>虽然 C++ 并没有直接支持反射，但是通过 TMP 和 <code>type_traits</code> 库，可以实现类似于反射的功能。不过相比于动态语言，C++ 反射的实现较为复杂，需要更多的编码工作。</p><h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type_traits"></a><code>type_traits</code></h2><p><code>type_traits</code> 是 C++11 引入的一个头文件，它定义了一系列的类型特征（type traits），用于在编译时对类型进行分析和操作，从而更好地支持泛型编程。由于 C++ 是静态类型语言，编译器在编译阶段需要明确每个变量和函数的类型，因此使用 <code>type_traits</code> 可以在编译期间进行类型检查和操作，而不需要运行时判断，提高了代码的效率和可靠性。</p><p>它的作用有以下几个方面：</p><ol><li><strong>提供编译时对类型进行分析的功能，如判断一个类型是否为指针类型、是否为 const 类型等等。</strong></li><li><strong>提供一些转换类型的方法，如将一个类型转换为指针类型、将一个类型转换为 const 类型等等。</strong></li><li><strong>提供一些特定类型的方法，如获取一个类型的指针类型、获取一个类型的 const 类型等等。</strong></li><li><strong>支持模板元编程，即将模板作为参数，然后在编译时对模板进行处理，从而得到另一个模板。</strong></li></ol><p>下面是一些 <code>type_traits</code> 库中常用的类型特征：</p><ol><li><code>is_void</code>：判断一个类型是否为 <code>void</code>。</li><li><code>is_integral</code>：判断一个类型是否为整数类型，包括有符号整数、无符号整数和布尔类型。</li><li><code>is_floating_point</code>：判断一个类型是否为浮点数类型。</li><li><code>is_array</code>：判断一个类型是否为数组类型。</li><li><code>is_pointer</code>：判断一个类型是否为指针类型。</li><li><code>is_reference</code>：判断一个类型是否为引用类型。</li><li><code>is_const</code>：判断一个类型是否为 <code>const</code> 类型。</li><li><code>is_function</code>：判断一个类型是否为函数类型。</li><li><code>is_member_pointer</code>：判断一个类型是否为成员指针类型。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void check_type()</span><br><span class="line">&#123;</span><br><span class="line">    if(std::is_floating_point&lt;T&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; &quot;Type is float or double&quot; &lt;&lt; std::endl;</span><br><span class="line">    else</span><br><span class="line">        std::cout &lt;&lt; &quot;Type is not float or double&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    check_type&lt;int&gt;();   // Type is not float or double</span><br><span class="line">    check_type&lt;float&gt;(); // Type is float or double</span><br><span class="line">    check_type&lt;double&gt;();// Type is float or double</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>std::is_floating_point</code> 模板可以检查给定类型是否为浮点类型，如果是则返回 <code>true</code>，否则返回 <code>false</code>。在 <code>check_type</code> 函数中，我们可以使用 <code>if</code> 语句根据 <code>std::is_floating_point</code> 的返回值来判断类型是否为浮点类型。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go python C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LammpsNN安装</title>
      <link href="/anxiangblog.github.io/2023/04/23/lampnn/"/>
      <url>/anxiangblog.github.io/2023/04/23/lampnn/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="laspnn"><a href="#laspnn" class="headerlink" title="laspnn"></a>laspnn</h1><p>laspnn 安装需要intel com 和 Intelmpi，所以就学习安装一下</p><h2 id="部署oneapi-HPC版本"><a href="#部署oneapi-HPC版本" class="headerlink" title="部署oneapi HPC版本"></a>部署oneapi HPC版本</h2><p>记录一下部署<a href="https://so.csdn.net/so/search?q=oneapi&spm=1001.2101.3001.7020">oneapi</a> HPC版本的部署过程。<br>本次部署使用的是offline的方式，使用的是silent模式<br>我的操作系统版本是centos7.6</p><h3 id="offline脚本获取"><a href="#offline脚本获取" class="headerlink" title="offline脚本获取"></a>offline脚本获取</h3><p>直接从官网上获获取offline的安装脚本，offline的安装模式是最合适的。</p><p>官网地址<br>链接: <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/hpc-toolkit-download.html">https://www.intel.com/content/www/us/en/developer/tools/oneapi/hpc-toolkit-download.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://registrationcenter-download.intel.com/akdlm/irc_nas/18679/l_HPCKit_p_2022.3.0.8751_offline.sh</span><br><span class="line"></span><br><span class="line">安装模式：-a -s --eula accept</span><br><span class="line">安装路径：--install-dir /HPC/software/oneapi/2022.3.0.8751</span><br><span class="line"></span><br><span class="line">#创建部署路径</span><br><span class="line">mkdir -p /HPC/software/oneapi/2022.3.0.8751</span><br><span class="line"></span><br><span class="line">#开始部署</span><br><span class="line">sh l_HPCKit_p_2022.3.0.8751_offline.sh -a -s --eula accept  --action install  --install-dir /HPC/software/oneapi/2022.3.0.8751</span><br><span class="line">#等待部署完毕即可</span><br><span class="line"></span><br><span class="line">环境变量配置    </span><br><span class="line">export PATH=..../bin    lib   等</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装mkl"><a href="#安装mkl" class="headerlink" title="安装mkl"></a>安装mkl</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">和上面类似   </span><br><span class="line">安装模式：-a -s --eula accept</span><br><span class="line">安装路径：--install-dir</span><br><span class="line"></span><br><span class="line">完成后要配置环境变量</span><br></pre></td></tr></table></figure><h3 id="laspnn安装"><a href="#laspnn安装" class="headerlink" title="laspnn安装"></a>laspnn安装</h3><p>laspnn解压后有patch文件夹和Makefile文件 ，把patch文件下的拷贝到lammps&#x2F;src下，编辑SRC&#x2F;MAKE&#x2F;OPTRIONS&#x2F;下的makefile.intel_cpu ,拷贝 laspnn中Makefile文件到makefile.intel_cpu，src下make intel_cpu，就会生成可执行文件</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>口红和显卡</title>
      <link href="/anxiangblog.github.io/2023/04/21/%E5%8F%A3%E7%BA%A2%E5%92%8C%E6%98%BE%E5%8D%A1%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%8C%E5%93%88%E5%93%88%E5%93%88/"/>
      <url>/anxiangblog.github.io/2023/04/21/%E5%8F%A3%E7%BA%A2%E5%92%8C%E6%98%BE%E5%8D%A1%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%8C%E5%93%88%E5%93%88%E5%93%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><p>看到一个关于口红和显卡的对比，哈哈哈</p><p>6500XT       —》     卡姿兰</p><p>6600           —》      美宝莲 欧莱雅</p><p>3060ti        —》       mac</p><p>3070ti       —》        植村秀  nars</p><p>3080         —》        兰蔻   香奈儿 纪梵希  阿玛尼</p><p>3090ti      —》         圣罗兰  迪奥</p><p>4080        —-》        cpb   卢丹氏</p><p>4090       —-》         女王权杖萝卜丁</p>]]></content>
      
      
      <categories>
          
          <category> 娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elsarticle-num.bst 格式调整</title>
      <link href="/anxiangblog.github.io/2023/04/20/elsarticle-num.bst/"/>
      <url>/anxiangblog.github.io/2023/04/20/elsarticle-num.bst/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="elsarticle-num-bst"><a href="#elsarticle-num-bst" class="headerlink" title="elsarticle-num.bst"></a>elsarticle-num.bst</h1><h2 id="格式调整"><a href="#格式调整" class="headerlink" title="格式调整"></a>格式调整</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">输出文章   不想用可以注释掉</span><br><span class="line"></span><br><span class="line">FUNCTION &#123;article&#125;</span><br><span class="line">&#123;</span><br><span class="line">  output.bibitem        <span class="comment">% 输出文献条目开始</span></span><br><span class="line">  format.authors &quot;author&quot; output.check <span class="comment">% 输出作者</span></span><br><span class="line">  title empty<span class="built_in">$</span> &#x27;skip<span class="built_in">$</span> &#x27;setup.inlinelink if<span class="built_in">$</span> <span class="comment">% urlbst</span></span><br><span class="line">  format.title &quot;title&quot; output.check      <span class="comment">% 输出题目</span></span><br><span class="line">  crossref missing<span class="built_in">$</span>     <span class="comment">% 如果没有引用其他文献</span></span><br><span class="line">    &#123; format.journal    <span class="comment">% 输出期刊名称缩写</span></span><br><span class="line">      &quot;journal&quot; output.check</span><br><span class="line">      <span class="comment">% add.blank</span></span><br><span class="line">      before.all &#x27;output.state :=</span><br><span class="line">      format.vol.num.pages output <span class="comment">% 输出卷、号、页码</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123; format.article.crossref output.nonnull <span class="comment">% 如果引用了其他文献，则输出交叉引用的信息</span></span><br><span class="line">      format.pages output</span><br><span class="line">    &#125;</span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">  format.journal.pages  <span class="comment">% 输出期刊页码范围</span></span><br><span class="line">  format.note output     <span class="comment">% 输出附注信息</span></span><br><span class="line">  pages empty<span class="built_in">$</span>           <span class="comment">% 如果没有页码信息</span></span><br><span class="line">    &#123; format.date &quot;year&quot; output.check &#125; <span class="comment">% 输出年份</span></span><br><span class="line">    &#x27;skip<span class="built_in">$</span> </span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">  fin.entry              <span class="comment">% 文献条目结束</span></span><br><span class="line">  write.url              <span class="comment">% 输出网址信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个format都对应一个函数，比如 format.journal</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">journal 替换为简写的形式</span><br><span class="line">FUNCTION &#123;format.journal&#125;</span><br><span class="line">&#123; </span><br><span class="line">  journal empty<span class="built_in">$</span></span><br><span class="line">    &#123; &quot;&quot; &#125;</span><br><span class="line">    &#123; </span><br><span class="line">      journal &quot;Journal of Nuclear Materials&quot; = </span><br><span class="line">        &#123; &quot;J. Nucl. Mater.&quot; &#125;</span><br><span class="line">        &#123; journal &quot;Materials <span class="built_in">&amp;</span> Design&quot; = </span><br><span class="line">            &#123; &quot;MATER DESIGN.&quot; &#125;</span><br><span class="line">            &#123; journal &quot;Scripta Materialia&quot; = </span><br><span class="line">                &#123; &quot;Scripta Mater.&quot; &#125;</span><br><span class="line">                &#123; journal &quot;Physical Review B&quot; = </span><br><span class="line">                    &#123; &quot;Phys. Rev. B &quot; &#125;</span><br><span class="line">                    &#123; journal &#125;</span><br><span class="line">                  if<span class="built_in">$</span></span><br><span class="line">                &#125;</span><br><span class="line">              if<span class="built_in">$</span></span><br><span class="line">            &#125;</span><br><span class="line">          if<span class="built_in">$</span></span><br><span class="line">        &#125;</span><br><span class="line">      if<span class="built_in">$</span></span><br><span class="line">    &#125;</span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">format.vol.num.pages  输出卷 页码 等</span><br><span class="line"></span><br><span class="line">FUNCTION &#123;format.vol.num.pages&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">% volume field.or.null</span></span><br><span class="line">  &quot; &quot;</span><br><span class="line">  volume empty<span class="built_in">$</span></span><br><span class="line">    &#123; pop<span class="built_in">$</span> &quot;&quot; &#125;</span><br><span class="line">    &#123; volume * &#125;            //vol</span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">  number empty<span class="built_in">$</span></span><br><span class="line">    &#x27;skip<span class="built_in">$</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">%&quot;~(&quot; number * &quot;)&quot; * *      //num</span></span><br><span class="line">      volume empty<span class="built_in">$</span></span><br><span class="line">        &#123; &quot;there&#x27;s a number but no volume in &quot; cite<span class="built_in">$</span> * warning<span class="built_in">$</span> &#125;</span><br><span class="line">        &#x27;skip<span class="built_in">$</span></span><br><span class="line">      if<span class="built_in">$</span></span><br><span class="line">    &#125;</span><br><span class="line">  if<span class="built_in">$</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 语言规范</title>
      <link href="/anxiangblog.github.io/2023/04/20/go%20%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/"/>
      <url>/anxiangblog.github.io/2023/04/20/go%20%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="go-语言规范"><a href="#go-语言规范" class="headerlink" title="go 语言规范"></a>go 语言规范</h1><p>System:</p><ul><li>par_ltc: 晶体结构类型</li><li>nx, ny, nz: 模拟系统在三个维度上的大小</li><li>par_compB: 杂质浓度</li><li>par_compV: 空位浓度</li><li>Mutiple: 是否允许多个空位存在</li></ul><p>Simulation time parameters:</p><ul><li>par_time: 模拟总时间</li><li>time_conf: 输出体系状态的时间间隔</li><li>par_step: 总步数</li><li>step_log: 输出log文件的步数间隔</li></ul><p>Read File:</p><ul><li>read_file: 是否从文件中读取系统信息</li><li>filepath: 文件路径</li></ul><p>Kinetic parameters:</p><ul><li>par_temp: 模拟温度</li><li>par_beta: 波尔兹曼常数</li><li>par_dis_rec: 再生中心到复合中心的距离</li><li>par_muvA: 空位在缺陷中移动的速率</li></ul><p>Starting number of atoms:</p><ul><li>par_radius_start: 起始原子数量</li></ul><p>Energy parameters:</p><ul><li>par_eSPA, par_eSPB: A-B, B-B之间相互作用的势能参数</li><li>par_eSPA1A, par_eSPA2A, par_eSPA1B, par_eSPA2B, par_eSPA1V, par_eSPA2V: A-A, A-B, A-V之间相互作用的势能参数</li><li>par_eSPB1B, par_eSPB2B, par_eSPB1V, par_eSPB2V, par_eSPV1V, par_eSPV2V: B-B, B-V, V-V之间相互作用的势能参数</li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a><strong>命名规范</strong></h2><ol><li><p>当命名（包括常量、变量、类型、函数名、结构字段等等）以一个<strong>大写字母开头</strong>，如：Group1，那么使用这种形式的标识符的对象就<strong>可以被外部包的代码所使用</strong>（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；</p></li><li><p><strong>命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的</strong>（像面向对象语言中的 private ）</p></li><li><p>保持<strong>package</strong>的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为<strong>小写</strong>单词，不要使用下划线或者混合大小写</p></li><li><p>尽量采取有意义的文件名，简短，有意义，应该为<strong>小写</strong>单词，使用<strong>下划线</strong>分隔各个单词</p></li></ol><hr><h3 id="结构体命名"><a href="#结构体命名" class="headerlink" title="结构体命名"></a><strong>结构体命名</strong></h3><ul><li><p>采用驼峰命名法，首字母根据访问控制大写或者小写</p></li><li><p>struct 申明和初始化格式采用多行，例如下面：</p></li><li><pre><code class="go">type User struct&#123;    Username  string    Email     string&#125;// 多行初始化u := User&#123;    Username: &quot;astaxie&quot;,    Email:    &quot;astaxie@gmail.com&quot;,&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### **接口命名**</span><br><span class="line"></span><br><span class="line">- 命名规则基本和上面的结构体类型</span><br><span class="line">- 单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">type Reader interface &#123;</span><br><span class="line">        Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a><strong>变量命名</strong></h3><ul><li>和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则：</li><li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li><li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li><li>错误示例：UrlArray，应该写成 urlArray 或者 URLArray</li><li>若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> hasConflict <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> canManage <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> allowGitHook <span class="type">bool</span></span><br></pre></td></tr></table></figure><h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a><strong>常量命名</strong></h3><p>常量均需使用全部大写字母组成，并使用下划线分词</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> APP_VER = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure><p>如果是枚举类型的常量，需要先创建相应类型：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP  Scheme = <span class="string">&quot;http&quot;</span></span><br><span class="line">    HTTPS Scheme = <span class="string">&quot;https&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>下面的列表显示了Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。</p><p><img src="https://pic2.zhimg.com/80/v2-6f2ead24b6b775c30f025cdbd2dff911_720w.webp" alt="img"></p><p>Go提供C风格的<code>/* */</code>块注释和C ++风格的<code>//</code>行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。</p><ul><li>单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释</li><li>多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段</li></ul><p>go 语言自带的 godoc 工具可以根据注释生成文档，生成可以自动生成对应的网站（ <a href="https://link.zhihu.com/?target=http://golang.org">http://golang.org</a> 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在package子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在<code>godoc</code>页面上，并应设置下面的详细文档</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><h3 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a><strong>包注释</strong></h3><p>每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）：</p><ul><li>包的基本简介（包名，简介）</li><li>创建者，格式： 创建人： rtx 名</li><li>创建时间，格式：创建时间： yyyyMMdd</li></ul><p>例如 util 包的注释示例如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。</span></span><br><span class="line"><span class="comment">// 创建人： hanru</span></span><br><span class="line"><span class="comment">// 创建时间： 20190419</span></span><br></pre></td></tr></table></figure><h3 id="结构（接口）注释"><a href="#结构（接口）注释" class="headerlink" title="结构（接口）注释"></a><strong>结构（接口）注释</strong></h3><p>每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User ， 用户对象，定义了用户的基础信息</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="type">string</span> <span class="comment">// 用户名</span></span><br><span class="line">    Email     <span class="type">string</span> <span class="comment">// 邮箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数（方法）注释"><a href="#函数（方法）注释" class="headerlink" title="函数（方法）注释"></a><strong>函数（方法）注释</strong></h3><p>每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）：</p><ul><li>简要说明，格式说明：以函数名开头，“，”分隔说明部分</li><li>参数列表：每行一个参数，参数名开头，“，”分隔说明部分</li><li>返回值： 每行一个返回值</li></ul><p>示例如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewtAttrModel ， 属性数据层操作类的工厂方法</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      ctx ： 上下文信息</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      属性操作类指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAttrModel</span><span class="params">(ctx *common.Context)</span></span> *AttrModel &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码逻辑注释"><a href="#代码逻辑注释" class="headerlink" title="代码逻辑注释"></a><strong>代码逻辑注释</strong></h3><p>对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br><span class="line">xxxxx</span><br><span class="line">xxxxxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure><h3 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a><strong>注释风格</strong></h3><p>统一使用中文注释，对于中英文字符之间严格使用<strong>空格分隔</strong>， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br><span class="line">建议全部使用单行注释</span><br><span class="line">和代码的规范一样，单行注释不要过长，禁止超过 <span class="number">120</span> 字符</span><br></pre></td></tr></table></figure><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a><strong>代码风格</strong></h2><h3 id="1、缩进和折行"><a href="#1、缩进和折行" class="headerlink" title="1、缩进和折行"></a><strong>1、缩进和折行</strong></h3><ul><li>缩进直接使用 gofmt 工具格式化即可（gofmt 是使用 <strong>tab</strong> 缩进的）；</li><li>折行方面，一行最长不超过<strong>120个字符</strong>，超过的请使用换行展示，尽量保持格式优雅。</li></ul><p>我们使用Goland开发工具，可以直接使用快捷键：ctrl+alt+L，即可。</p><h3 id="2、语句的结尾"><a href="#2、语句的结尾" class="headerlink" title="2、语句的结尾"></a><strong>2、语句的结尾</strong></h3><p>Go语言中是不需要类似于Java需要冒号结尾，默认一行就是一条数据</p><p>如果你打算将多个语句写在同一行，它们则必须使用 <strong>;</strong></p><h3 id="3、括号和空格"><a href="#3、括号和空格" class="headerlink" title="3、括号和空格"></a>3、<strong>括号和空格</strong></h3><p>括号和空格方面，也可以直接使用 gofmt 工具格式化（go 会强制左大括号不换行，换行会报语法错误），所有的运算符和操作数之间要留空格。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的方式</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的方式</span></span><br><span class="line"><span class="keyword">if</span> a&gt;<span class="number">0</span>  <span class="comment">// a ，0 和 &gt; 之间应该空格</span></span><br><span class="line">&#123;       <span class="comment">// 左大括号不可以换行，会报语法错误</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、import-规范"><a href="#4、import-规范" class="headerlink" title="4、import 规范"></a><strong>4、import 规范</strong></h3><p>import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;myproject/models&quot;</span></span><br><span class="line">    <span class="string">&quot;myproject/controller&quot;</span></span><br><span class="line">    <span class="string">&quot;myproject/utils&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/astaxie/beego&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)   </span><br></pre></td></tr></table></figure><p>有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。</p><p>在项目中不要使用相对路径引入包：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是不好的导入</span></span><br><span class="line"><span class="keyword">import</span> “../net”</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是正确的做法</span></span><br><span class="line"><span class="keyword">import</span> “github.com/repo/proj/src/net”</span><br></pre></td></tr></table></figure><p>但是如果是引入本项目中的其他包，最好使用相对路径</p><h3 id="5、错误处理"><a href="#5、错误处理" class="headerlink" title="5、错误处理"></a><strong>5、错误处理</strong></h3><ul><li>错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来</li><li>尽早return：一旦有错误发生，马上返回</li><li>尽量不要使用panic，除非你知道你在做什么</li><li>错误描述如果是英文必须为小写，不需要标点结尾</li><li>采用独立的错误流进行处理</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a><strong>6、测试</strong></h3><p>单元测试文件名命名规范为 example_test.go 测试用例的函数名称必须以 Test 开头，例如：TestExample 每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include#include#includeusing namespace std;void main() &#123;  vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;a1;//定义三维数组  vector&lt;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&gt;a2;//定义四维数组  vector&lt;vector&lt;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&gt;&gt;a3;//定义五维数组    int n = 5, m = 4, k = 6, p = 3, q = 2;//可以改变，可以根据自己要求输入  //三维数组a1实例化  </span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;    </span><br><span class="line">vector&lt;vector&lt;int&gt;&gt;temp1;    </span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;     </span><br><span class="line">vector&lt;int&gt;temp2;      </span><br><span class="line">for (int v = 0; v &lt; k; v++) &#123;        </span><br><span class="line">temp2.push_back(3);//三维数组a1[n][m][k]全部赋值为3      </span><br><span class="line">&#125;     </span><br><span class="line">temp1.push_back(temp2);    </span><br><span class="line">&#125;  </span><br><span class="line">a1.push_back(temp1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//四维数组a2实例化  </span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;   </span><br><span class="line">vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;temp3;   </span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;    </span><br><span class="line">vector&lt;vector&lt;int&gt;&gt;temp4;     </span><br><span class="line">for (int v = 0; v &lt; k; v++) &#123;       </span><br><span class="line">vector&lt;int&gt;temp5;        </span><br><span class="line">for (int c = 0; c &lt; p; c++) &#123;         </span><br><span class="line">temp5.push_back(4);//四维数组a2[n][m][k][p]全部赋值为4      </span><br><span class="line">&#125;       </span><br><span class="line">temp4.push_back(temp5);    </span><br><span class="line">&#125;     </span><br><span class="line">temp3.push_back(temp4);   </span><br><span class="line">&#125;    </span><br><span class="line">a2.push_back(temp3);  &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//五维数组a3实例化  for (int i = 0; i &lt; n; i++) &#123;    vector&lt;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&gt;temp6;    for (int j = 0; j &lt; m; j++) &#123;      vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;temp7;      for (int v = 0; v &lt; k; v++) &#123;        vector&lt;vector&lt;int&gt;&gt;temp8;        for (int c = 0; c &lt; p; c++) &#123;          vector&lt;int&gt;temp9;          for (int b = 0; b &lt; q; b++) &#123;            temp9.push_back(5);//五维数组a3[n][m][k][p][q]全部赋值为5          &#125;          temp8.push_back(temp9);        &#125;        temp7.push_back(temp8);      &#125;      temp6.push_back(temp7);    &#125;    a3.push_back(temp6);  &#125;    //打印数组a3[n][m][k][p][q]，显示是否正确    for (int i = 0; i &lt; n; i++) &#123;      for (int j = 0; j &lt; m; j++) &#123;        for (int v = 0; v &lt; k; v++) &#123;          for (int c = 0; c &lt; p; c++)          &#123;            for (int b = 0; b &lt; q; b++) &#123;              a3[i][j][v][c][b] = 5;//给五维数组赋值              printf(&quot;a3[%d][%d][%d][% d][%d]=%d\t&quot;,i,j,v,c,b,a3[i][j][v][c][b]);            &#125;            //printf(&quot;\n&quot;);          &#125;          printf(&quot;\n&quot;);        &#125;        printf(&quot;\n&quot;);      &#125;      printf(&quot;\n&quot;);    &#125;    //同理可以输出三维数组a1[n][m][k]和四维数组a2[n][m][k][p]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡方测验</title>
      <link href="/anxiangblog.github.io/2023/04/19/%E5%8D%A1%E6%96%B9/"/>
      <url>/anxiangblog.github.io/2023/04/19/%E5%8D%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="卡方测验"><a href="#卡方测验" class="headerlink" title="卡方测验"></a>卡方测验</h1><p><strong>卡方检验</strong>是一种用于<strong>确定观察到的频率与期望频率之间差异</strong>的统计检验。它可以用于比较两个或更多组分类变量的频率分布，以确定它们是否来自<strong>同一总体。</strong></p><p>下面是进行卡方检验的基本步骤：</p><ol><li>提出假设：你需要提出原假设和备择假设。原假设是指两个或更多组之间没有显著差异，而备择假设则是指它们之间存在显著差异。</li><li>确定显著性水平：在进行卡方检验之前，你需要确定显著性水平，通常为0.05或0.01。这表示如果计算出的p值小于显著性水平，则可以拒绝原假设。</li><li>收集数据：你需要收集每个组的样本数据，并计算每个组的观察频率。</li><li>计算期望频率：根据原假设，计算每个组的期望频率。</li><li>计算卡方值：将观察频率和期望频率之间的<strong>差异平方除以期望频率</strong>，然后将所有结果相加，即可得到卡方值。</li><li>查找临界值：使用自由度和显著性水平查找卡方分布表格，以确定拒绝原假设所需的临界值。</li><li>进行统计检验：比较卡方值和临界值。如果卡方值大于临界值，则可以拒绝原假设，并认为组之间存在显著差异。如果卡方值小于或等于临界值，则不能拒绝原假设。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设你是一位研究人员，想要确定在某个城市中，男性和女性的吸烟率是否存在显著差异。你随机选择了200名男性和200名女性，并记录了他们是否吸烟的情况。你的原假设是男性和女性的吸烟率没有显著差异，备择假设是男性和女性的吸烟率存在显著差异。</p><p>下面是卡方检验的步骤：</p><ol><li>提出假设： <strong>原假设：男性和女性的吸烟率没有显著差异</strong>。 <strong>备择假设：男性和女性的吸烟率存在显著差异</strong>。</li><li>确定显著性水平：假设我们将显著性水平设置为<strong>0.05</strong>。</li><li>收集数据：你收集了200名男性和200名女性的数据，并记录了他们是否吸烟。结果如下：</li></ol><table><thead><tr><th></th><th>吸烟</th><th>不吸烟</th><th>总数</th></tr></thead><tbody><tr><td>男性</td><td>50</td><td>150</td><td>200</td></tr><tr><td>女性</td><td>30</td><td>170</td><td>200</td></tr><tr><td>总数</td><td>80</td><td>320</td><td>400</td></tr></tbody></table><p>计算期望频率：根据原假设，男性和女性的吸烟率相同。因此，期望频率可以通过以下公式计算：</p><p>男性吸烟人数的期望频率 &#x3D; (男性总人数 × 吸烟总人数) &#x2F; 样本总人数 &#x3D; (200 × 80) &#x2F; 400 &#x3D; 40 </p><p>男性不吸烟人数的期望频率 &#x3D; (男性总人数 × 不吸烟总人数) &#x2F; 样本总人数 &#x3D; (200 × 320) &#x2F; 400 &#x3D; 160 </p><p>女性吸烟人数的期望频率 &#x3D; (女性总人数 × 吸烟总人数) &#x2F; 样本总人数 &#x3D; (200 × 80) &#x2F; 400 &#x3D; 40 </p><p>女性不吸烟人数的期望频率 &#x3D; (女性总人数 × 不吸烟总人数) &#x2F; 样本总人数 &#x3D; (200 × 320) &#x2F; 400 &#x3D; 160</p><ol><li><p>计算卡方值：根据上面的期望频率，我们可以计算出每个单元格的卡方值，然后将所有单元格的卡方值相加，得到总的卡方值。计算公式为：</p><p>​</p></li></ol><p>​<strong>卡方值 &#x3D; Σ [ (观察频率 - 期望频率)² &#x2F; 期望频率 ]</strong></p><p>​    卡方值 &#x3D; [(50-40)² &#x2F; 40] + [(150-160)² &#x2F; 160] + [(30-40)² &#x2F; 40] + [(170-160)² &#x2F; 160] &#x3D; 2.5</p><p>  2.确定自由度：自由度的计算公式为自由度 &#x3D; (行数-1) × (列数-1)，在这个例子中，自由度为 (2-1) × (2-1) &#x3D; 1。</p><p>  3.查找卡方分布表：在自由度为1时，显著性水平0.05对应的卡方值为3.84，而计算得出的卡方值2.5小于3.84。</p><p>  4.得出结论：因为计算得出的卡方值小于临界值3.84，所以在显著性水平0.05下，我们无法拒绝原假设，即男性     和女性的吸烟率没有显著差异。</p><p><strong>卡方检验的重点在于通过计算卡方值来判断两个变量之间是否存在显著性关联。具体来说，卡方值是通过比较观察频率和期望频率之间的差异来计算的，如果两者之间差异很大，则卡方值会比较大，反之则会比较小</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>口琴乐谱</title>
      <link href="/anxiangblog.github.io/2023/04/19/%E5%8F%A3%E7%90%B4%E4%B9%90%E8%B0%B1/"/>
      <url>/anxiangblog.github.io/2023/04/19/%E5%8F%A3%E7%90%B4%E4%B9%90%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="口琴乐谱"><a href="#口琴乐谱" class="headerlink" title="口琴乐谱"></a>口琴乐谱</h1><p>搜集的几个比较简单，适合初学者的乐曲</p><h2 id="漠河舞厅"><a href="#漠河舞厅" class="headerlink" title="漠河舞厅"></a>漠河舞厅</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1#1#23#5    #4#5【#2】【#1】#5 </span><br><span class="line">#4#5【#2】【#1】#4    3#23#2(#5)</span><br><span class="line"></span><br><span class="line">(#5)#1#1#23#4#53 #5#5#57#5   </span><br><span class="line">#5#5#4#4#4#56 (#5)#5#5#5#4#2</span><br><span class="line">#1#23#4#53#53#5#5#57#5  </span><br><span class="line">#5#5#4#4#4#56  (#5)#5#5#4#2</span><br><span class="line">【#1】#5#1  #176 #56  7#4(7) (7)7#5 6#56#5  </span><br><span class="line">【#1】#5#1  #176 #56  6#56#56 6#56#56#5</span><br><span class="line"></span><br><span class="line">#3#3#3#4#5  #1【#1】#5766#56 </span><br><span class="line">66673737  77【2】 【2】【#1】【#1】【1】【#1】</span><br><span class="line">【#1】【#1】【#1】777【#1】【2】 【2】【2】【2】6667【#1】 </span><br><span class="line">【#1】【#1】77【#1】【#1】 【4】【#1】7#5 #56#4 #1#5#4</span><br><span class="line"></span><br><span class="line">#1#1#1#23#4#53 #5#5#57#5   </span><br><span class="line">#5#5#4#4#4#56 (#5)#5#5#5#4#2 </span><br><span class="line">#1#23#4#53#53#5#5#57#5  </span><br><span class="line">#5#5#4#4#4#56  (#5)#5#5#4#2</span><br><span class="line"> </span><br><span class="line">【#1】#5#1  (#5)76 #56  7【#1】【#2】7#4 6  #5#5  </span><br><span class="line">#53#1  (#5)#5#4 #56  6#56#56 6#56#56#5</span><br><span class="line"></span><br><span class="line">#3#3#3#4#5  #1【#1】#5766#56 </span><br><span class="line">66673737  77【2】 【2】【#1】【#1】【1】【#1】</span><br><span class="line">【#1】【#1】【#1】777【#1】【2】 【2】【2】【2】6667【#1】 </span><br><span class="line">【#1】【#1】77【#1】【#1】 【4】【#1】7#5 #56#4 #4#5#4</span><br><span class="line"></span><br><span class="line">#3#3#3#4#5  #1【#1】#5766#56 </span><br><span class="line">66673737  77【2】 【2】【#1】【#1】7【#1】</span><br><span class="line">【#1】【#1】【#1】777【#1】【2】 【2】【2】【3】【#1】【#1】【#1】【#5】【6】  </span><br><span class="line">【6】【#5】 【#4】【4】 【#5】【#1】【#4】 【6】【#5】 【#5】【#1】【#4】 </span><br><span class="line"></span><br><span class="line">#4#4#4 #56 7【#1】6    【#1】【#1】7【#1】【#1】</span><br><span class="line">777【#1】【2】 7【2】7【#1】【#1】【#1】7#5</span><br></pre></td></tr></table></figure><h2 id="星月神话"><a href="#星月神话" class="headerlink" title="星月神话"></a>星月神话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32121(7)1(7)(6)(5)</span><br><span class="line">(6)1(7)(5)(3)</span><br><span class="line">1232121(7)1(7)(6)(5)</span><br><span class="line">(6)3(7)121</span><br><span class="line"></span><br><span class="line">(6)1(7)12353 (6)1(7)121</span><br><span class="line"></span><br><span class="line">1232121(7)1(7)(6)(5)</span><br><span class="line">(6)1(7)1232</span><br><span class="line">1232121(7)1(7)(6)(5)</span><br><span class="line">(7)(5)(6)3(7)121</span><br><span class="line"></span><br><span class="line">356652531(6)</span><br><span class="line">(6)(7)13253</span><br><span class="line">356652531(6)</span><br><span class="line">321323(6)</span><br><span class="line"></span><br><span class="line">副歌第二段：</span><br><span class="line">356652531(6)</span><br><span class="line">3213253</span><br><span class="line">356652531(6)</span><br><span class="line">321323(6)</span><br></pre></td></tr></table></figure><h2 id="蒲公英的约定"><a href="#蒲公英的约定" class="headerlink" title="蒲公英的约定"></a>蒲公英的约定</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(#5)(6)(7)(7)(7)(7)#1#23</span><br><span class="line">3#2#4#1(7)(7)#43#5#5</span><br><span class="line">3#4#5#5#56#5#4#53</span><br><span class="line">#1#23#433#1#5#5#4</span><br><span class="line"></span><br><span class="line">(#5)(6)(7)(7)(7)(7)#1#2(7)#43</span><br><span class="line">3#2#4#1(7)(7)#43#5#5</span><br><span class="line">3#4#5#5#56#5#4#5#43</span><br><span class="line">#1#23#433#1#5#5#4</span><br><span class="line"></span><br><span class="line">(#5)(7)3#5#56#4  #47#23</span><br><span class="line">#56733#4#5#5</span><br><span class="line">(#5)(7)3#5#56#4  #47#23</span><br><span class="line">#56733#433</span><br><span class="line"></span><br><span class="line">第二遍结尾：</span><br><span class="line">【#1】7#5#43#56#4  【#1】7#23</span><br><span class="line">#56733#4#5#5</span><br><span class="line">(#5)(7)3#5#5#4#4  #47#2#43</span><br><span class="line">#56733#433</span><br></pre></td></tr></table></figure><h2 id="起风了"><a href="#起风了" class="headerlink" title="起风了"></a>起风了</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)#1(#6)</span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)(#5)(#4#2)</span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)#1(#6) (#5)(#6)(#5)(#4)(#5)</span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)#1(#6) (#5)(#6)(#5)(#4#2)</span><br><span class="line">(#6)(#5)(#4)(#5)(#4) (#6)(#5)(#4)(#5)(#4)（#1）</span><br><span class="line">(#6)(#5)(#4)(#5)(#4)</span><br><span class="line"></span><br><span class="line">(#4)(#5)(#6)(#4) #2#1#2（#4）#3#2#3</span><br><span class="line">#3#2#3 (#6)#4#5#4#3#2#1</span><br><span class="line">#2#1#2#1#2#1#2#1(#5)#1(#6)</span><br><span class="line">(#4)(#5)(#6)(#4) #2#1#2（#4）#3#2#3</span><br><span class="line">#3#2#3 (#6)#4#5#4#3#2#1</span><br><span class="line">#2#6#6 #1#2#6#6#1#2</span><br><span class="line"></span><br><span class="line">#4#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】</span><br><span class="line">#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】#6</span><br><span class="line">#5#4#2#4 #5#4#2#4#67#6#5#6#5</span><br><span class="line">#4#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】</span><br><span class="line">#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】#6</span><br><span class="line">#5#4#2#6 #5#4#2#4#4</span><br><span class="line">#2#6 #5#4#2 #6#5#4#2 #4#4</span><br><span class="line">  间奏：</span><br><span class="line">#1 #4 #5 #6 #1【#1】  #6</span><br><span class="line"> #3#4 #5 #6  #1【#1】  #6</span><br><span class="line"> #6【#1】 #5 6 #5#4#2#4</span><br><span class="line">(#6)(7)(#6) #1 #2(#6)(#5) （#4） （#2） （#4）(#6)</span><br><span class="line">(#6)(#6) (#2) (#6)(#6) (#2)</span><br><span class="line">(#6)(#6)#2#1#2</span><br><span class="line">【#1 】#6 #5#4#2#1(#6)(#5) (#4) (#2) (#1) (#2) (#4)</span><br><span class="line"> (#3) (#4)(#5)(#6)#2#1(7)(#6) (#3) (#4) #1</span><br><span class="line">  尾音：</span><br><span class="line">【#2#1】#6  【#2#1】#6【#1 】  【#2#1】#6</span><br></pre></td></tr></table></figure><h2 id="Clannad团子大家族"><a href="#Clannad团子大家族" class="headerlink" title="Clannad团子大家族"></a>Clannad团子大家族</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1=C</span><br><span class="line">【#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6 #6#7#7#5</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6#6#5  】</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6 #6#7#6</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6#5</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6 #6#7#6</span><br><span class="line">#3#2#5 #5#6 #6#7 #5#2 </span><br><span class="line">#3#2#5 #5#6#5</span><br><span class="line">【#1】#7#5#3 #5#6#3 #5#2#3#5</span><br><span class="line">【#1】#7#5#3 #5#6#3 #5</span><br><span class="line">【#1】#7#5#3 #5#6#3 #5#2#3#5 #2#5#1 </span><br><span class="line">#2#1#2#1</span><br><span class="line">(#6)#2#5#6 #6#5#3 #5#6#7【#2】#6#7#5</span><br><span class="line">#2#5#6 #6#5#3 #6#5【#2】#7</span><br><span class="line">(#6)#2#5#6 #6#5#3 #5#6#7【#2】#6#7</span><br><span class="line">#554 45#55#5#5</span><br><span class="line">(#6)#2#5#6 #6#5#3 #5#6#7【#2】#6#7#5</span><br><span class="line">#2#5#6 #6#5#3 #6#5【#2】#7</span><br><span class="line">(#6)#2#5#6 #6#5#3 #5#6#7【#2】#6#7</span><br><span class="line">#554 45#55#5   </span><br><span class="line"></span><br><span class="line">间奏   #5 5 4 #2   #6#54#5 #6#5【#21】  </span><br><span class="line">#6#54#5 #6#5【#21】     #6#54#5 #6#5【#21】</span><br></pre></td></tr></table></figure><h2 id="打上花火"><a href="#打上花火" class="headerlink" title="打上花火"></a>打上花火</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1=C</span><br><span class="line">(#6)#1#2#4#5 #3#1(7#6)#1#3#4 #4#3#2#4#3#1#1</span><br><span class="line">(#6)#1#2#4#5 #3#1(7#6)#1#3#4 #4#3#2#4#3#1#1#2 </span><br><span class="line">#2#3#4 #3#2#3#4 #3#2#3#4#1#1#2#1(#4#4) #2#1(#4#5#6) </span><br><span class="line">#2#3#4 #3#2#3#4 #3#2#3#4#5#67 #4#4#6#5#4#4</span><br><span class="line"></span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4</span><br><span class="line">#6[#1]#6#5 #6[#1#1#2] [#1]7#6</span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4</span><br><span class="line">#4#3#2#3#2 #5#3#2#3#3#4 </span><br><span class="line"></span><br><span class="line">#4#5#6 #5#4#4 #2#3#4 #3#2#1 (#6)#1#2  #3#4#3#2#1#2#1</span><br><span class="line">(#6#67)#1#2 #3#4#3 #4#5#6 #5#4#3 #1#1</span><br><span class="line">#4#5#6 #5#4#4 #2#3#4 #3#2#1 (#6)#1#2  #3#4#3#2#1#2#1 </span><br><span class="line">#2#1#2#4 #5 #6#5#4</span><br><span class="line">[#2#1]7#6 #5#67 #6#5#4 #5#67 #6#5#4</span><br><span class="line">#2#3#4#3#2#1 #1#2#4#3#1(#6)#2 </span><br><span class="line">[#2#1]7#6 #5#67 #6#5#6 7#6#5#4 #4</span><br><span class="line"></span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4 </span><br><span class="line">#6[#1]#6#5 #6[#1#1#2] [#1]7#6 </span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4 </span><br><span class="line">#4#3#2#3#2 #5#3#1(#6)#3#4</span><br><span class="line"></span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#2#1]7#6[#1#1] #2#1(7#6)#1#1</span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#1]#6#5#4#5#5 #1(#6#5#4#5#5)</span><br><span class="line">[#1]#6#5#4#5#5 #4#5#67#5</span><br><span class="line"></span><br><span class="line">(#6)#1#2#4#5 #3#1(7#6)#1#3#4 #4#3#2#4#3#1#1</span><br><span class="line">(#6)#1#2#4#5 #3#1(7#6)#1#3#4 #4#3#2#4#3#1#1#2</span><br><span class="line"></span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4</span><br><span class="line">#6[#1]#6#5 #6[#1#1#2] [#1]7#6</span><br><span class="line">#6[#1]#6 #5#4#2#4#5 #6[#1]#6 #5#4#1#4#4</span><br><span class="line">#4#3#2#3#2 #5#3#2#3#3#4 </span><br><span class="line"></span><br><span class="line">#2 #4#5 #6#4 #6#5#4#5[#1]#6 #4#1#2 #1(7)#1</span><br><span class="line">#2 #4#5 #6#4 #6#5#4#5[#1#2] #6#5 #4#5#6 #5#4#4</span><br><span class="line">#2 #4#5 #6#4 #6#5#4#5[#1]#6 #4#1#2 #1(7)#1</span><br><span class="line">#2 #4#5 #6#4 #6#5#4#5[#1#2] #6#5 #4#5#6 #5#4#4</span><br></pre></td></tr></table></figure><p>先搜集这么多，剩下的下次在更新 22333</p>]]></content>
      
      
      <categories>
          
          <category> 娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lammps安装</title>
      <link href="/anxiangblog.github.io/2023/04/19/Lammps/"/>
      <url>/anxiangblog.github.io/2023/04/19/Lammps/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="Lammps"><a href="#Lammps" class="headerlink" title="Lammps"></a>Lammps</h1><p>最近一个老师让我帮他装一个lammps跑模拟用，就花了几天时间学习了一下，总共需要配置3个包</p><p>配置环境为centos，其他同理。下载包的话<strong>最新版本</strong>。</p><h2 id="openmpi"><a href="#openmpi" class="headerlink" title="openmpi"></a>openmpi</h2><p><strong>下载地址</strong> <a href="https://link.zhihu.com/?target=https://www.open-mpi.org/software/ompi/v4.0/">https://link.zhihu.com/?target=https%3A//www.open-mpi.org/software/ompi/v4.0/</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf openmpi的文件名</span><br><span class="line">cd openmpi文件名</span><br><span class="line">./configure --prefix=openmpi安装路径   #安装路径可以新建一个local/openmpi文件夹 </span><br><span class="line">make -j 8  #多少核make        </span><br><span class="line">make check</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">安装完成没有报错配置环境变量</span><br><span class="line">vi .bashrc</span><br><span class="line">#openmpi 这是我的环境变量</span><br><span class="line">export PATH=/home/liaosi/local/openmpi/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/home/liaosi/local/openmpi/lib:LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">安装后检查一下</span><br><span class="line"></span><br><span class="line">mpicc --version：该命令将显示MPI编译器的版本信息，如果MPI已经安装，则将显示版本信息。</span><br><span class="line"></span><br><span class="line">mpirun --version：该命令将显示MPI运行时的版本信息，如果MPI已经安装，则将显示版本信息。</span><br><span class="line"></span><br><span class="line">mpiexec --version：该命令将显示MPI运行时的版本信息，如果MPI已经安装，则将显示版本信息。</span><br></pre></td></tr></table></figure><h2 id="fftw3"><a href="#fftw3" class="headerlink" title="fftw3"></a>fftw3</h2><p><strong>下载地址</strong> <a href="https://link.zhihu.com/?target=https://www.fftw.org/download.html">https://link.zhihu.com/?target=https%3A//www.fftw.org/download.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf fftw3的文件名</span><br><span class="line">cd openmpi文件名</span><br><span class="line">./configure --prefix=fftw3安装路径   #安装路径可以新建一个local/fftw3文件夹 </span><br><span class="line">make -j 8  #多少核make        </span><br><span class="line">make check</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">安装完成没有报错配置环境变量</span><br><span class="line">vi .bashrc</span><br><span class="line">#openmpi 这是我的环境变量</span><br><span class="line">export PATH=/home/liaosi/local/fft/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/home/liaosi/local/fft/lib:LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><h2 id="lammps"><a href="#lammps" class="headerlink" title="lammps"></a>lammps</h2><p><strong>下载地址</strong> <a href="https://link.zhihu.com/?target=https://www.lammps.org/download.html">https://link.zhihu.com/?target=https%3A//www.lammps.org/download.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解压lammps包，进入/src/MAKE/OPTION</span><br><span class="line"></span><br><span class="line">修改Makefile.fftw内容</span><br><span class="line">将fftw3路径改为自己的fftw3安装路径(默认路径是/usr/local)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改Makefile.g++_openmpi</span><br><span class="line">将openmpi的路径改为自己的openmpi安装路径(默认路径是/usr/local)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回到src目录，安装所需的包（可以用make package-status查看包的安装情况，这里的包是指lammps提供的一些实现特定功能的脚本，可以理解为类似于python里面的库）</span><br><span class="line"></span><br><span class="line">make yes-molecule</span><br><span class="line">make yes-rigid</span><br><span class="line">make yes-kspace</span><br><span class="line">make yes-body</span><br><span class="line">make yes-manybody</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make mpi   #会生成一个lmp_mpi 文件</span><br><span class="line"></span><br><span class="line">配置环境变量</span><br><span class="line">“#lammps2022</span><br><span class="line"></span><br><span class="line">export PATH=/home/liaosi/opt/lammps/lammps-23Jun2022/src:$PATH”</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>都按照完成后 source ~&#x2F;.bashrc 更新一下环境变量</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpirun -np 4 ../../src/lmp_mpi -in in.file    in.file 在examp文件下</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++</title>
      <link href="/anxiangblog.github.io/2023/04/18/C++%20%20%E9%87%8D%E7%82%B9/"/>
      <url>/anxiangblog.github.io/2023/04/18/C++%20%20%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\anxiangblog.github.io\assets\css\APlayer.min.css"><script src="\anxiangblog.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\anxiangblog.github.io\assets\js\Meting.min.js"></script><h1 id="C-重点"><a href="#C-重点" class="headerlink" title="C++  重点"></a>C++  重点</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>常类型是指使用类型修饰符****const****说明的类型，常类型的变量或对象的值是不能被更新的</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1.可以定义常量const int a&#x3D;100;  </p><p>2.防止修改，起保护作用，增加程序健壮性</p><p>3.类型检查 const定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。其他情况下它只是一个 <code>const</code> 限定的变量，不要将与常量混淆。</p><p>4.可以节省空间，避免不必要的内存分配const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像<code>#define</code>一样给出的是立即数。const定义的常量在程序运行过程中只有一份拷贝，而<code>#define</code>定义的常量在内存中有若干个拷贝。</p><h3 id="const对象默认为文件局部变量"><a href="#const对象默认为文件局部变量" class="headerlink" title="const对象默认为文件局部变量"></a><strong>const对象默认为文件局部变量</strong></h3><p>非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">未被const修饰的变量在不同文件的访问</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">// file1.cpp</span><br><span class="line">int ext;</span><br><span class="line">// file2.cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">extern int ext;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;(ext+10)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&gt; const常量在不同文件的访问</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">//extern_file1.cpp</span><br><span class="line">extern const int ext=12;</span><br><span class="line">//extern_file2.cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">extern const int ext;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;ext&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.定义常量</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">const int b = 10;</span><br><span class="line">b = 0; // error: assignment of read-only variable ‘b’</span><br><span class="line">const string s = &quot;helloworld&quot;;</span><br><span class="line">const int i,j=0 // error: uninitialized const ‘i’</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">上述有两个错误：</span><br><span class="line">+ b 为常量，不可更改！</span><br><span class="line">+ i 为常量，必须进行初始化！(因为常量在定义后就不能被修改，所以定义时必须初始化。)</span><br></pre></td></tr></table></figure><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a><strong>指针与const</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char * a; //指向const对象的指针或者说指向常量的指针。</span><br><span class="line">char const * a; //同上</span><br><span class="line">char * const a; //指向类型对象的const指针。或者说常指针、const指针。</span><br><span class="line">const char * const a; //指向const对象的const指针。</span><br></pre></td></tr></table></figure><p>如果<strong>const</strong>位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br>如果const位于<code>*</code>的右侧，<strong>const</strong>就是修饰指针本身，即指针本身是常量。</p><h4 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int *ptr;</span><br><span class="line">*ptr = 10; //error</span><br><span class="line">ptr是一个指向int类型const对象的指针，const定义的是int类型，也就是ptr所指向的对象类型，而不是ptr本身，所以ptr可以不用赋初始值。但是不能通过ptr去修改所指对象的值。</span><br><span class="line">除此之外，也不能使用void`*`指针保存const对象的地址，必须使用const void`*`类型的指针保存const对象的地址</span><br><span class="line"></span><br><span class="line">const int p = 10;</span><br><span class="line">const void * vp = &amp;p;</span><br><span class="line">void *vp = &amp;p; //error</span><br><span class="line"></span><br><span class="line">允许把非const对象的地址赋给指向const对象的指针</span><br><span class="line">const int *ptr;</span><br><span class="line">int val = 3;</span><br><span class="line">ptr = &amp;val; //ok</span><br><span class="line">我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!</span><br><span class="line"></span><br><span class="line">我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：</span><br><span class="line">int *ptr1 = &amp;val;</span><br><span class="line">*ptr1=4;</span><br><span class="line">cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.对于指向常量的指针，不能通过指针来修改对象的值。<br>2.不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。<br>3.允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。</p><h4 id="常指针"><a href="#常指针" class="headerlink" title="常指针"></a><strong>常指针</strong></h4><p>const指针必须进行初始化，且const指针的值不能修改。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int num=0;</span><br><span class="line">    int * const ptr=&amp;num; //const指针必须初始化！且const指针的值不能修改</span><br><span class="line">    int * t = &amp;num;</span><br><span class="line">    *t = 1;</span><br><span class="line">    cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">上述修改ptr指针所指向的值，可以通过非const指针来修改。</span><br><span class="line"></span><br><span class="line">最后，当把一个const常量的地址赋值给ptr时候，由于ptr指向的是一个变量，而不是const常量，所以会报错，出现：const int`*` -&gt; int `*`错误！</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    const int num=0;</span><br><span class="line">    int * const ptr=&amp;num; //error! const int* -&gt; int*</span><br><span class="line">    cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">上述若改为 const int `*`ptr或者改为const int `*`const ptr，都可以正常！</span><br></pre></td></tr></table></figure><h4 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a><strong>指向常量的常指针</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int p = 3;</span><br><span class="line">const int * const ptr = &amp;p; </span><br><span class="line">ptr是一个const指针，然后指向了一个int 类型的const对象。</span><br></pre></td></tr></table></figure><h3 id="函数中使用const"><a href="#函数中使用const" class="headerlink" title="函数中使用const"></a><strong>函数中使用const</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传递过来的参数及指针本身在函数内不可变，无意义！</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">void func(const int var); // 传递过来的参数不可变</span><br><span class="line">void func(int *const var); // 指针本身不可变</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">表明参数在函数体内不能被修改，但此处没有任何意义，var本身就是形参，在函数内不会改变。包括传入的形参是指针也是一样。</span><br><span class="line"></span><br><span class="line">输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**参数指针所指内容为常量不可变**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">void StringCopy(char *dst, const char *src);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。</span><br></pre></td></tr></table></figure><p><em><strong>*参数为引用，为了增加效率同时防止修改。*</strong></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void func(const A &amp;a)</span><br></pre></td></tr></table></figure><p>对于非内部数据类型的参数而言，像void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。为了提高效率，可以将函数声明改为void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。</p><p>但是函数void func(A &amp;a) 存在一个缺点：“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为void func(const A &amp;a)。</p><p>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &amp;a)。2.对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &amp;x)。</p><h3 id="类中使用const"><a href="#类中使用const" class="headerlink" title="类中使用const"></a><strong>类中使用const</strong></h3><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改 数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。</p><p>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="type">int</span> i); </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Apple::<span class="built_in">Apple</span>(<span class="type">int</span> i):<span class="built_in">apple_number</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span>对象只能访问<span class="type">const</span>成员函数,而非<span class="type">const</span>对象可以访问任意的成员函数,包括<span class="type">const</span>成员函数.</span><br><span class="line"></span><br><span class="line">此时报错，上面<span class="built_in">getCount</span>()方法中调用了一个add方法，而add方法并非<span class="type">const</span>修饰，所以运行报错。也就是说<span class="type">const</span>成员函数只能访问<span class="type">const</span>成员函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们除了上述的初始化<span class="type">const</span>常量用初始化列表方式外，也可以通过下面方法：</span><br><span class="line"></span><br><span class="line">第一：将常量定义与<span class="type">static</span>结合，也就是：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">第二：在外面初始化：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Apple::apple_number=<span class="number">10</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">当然，如果你使用c++<span class="number">11</span>进行编译，直接可以在定义出初始化，可以直接写成：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这两种都在c++<span class="number">11</span>中支持！</span><br><span class="line"></span><br><span class="line">编译的时候加上`-std=c++<span class="number">11</span>`即可！</span><br><span class="line"></span><br><span class="line">这里提到了<span class="type">static</span>，下面简单的说一下：</span><br><span class="line"></span><br><span class="line">在C++中，<span class="type">static</span>静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。</span><br><span class="line"></span><br><span class="line">在类中声明：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ap;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">在类实现文件中使用：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">int</span> Apple::ap=<span class="number">666</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">对于此项，c++<span class="number">11</span>不能进行声明并初始化，也就是上述使用方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>当与不同类型一起使用时，Static关键字具有不同的含义。我们可以使用static关键字：</p><p><em><strong>*静态变量：*</strong></em> 函数中的变量，类中的变量</p><p><em><strong>*静态类的成员：*</strong></em> 类对象和类中的函数</p><h4 id="函数中的静态变量"><a href="#函数中的静态变量" class="headerlink" title="函数中的静态变量"></a>函数中的静态变量</h4><p>当变量声明为static时，空间****将在程序的生命周期内分配*<em><strong>。即使多次调用该函数，静态变量的空间也</strong></em>*只分配一次****，前一次调用中的变量值通过下一次函数调用传递。这对于在C &#x2F; C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p><h4 id="类中的静态变量"><a href="#类中的静态变量" class="headerlink" title="类中的静态变量"></a>类中的静态变量</h4><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量****由对象共享。****对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。</p><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="*静态成员*"></a><em><strong>*静态成员*</strong></em></h4><p>类对象为静态.就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。考虑以下程序，其中对象是非静态的。</p><p>您可以清楚地看到输出的变化。现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期</p><h4 id="类中的静态函数"><a href="#类中的静态函数" class="headerlink" title="类中的静态函数"></a>类中的静态函数</h4><p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和’.’来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。</p><p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">class Apple </span><br><span class="line">&#123; </span><br><span class="line">    public: </span><br><span class="line">        // static member function </span><br><span class="line">        static void printMsg() </span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;Welcome to Apple!&quot;; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// main function </span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    // invoking a static member function </span><br><span class="line">    Apple::printMsg(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="限定访问范围"><a href="#限定访问范围" class="headerlink" title="限定访问范围**"></a><strong>限定访问范围*</strong>*</h4><p>static还有限定访问范围的作用（类似于匿名名字空间）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// source1.cpp</span><br><span class="line">extern void sayHello();</span><br><span class="line">const char* msg = &quot;Hello World!\n&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    sayHello();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// source2.cpp</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">extern char* msg;</span><br><span class="line">void sayHello()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s&quot;, msg);</span><br><span class="line">&#125;</span><br><span class="line">g++对于上面两个代码文件是可以正常编译并且打印Hello World!，但如果给source1.cpp中的msg加上static，则会导致undefined reference to &#x27;msg&#x27;的编译错误：</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><strong>this指针</strong></h2><p>相信在坐的很多人，都在学Python，对于Python来说有self，类比到C++中就是this指针，那么下面一起来深入分析this指针在类中的使用！</p><p>首先来谈谈this指针的用处：</p><p>（1）一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</p><p>（2）this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p><p>其次，this指针的使用：</p><p>（1）在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。</p><p>（2）当参数与成员变量名相同时，如this-&gt;n &#x3D; n （不能写成n &#x3D; n)。</p><p>另外，在网上大家会看到this会被编译器解析成<code>A *const </code>，<code>A const * </code>，究竟是哪一个呢？下面通过断点调试分析：</p><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。上述的get_age函数会被解析成<code>get_age(const A * const this)</code>,<code>add_age</code>函数会被解析成<code>add_age(A* const this,int a)</code>。在C++中类和结构是只有一个区别的：类的成员默认是private，而结构是public。this是类的指针，如果换成结构，那this就是结构的指针了</p><h2 id="inline那些事"><a href="#inline那些事" class="headerlink" title="inline那些事"></a><strong>inline那些事</strong></h2>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
